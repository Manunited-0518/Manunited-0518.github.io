<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="数据结构基本概念 数据 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。 数据元素、数据项 数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。 一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。 数据结构、数据对象： 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。 数据对象是具有相同性质的数据元素的集合，是数据的一个子集。 数据结构的三要素 逻辑结构，物理结构（存储结构），数据的运算。 逻辑结构 集合：各个元素同属一个集合，别无其他关系 线性结构：数据元素之间是一对一的关系。除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继 树形结构：数据元素之间是一对多的关系 图结构：数据元素之间是多对多的关系 物理结构（存储结构） 顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储 单元的邻接关系来体现。 链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。 索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址） 散列存储。根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储 其中，链式存储、索引存储、散列存储也并称为非顺序存储\n以下几点需要注意 若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用 非顺序存储，则各个数据元素在物理上可以是离散的。 数据的存储结构会影响存储空间分配的方便程度 数据的存储结构会影响对数据运算的速度 数据的运算 施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的， 指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。\n数据类型、抽象数据类型 数据类型是一个值的集合和定义在此集合上的一组操作的总称。 1）原子类型。其值不可再分的数据类型。 2）结构类型。其值可以再分解为若干成分（分量）的数据类型。 抽象数据类型（Abstract Data Type，ADT）是抽象数据组织及与之相关的操作。\nADT 用数学化的语言定义数据的逻辑结构、定义运算。与具体的实现无关。 算法的基本概念 什么是算法 程序 = 数据结构（如何用数据正确地描述现实世界的问题，并存入计算机） + 算法（如何高效地处理这些数据，以解决实际问题） 算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令 表示一个或多个操作 算法的特性 有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。用有限步骤解决某个特定的问题 注：算法必须是有穷的，而程序可以是无穷的 确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。 “好”算法的特性 设计算法时尽量遵循的目标\n正确性。算法应能够正确地解决求解问题。 可读性。算法应具有良好的可读性，以帮助人们理解。 健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。 高效率与低存储量需求 算法效率的度量 如何评估算法时间开销 算法时间复杂度： 事前预估算法时间开销T(n)与问题规模 n 的关系（T 表示 “time”） 例子：用算法表白——“爱你n遍” 1 2 3 4 5 6 7 8 void loveyou(int n){ ①int i; ②while(i&lt;=n){ ③i++; ④cout&lt;&lt;&#34;I Love You %d&#34;&lt;&lt;endl; } ⑤cout&lt;&lt;&#34;I Love You More Than %d&#34;&lt;&lt;endl; } 语句频度： ① ——1次 ② ——3001次 ③④ ——3000次 ⑤ ——1次 T(3000) = 1 + 3001 + 2*3000 + 1 时间开销与问题规模 n 的关系： T(n)=3n+3\n">
<title>数据结构---王道网课</title>

<link rel='canonical' href='http://localhost:1313/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E7%8E%8B%E9%81%93%E7%BD%91%E8%AF%BE/'>

<link rel="stylesheet" href="/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="数据结构---王道网课">
<meta property='og:description' content="数据结构基本概念 数据 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。 数据元素、数据项 数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。 一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。 数据结构、数据对象： 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。 数据对象是具有相同性质的数据元素的集合，是数据的一个子集。 数据结构的三要素 逻辑结构，物理结构（存储结构），数据的运算。 逻辑结构 集合：各个元素同属一个集合，别无其他关系 线性结构：数据元素之间是一对一的关系。除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继 树形结构：数据元素之间是一对多的关系 图结构：数据元素之间是多对多的关系 物理结构（存储结构） 顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储 单元的邻接关系来体现。 链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。 索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址） 散列存储。根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储 其中，链式存储、索引存储、散列存储也并称为非顺序存储\n以下几点需要注意 若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用 非顺序存储，则各个数据元素在物理上可以是离散的。 数据的存储结构会影响存储空间分配的方便程度 数据的存储结构会影响对数据运算的速度 数据的运算 施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的， 指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。\n数据类型、抽象数据类型 数据类型是一个值的集合和定义在此集合上的一组操作的总称。 1）原子类型。其值不可再分的数据类型。 2）结构类型。其值可以再分解为若干成分（分量）的数据类型。 抽象数据类型（Abstract Data Type，ADT）是抽象数据组织及与之相关的操作。\nADT 用数学化的语言定义数据的逻辑结构、定义运算。与具体的实现无关。 算法的基本概念 什么是算法 程序 = 数据结构（如何用数据正确地描述现实世界的问题，并存入计算机） + 算法（如何高效地处理这些数据，以解决实际问题） 算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令 表示一个或多个操作 算法的特性 有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。用有限步骤解决某个特定的问题 注：算法必须是有穷的，而程序可以是无穷的 确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。 “好”算法的特性 设计算法时尽量遵循的目标\n正确性。算法应能够正确地解决求解问题。 可读性。算法应具有良好的可读性，以帮助人们理解。 健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。 高效率与低存储量需求 算法效率的度量 如何评估算法时间开销 算法时间复杂度： 事前预估算法时间开销T(n)与问题规模 n 的关系（T 表示 “time”） 例子：用算法表白——“爱你n遍” 1 2 3 4 5 6 7 8 void loveyou(int n){ ①int i; ②while(i&lt;=n){ ③i++; ④cout&lt;&lt;&#34;I Love You %d&#34;&lt;&lt;endl; } ⑤cout&lt;&lt;&#34;I Love You More Than %d&#34;&lt;&lt;endl; } 语句频度： ① ——1次 ② ——3001次 ③④ ——3000次 ⑤ ——1次 T(3000) = 1 + 3001 + 2*3000 + 1 时间开销与问题规模 n 的关系： T(n)=3n+3\n">
<meta property='og:url' content='http://localhost:1313/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E7%8E%8B%E9%81%93%E7%BD%91%E8%AF%BE/'>
<meta property='og:site_name' content='MUBlog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2024-11-12T20:43:19&#43;08:00'/><meta property='article:modified_time' content='2024-11-12T20:43:19&#43;08:00'/>
<meta name="twitter:title" content="数据结构---王道网课">
<meta name="twitter:description" content="数据结构基本概念 数据 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。 数据元素、数据项 数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。 一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。 数据结构、数据对象： 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。 数据对象是具有相同性质的数据元素的集合，是数据的一个子集。 数据结构的三要素 逻辑结构，物理结构（存储结构），数据的运算。 逻辑结构 集合：各个元素同属一个集合，别无其他关系 线性结构：数据元素之间是一对一的关系。除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继 树形结构：数据元素之间是一对多的关系 图结构：数据元素之间是多对多的关系 物理结构（存储结构） 顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储 单元的邻接关系来体现。 链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。 索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址） 散列存储。根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储 其中，链式存储、索引存储、散列存储也并称为非顺序存储\n以下几点需要注意 若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用 非顺序存储，则各个数据元素在物理上可以是离散的。 数据的存储结构会影响存储空间分配的方便程度 数据的存储结构会影响对数据运算的速度 数据的运算 施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的， 指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。\n数据类型、抽象数据类型 数据类型是一个值的集合和定义在此集合上的一组操作的总称。 1）原子类型。其值不可再分的数据类型。 2）结构类型。其值可以再分解为若干成分（分量）的数据类型。 抽象数据类型（Abstract Data Type，ADT）是抽象数据组织及与之相关的操作。\nADT 用数学化的语言定义数据的逻辑结构、定义运算。与具体的实现无关。 算法的基本概念 什么是算法 程序 = 数据结构（如何用数据正确地描述现实世界的问题，并存入计算机） + 算法（如何高效地处理这些数据，以解决实际问题） 算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令 表示一个或多个操作 算法的特性 有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。用有限步骤解决某个特定的问题 注：算法必须是有穷的，而程序可以是无穷的 确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。 “好”算法的特性 设计算法时尽量遵循的目标\n正确性。算法应能够正确地解决求解问题。 可读性。算法应具有良好的可读性，以帮助人们理解。 健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。 高效率与低存储量需求 算法效率的度量 如何评估算法时间开销 算法时间复杂度： 事前预估算法时间开销T(n)与问题规模 n 的关系（T 表示 “time”） 例子：用算法表白——“爱你n遍” 1 2 3 4 5 6 7 8 void loveyou(int n){ ①int i; ②while(i&lt;=n){ ③i++; ④cout&lt;&lt;&#34;I Love You %d&#34;&lt;&lt;endl; } ⑤cout&lt;&lt;&#34;I Love You More Than %d&#34;&lt;&lt;endl; } 语句频度： ① ——1次 ② ——3001次 ③④ ——3000次 ⑤ ——1次 T(3000) = 1 + 3001 + 2*3000 + 1 时间开销与问题规模 n 的关系： T(n)=3n+3\n">
    <link rel="shortcut icon" href="/favicon.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu18158790818522699153.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🚀</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">MUBlog</a></h1>
            <h2 class="site-description">Welcome to my Blog!!!</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/CaiJimmy/hugo-theme-stack'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">
                    
                        <li id="i18n-switch">  
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 5h7" />
  <path d="M9 3v2c0 4.418 -2.239 8 -5 8" />
  <path d="M5 9c-.003 2.144 2.952 3.908 6.7 4" />
  <path d="M12 20l4 -9l4 9" />
  <path d="M19.1 18h-6.2" />
</svg>



                            <select name="language" title="language" onchange="window.location.href = this.selectedOptions[0].value">
                                
                                    <option value="http://localhost:1313/en/" >English</option>
                                
                                    <option value="http://localhost:1313/" selected>中文</option>
                                
                                    <option value="http://localhost:1313/ar/" >عربي</option>
                                
                            </select>
                        </li>
                    
                

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#数据">数据</a></li>
    <li><a href="#数据元素数据项">数据元素、数据项</a></li>
    <li><a href="#数据结构数据对象">数据结构、数据对象：</a></li>
    <li><a href="#数据结构的三要素">数据结构的三要素</a>
      <ol>
        <li><a href="#逻辑结构">逻辑结构</a></li>
        <li><a href="#物理结构存储结构">物理结构（存储结构）</a></li>
      </ol>
    </li>
    <li><a href="#数据的运算">数据的运算</a></li>
    <li><a href="#数据类型抽象数据类型">数据类型、抽象数据类型</a></li>
  </ol>

  <ol>
    <li><a href="#什么是算法">什么是算法</a></li>
    <li><a href="#算法的特性">算法的特性</a></li>
    <li><a href="#好算法的特性">“好”算法的特性</a></li>
  </ol>

  <ol>
    <li><a href="#如何评估算法时间开销">如何评估算法时间开销</a>
      <ol>
        <li><a href="#加法规则和乘法规则">加法规则和乘法规则</a></li>
      </ol>
    </li>
    <li><a href="#程序运行时的内存需求">程序运行时的内存需求</a>
      <ol>
        <li><a href="#函数递归带来的内存开销">函数递归带来的内存开销</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#线性表定义基本操作">线性表定义、基本操作</a>
      <ol>
        <li><a href="#定义">定义</a></li>
        <li><a href="#基本操作">基本操作</a></li>
      </ol>
    </li>
    <li><a href="#顺序表的定义">顺序表的定义</a>
      <ol>
        <li><a href="#顺序表的实现--静态分配">顺序表的实现&ndash;静态分配</a></li>
        <li><a href="#顺序表的实现--动态分配">顺序表的实现&ndash;动态分配</a></li>
      </ol>
    </li>
    <li><a href="#顺序表的插入与删除">顺序表的插入与删除</a>
      <ol>
        <li><a href="#顺序表的基本操作--插入">顺序表的基本操作&ndash;插入</a></li>
        <li><a href="#顺序表的基本操作--删除">顺序表的基本操作&ndash;删除</a></li>
      </ol>
    </li>
    <li><a href="#顺序表的查找">顺序表的查找</a>
      <ol>
        <li><a href="#按位查找">按位查找</a>
          <ol>
            <li><a href="#静态分配">静态分配</a></li>
            <li><a href="#动态分配">动态分配</a></li>
          </ol>
        </li>
        <li><a href="#按值查找">按值查找</a>
          <ol>
            <li><a href="#静态分配-1">静态分配</a></li>
            <li><a href="#动态分配-1">动态分配</a></li>
          </ol>
        </li>
        <li><a href="#单链表的定义">单链表的定义</a>
          <ol>
            <li><a href="#顺序表与单链表的优缺点">顺序表与单链表的优缺点</a></li>
            <li><a href="#单链表的代码实现">单链表的代码实现</a></li>
            <li><a href="#头插法">头插法</a></li>
            <li><a href="#不带头结点的单链表与带头结点的单链表">不带头结点的单链表与带头结点的单链表</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#单链表的插入与删除">单链表的插入与删除</a>
      <ol>
        <li><a href="#按位序插入带头结点">按位序插入（带头结点）</a></li>
        <li><a href="#按位序插入不带头结点">按位序插入（不带头结点）</a></li>
        <li><a href="#指定结点的后插操作">指定结点的后插操作</a></li>
        <li><a href="#指定结点的前插操作">指定结点的前插操作</a></li>
        <li><a href="#按位序删除带头结点">按位序删除（带头结点）</a></li>
        <li><a href="#指定结点的删除">指定结点的删除</a></li>
      </ol>
    </li>
    <li><a href="#单链表的查找">单链表的查找</a>
      <ol>
        <li><a href="#按位查找-1">按位查找</a></li>
        <li><a href="#按值查找-1">按值查找</a></li>
        <li><a href="#求表的长度">求表的长度</a></li>
      </ol>
    </li>
    <li><a href="#单链表的建立">单链表的建立</a>
      <ol>
        <li><a href="#头插法-1">头插法</a></li>
        <li><a href="#尾插法">尾插法</a></li>
      </ol>
    </li>
    <li><a href="#双链表">双链表</a>
      <ol>
        <li><a href="#单链表和双链表的区别">单链表和双链表的区别</a></li>
        <li><a href="#双链表的初始化带头结点">双链表的初始化（带头结点）</a></li>
        <li><a href="#双链表的插入">双链表的插入</a></li>
        <li><a href="#双链表的删除">双链表的删除</a>
          <ol>
            <li><a href="#删除p结点的后续结点">删除p结点的后续结点</a></li>
            <li><a href="#删除整个双链表">删除整个双链表</a></li>
          </ol>
        </li>
        <li><a href="#双链表的遍历">双链表的遍历</a>
          <ol>
            <li><a href="#后向遍历">后向遍历</a></li>
            <li><a href="#前向遍历">前向遍历</a></li>
            <li><a href="#前向遍历不带头结点">前向遍历（不带头结点）</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#循环链表">循环链表</a>
      <ol>
        <li><a href="#循环单链表">循环单链表</a>
          <ol>
            <li><a href="#初始化循环单链表">初始化循环单链表</a></li>
            <li><a href="#判断循环单链表是否为空">判断循环单链表是否为空</a></li>
            <li><a href="#判断结点p是否为循环单链表的表尾结点">判断结点p是否为循环单链表的表尾结点</a></li>
          </ol>
        </li>
        <li><a href="#循环双链表">循环双链表</a>
          <ol>
            <li><a href="#初始化循环双链表">初始化循环双链表</a></li>
            <li><a href="#判断循环单链表是否为空-1">判断循环单链表是否为空</a></li>
            <li><a href="#判断结点p是否为循环单链表的表尾结点-1">判断结点p是否为循环单链表的表尾结点</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#静态链表">静态链表</a>
      <ol>
        <li><a href="#静态链表的定义">静态链表的定义</a></li>
        <li><a href="#基本操作的简述">基本操作的简述</a></li>
        <li><a href="#静态链表的特点">静态链表的特点</a></li>
      </ol>
    </li>
    <li><a href="#顺序表和链表的对比">顺序表和链表的对比</a>
      <ol>
        <li><a href="#逻辑结构-1">逻辑结构</a></li>
        <li><a href="#存储结构">存储结构</a></li>
        <li><a href="#基本操作-1">基本操作</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#栈的基本概念">栈的基本概念</a>
      <ol>
        <li><a href="#栈的基本操作">栈的基本操作</a></li>
        <li><a href="#常见问题栈的进出栈问题">常见问题：栈的进出栈问题</a></li>
      </ol>
    </li>
    <li><a href="#顺序栈的实现">顺序栈的实现</a>
      <ol>
        <li><a href="#顺序栈的定义">顺序栈的定义</a></li>
        <li><a href="#初始化操作">初始化操作</a></li>
        <li><a href="#判空操作">判空操作</a></li>
        <li><a href="#进栈操作">进栈操作</a></li>
        <li><a href="#出栈操作">出栈操作</a></li>
        <li><a href="#读栈顶元素">读栈顶元素</a></li>
        <li><a href="#另一种方式">另一种方式</a></li>
        <li><a href="#共享栈">共享栈</a></li>
      </ol>
    </li>
    <li><a href="#链栈的实现">链栈的实现</a>
      <ol>
        <li><a href="#链栈的定义">链栈的定义</a></li>
      </ol>
    </li>
    <li><a href="#队列的基本概念">队列的基本概念</a>
      <ol>
        <li><a href="#队列的定义">队列的定义</a></li>
        <li><a href="#队列的基本操作">队列的基本操作</a></li>
      </ol>
    </li>
    <li><a href="#队列的顺序实现">队列的顺序实现</a>
      <ol>
        <li><a href="#顺序队列的定义">顺序队列的定义</a></li>
        <li><a href="#初始化操作-1">初始化操作</a></li>
        <li><a href="#判空操作-1">判空操作</a></li>
        <li><a href="#入队操作">入队操作</a></li>
        <li><a href="#判空操作-2">判空操作</a></li>
        <li><a href="#出队操作">出队操作</a></li>
        <li><a href="#获得对头元素的值用x的值">获得对头元素的值，用x的值</a></li>
        <li><a href="#判断队列已满已空">判断队列已满/已空</a>
          <ol>
            <li><a href="#方案一">方案一</a></li>
            <li><a href="#方案二">方案二</a></li>
            <li><a href="#方案三">方案三</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#队列的链式实现">队列的链式实现</a>
      <ol>
        <li><a href="#链式队列的定义">链式队列的定义</a></li>
        <li><a href="#初始化链式队列带头结点">初始化链式队列（带头结点）</a></li>
        <li><a href="#判空操作带头结点">判空操作（带头结点）</a></li>
        <li><a href="#初始化链式队列不带头结点">初始化链式队列（不带头结点）</a></li>
        <li><a href="#判空操作不带头结点">判空操作（不带头结点）</a></li>
        <li><a href="#入队带头结点">入队（带头结点）</a></li>
        <li><a href="#入队不带头结点">入队（不带头结点）</a></li>
        <li><a href="#出队带头结点">出队（带头结点）</a></li>
        <li><a href="#出队不带头结点">出队（不带头结点）</a></li>
        <li><a href="#队列满的条件">队列满的条件</a></li>
      </ol>
    </li>
    <li><a href="#双端队列">双端队列</a>
      <ol>
        <li><a href="#判断输出序列的合法性">判断输出序列的合法性</a></li>
      </ol>
    </li>
    <li><a href="#栈的应用--括号匹配">栈的应用&ndash;括号匹配</a></li>
    <li><a href="#栈的应用--表达式求值">栈的应用&ndash;表达式求值</a>
      <ol>
        <li><a href="#中缀表达式转后缀表达式手算">中缀表达式转后缀表达式（手算）</a></li>
        <li><a href="#中缀表达式转前缀表达式手算">中缀表达式转前缀表达式（手算）</a></li>
        <li><a href="#中缀表达式转后缀表达式机算">中缀表达式转后缀表达式（机算）</a></li>
        <li><a href="#中缀表达式的计算用栈实现">中缀表达式的计算（用栈实现）</a></li>
      </ol>
    </li>
    <li><a href="#栈的应用--递归">栈的应用&ndash;递归</a>
      <ol>
        <li><a href="#函数调用背后的过程">函数调用背后的过程</a></li>
        <li><a href="#栈在递归中的应用">栈在递归中的应用</a></li>
      </ol>
    </li>
    <li><a href="#队列的应用">队列的应用</a></li>
  </ol>

  <ol>
    <li><a href="#串的定义和基本操作">串的定义和基本操作</a>
      <ol>
        <li><a href="#串的定义">串的定义</a></li>
        <li><a href="#串的基本操作">串的基本操作</a></li>
        <li><a href="#串的比较操作">串的比较操作</a></li>
      </ol>
    </li>
    <li><a href="#串的存储结构">串的存储结构</a>
      <ol>
        <li><a href="#串的顺序存储">串的顺序存储</a>
          <ol>
            <li><a href="#定义-1">定义</a></li>
            <li><a href="#存储方式">存储方式</a></li>
          </ol>
        </li>
        <li><a href="#串的链式存储">串的链式存储</a></li>
        <li><a href="#基本操作的实现">基本操作的实现</a></li>
      </ol>
    </li>
    <li><a href="#字符串----朴素模式匹配算法">字符串&mdash;-朴素模式匹配算法</a>
      <ol>
        <li><a href="#朴素模式匹配算法">朴素模式匹配算法</a></li>
      </ol>
    </li>
    <li><a href="#字符串----kmp算法">字符串&mdash;-KMP算法</a>
      <ol>
        <li><a href="#kmp算法">KMP算法</a></li>
        <li><a href="#next数组">next数组</a></li>
      </ol>
    </li>
    <li><a href="#kmp算法----求next数组">KMP算法&mdash;-求next数组</a></li>
    <li><a href="#kmp算法----进一步优化">KMP算法&mdash;-进一步优化</a></li>
  </ol>

  <ol>
    <li><a href="#树的定义与基本术语">树的定义与基本术语</a>
      <ol>
        <li><a href="#树的基本概念">树的基本概念</a></li>
        <li><a href="#有序树vs无序树">有序树V.S无序树</a></li>
        <li><a href="#树vs森林">树V.S森林</a></li>
      </ol>
    </li>
    <li><a href="#树的常考性质">树的常考性质</a></li>
    <li><a href="#二叉树的定义与基本定语">二叉树的定义与基本定语</a>
      <ol>
        <li><a href="#二叉树的基本概念">二叉树的基本概念</a></li>
        <li><a href="#几种特殊的二叉树">几种特殊的二叉树</a></li>
      </ol>
    </li>
    <li><a href="#二叉树常考性质">二叉树常考性质</a>
      <ol>
        <li><a href="#二叉树常考性质-1">二叉树常考性质</a></li>
        <li><a href="#完全二叉树常考性质">完全二叉树常考性质</a></li>
      </ol>
    </li>
    <li><a href="#二叉树的存储结构">二叉树的存储结构</a>
      <ol>
        <li><a href="#二叉树的顺序存储">二叉树的顺序存储</a></li>
        <li><a href="#二叉树的链式存储">二叉树的链式存储</a></li>
      </ol>
    </li>
    <li><a href="#二叉树的先中后序遍历">二叉树的先中后序遍历</a></li>
    <li><a href="#二叉树的层次遍历">二叉树的层次遍历</a></li>
    <li><a href="#由遍历序列来构造二叉树">由遍历序列来构造二叉树</a></li>
    <li><a href="#线索二叉树的概念">线索二叉树的概念</a></li>
    <li><a href="#二叉树的线索化">二叉树的线索化</a></li>
    <li><a href="#在线索二叉树中找前驱后继">在线索二叉树中找前驱后继</a>
      <ol>
        <li><a href="#中序线索二叉树找中序后继">中序线索二叉树找中序后继</a></li>
        <li><a href="#中序线索二叉树找中序前驱">中序线索二叉树找中序前驱</a></li>
      </ol>
    </li>
    <li><a href="#树的存储结构">树的存储结构</a>
      <ol>
        <li><a href="#树的逻辑结构">树的逻辑结构</a></li>
        <li><a href="#如何实现树的顺序存储">如何实现树的顺序存储</a></li>
      </ol>
    </li>
    <li><a href="#树森林与二叉树的转换">树、森林与二叉树的转换</a>
      <ol>
        <li><a href="#树-二叉树的转换">树-&gt;二叉树的转换</a></li>
        <li><a href="#森林-二叉树的转换">森林-&gt;二叉树的转换</a></li>
        <li><a href="#二叉树-树的转换">二叉树-&gt;树的转换</a></li>
        <li><a href="#二叉树-森林的转换">二叉树-&gt;森林的转换</a></li>
      </ol>
    </li>
    <li><a href="#树森林的遍历">树、森林的遍历</a>
      <ol>
        <li><a href="#树的先根遍历和后根遍历">树的先根遍历和后根遍历</a></li>
        <li><a href="#树的层次遍历">树的层次遍历</a></li>
        <li><a href="#森林的先序遍历中序遍历">森林的先序遍历、中序遍历</a></li>
      </ol>
    </li>
    <li><a href="#哈夫曼树">哈夫曼树</a>
      <ol>
        <li><a href="#带权路径长度">带权路径长度</a></li>
        <li><a href="#哈夫曼树的定义">哈夫曼树的定义</a></li>
        <li><a href="#哈夫曼树的构造">哈夫曼树的构造</a></li>
        <li><a href="#哈夫曼编码">哈夫曼编码</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#图的基本概念">图的基本概念</a>
      <ol>
        <li><a href="#图的定义">图的定义</a></li>
        <li><a href="#无向图有向图">无向图、有向图</a></li>
        <li><a href="#简单图多重图">简单图、多重图</a></li>
        <li><a href="#顶点的度入度出度">顶点的度、入度、出度</a></li>
        <li><a href="#顶点-顶点的关系描述">顶点-顶点的关系描述</a></li>
        <li><a href="#连通图强连通图">连通图、强连通图</a></li>
        <li><a href="#研究图的局部一一子图">研究图的局部一一子图</a></li>
        <li><a href="#连通分量">连通分量</a></li>
        <li><a href="#生成树">生成树</a></li>
        <li><a href="#边的权带权图网">边的权、带权图/网</a></li>
        <li><a href="#几种特形态的图">几种特形态的图</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E7%8E%8B%E9%81%93%E7%BD%91%E8%AF%BE/">数据结构---王道网课</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Nov 12, 2024</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 20 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="数据结构基本概念">数据结构基本概念
</h1><h2 id="数据">数据
</h2><ul>
<li>数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。</li>
</ul>
<h2 id="数据元素数据项">数据元素、数据项
</h2><ul>
<li>数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。</li>
<li>一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。</li>
</ul>
<h2 id="数据结构数据对象">数据结构、数据对象：
</h2><ul>
<li>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</li>
<li>数据对象是具有相同性质的数据元素的集合，是数据的一个子集。</li>
</ul>
<h2 id="数据结构的三要素">数据结构的三要素
</h2><ul>
<li>逻辑结构，物理结构（存储结构），数据的运算。</li>
</ul>
<h3 id="逻辑结构">逻辑结构
</h3><ul>
<li>集合：各个元素同属一个集合，别无其他关系</li>
<li>线性结构：数据元素之间是一对一的关系。除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继</li>
<li>树形结构：数据元素之间是一对多的关系</li>
<li>图结构：数据元素之间是多对多的关系</li>
</ul>
<h3 id="物理结构存储结构">物理结构（存储结构）
</h3><ul>
<li>顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储
单元的邻接关系来体现。</li>
<li>链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。</li>
<li>索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）</li>
<li>散列存储。根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储</li>
</ul>
<p>其中，链式存储、索引存储、散列存储也并称为非顺序存储</p>
<ul>
<li>以下几点需要注意</li>
</ul>
<ol>
<li>若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用
非顺序存储，则各个数据元素在物理上可以是离散的。</li>
<li>数据的存储结构会影响存储空间分配的方便程度</li>
<li>数据的存储结构会影响对数据运算的速度</li>
</ol>
<h2 id="数据的运算">数据的运算
</h2><p>施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，
指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。</p>
<h2 id="数据类型抽象数据类型">数据类型、抽象数据类型
</h2><p>数据类型是一个值的集合和定义在此集合上的一组操作的总称。
1）原子类型。其值不可再分的数据类型。
2）结构类型。其值可以再分解为若干成分（分量）的数据类型。
抽象数据类型（Abstract Data Type，ADT）是抽象数据组织及与之相关的操作。</p>
<ul>
<li>ADT 用数学化的语言定义数据的逻辑结构、定义运算。与具体的实现无关。</li>
</ul>
<h1 id="算法的基本概念">算法的基本概念
</h1><h2 id="什么是算法">什么是算法
</h2><ul>
<li>程序 = 数据结构（如何用数据正确地描述现实世界的问题，并存入计算机） + 算法（如何高效地处理这些数据，以解决实际问题）</li>
<li>算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令
表示一个或多个操作</li>
</ul>
<h2 id="算法的特性">算法的特性
</h2><ul>
<li>有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。用有限步骤解决某个特定的问题
注：算法必须是有穷的，而程序可以是无穷的</li>
<li>确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。</li>
</ul>
<h2 id="好算法的特性">“好”算法的特性
</h2><p>设计算法时尽量遵循的目标</p>
<ul>
<li>正确性。算法应能够正确地解决求解问题。</li>
<li>可读性。算法应具有良好的可读性，以帮助人们理解。</li>
<li>健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。</li>
<li>高效率与低存储量需求</li>
</ul>
<h1 id="算法效率的度量">算法效率的度量
</h1><h2 id="如何评估算法时间开销">如何评估算法时间开销
</h2><ul>
<li>算法时间复杂度：
事前预估算法时间开销T(n)与问题规模 n 的关系（T 表示 “time”）</li>
<li>例子：用算法表白——“爱你n遍”</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">loveyou</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="err">①</span><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="err">②</span><span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">     <span class="err">③</span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="err">④</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;I Love You %d&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="err">⑤</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;I Love You More Than %d&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>语句频度：
① ——1次
② ——3001次
③④ ——3000次
⑤ ——1次
T(3000) = 1 + 3001 + 2*3000 + 1
时间开销与问题规模 n 的关系：
T(n)=3n+3</p>
<ul>
<li>结论：1.可以只考虑阶数高的部分<br>
2.问题规模足够大时，常数项系数也可以忽略</li>
</ul>
<h3 id="加法规则和乘法规则">加法规则和乘法规则
</h3><p>a）加法规则
T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n)))
b）乘法规则
T(n) = T1(n)×T2(n) = O(f(n))×O(g(n)) = O(f(n)×g(n))
Eg：T3(n)= n3 + n2 log2n
= O(n3) + O(n2 log2n)
= ？？？</p>
<ul>
<li>1.顺序执行的代码只会影响常数项，可以忽略
2.只需挑循环中的一个基本操作分析它的执行次数与 n 的关系即可
3.如果有多层嵌套循环，只需关注最深层循环循环了几次</li>
<li>最坏时间复杂度：最坏情况下算法的时间复杂度
平均时间复杂度：所有输入示例等概率出现的情况下，算法的期望运行时间
最好时间复杂度：最好情况下算法的时间复杂度</li>
</ul>
<h2 id="程序运行时的内存需求">程序运行时的内存需求
</h2><ul>
<li>无论问题规模怎么变，算法运行所需的内存空间都是固定的常量，算法空间复杂度为S(n) = O(1)
注：S 表示 “Space”算法原地工作——算法所需内存空间为常量</li>
<li>O(1) &lt; O(log2n) &lt; O(n) &lt; O(nlog2n) &lt; O(n2) &lt; O(n3) &lt; O(2n) &lt; O(n!) &lt; O(nn)</li>
</ul>
<h3 id="函数递归带来的内存开销">函数递归带来的内存开销
</h3><p>空间复杂度 = 递归调用的深度</p>
<h1 id="线性表">线性表
</h1><h2 id="线性表定义基本操作">线性表定义、基本操作
</h2><h3 id="定义">定义
</h3><ul>
<li>
<p>线性表是具有相同数据类型的n（n≥0）个数据元素的有限 序列，其中n为表长，当n = 0时线
性表是一个空表。若用L命名线性表，则其一般表示为L = (a1, a2, &hellip; , ai, ai+1, &hellip; , an)</p>
</li>
<li>
<p>几个概念：
ai 是线性表中的“第i个”元素线性表中的位序
a1 是表头元素；an 是表尾元素。
除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继
a1 a2 a3 a4 a5</p>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog8.png"
	
	
	
	loading="lazy"
	
		alt="线性表结构图"
	
	
></p>
</li>
<li>
<p>有次序
注意：位序从1开始
数组下标从0开始
每个数据元素所占空间一样大</p>
</li>
</ul>
<h3 id="基本操作">基本操作
</h3><ul>
<li>
<p>InitList(&amp;L):初始化表。构造一个空的线性表L，分配内存空间。</p>
<p>DestroyList(&amp;L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</p>
<p>ListInsert(&amp;L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e。</p>
<p>ListDelete(&amp;L,i,&amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。</p>
<p>LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。</p>
<p>GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。</p>
<p>其他常用操作：</p>
<p>Length(L)：求表长。返回线性表L的长度，即L中数据元素的个数。</p>
<p>PrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值。</p>
<p>Empty(L)：判空操作。若L为空表，则返回true，否则返回false。</p>
<p>Key：命名要有可读性</p>
</li>
</ul>
<blockquote>
<p>Tips：
①对数据的操作（记忆思路） —— 创销、增删改查
②C语言函数的定义 —— &lt;返回值类型&gt; 函数名 (&lt;参数1类型&gt; 参数1，&lt;参数2类型&gt; 参数2，&hellip;&hellip;)
③实际开发中，可根据实际需求定义其他的基本操作
④函数名和参数的形式、命名都可改变（Reference：严蔚敏版《数据结构》）
⑤什么时候要传入引用“&amp;” —— 对参数的修改结果需要“带回来”</p>
</blockquote>
<h2 id="顺序表的定义">顺序表的定义
</h2><p>线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列。</p>
<ul>
<li>顺序表——用顺序存储的方式实现线性表顺序存储。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog9.png"
	
	
	
	loading="lazy"
	
	
></p>
<h3 id="顺序表的实现--静态分配">顺序表的实现&ndash;静态分配
</h3><ul>
<li>代码实现：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#define MaxSize 10 </span><span class="c1">//定义最大长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ElemType</span> <span class="n">data</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span> <span class="c1">//用静态的“数组”存放数据元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span> <span class="c1">//顺序表的当前长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">SqList</span><span class="p">;</span> <span class="c1">//顺序表的类型定义（静态分配方式）
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>InitList函数（静态分配）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">InitList</span><span class="p">(</span><span class="n">SqList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">MaxSize</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意：如果不进行初始化，内存中会有遗留的“脏数据”，但其实如果正常访问的话（指在进行访问数据的时候，没有赋值的不去访问），也不会有影响，也可以直接把长度设为零即可。</p>
<h3 id="顺序表的实现--动态分配">顺序表的实现&ndash;动态分配
</h3><ul>
<li>代码实现：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#define InitSize 10 </span><span class="c1">//顺序表的初始长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ElemType</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span> <span class="c1">//指示动态分配数组的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">MaxSize</span><span class="p">;</span> <span class="c1">//顺序表的最大容量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span> <span class="c1">//顺序表的当前长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">SeqList</span><span class="p">;</span> <span class="c1">//顺序表的类型定义（动态分配方式）
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>malloc函数
L.data = (ElemType *) malloc (sizeof(ElemType) * InitSize)
<strong>注：需要包含头文件&lt;stdlib.h&gt;</strong></li>
<li>InitList函数（动态分配）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">InitLIst</span><span class="p">(</span><span class="n">SqList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">InitSize</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="p">.</span><span class="n">Maxsize</span><span class="o">=</span><span class="n">InitSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>IncreaseSize函数（动态分配）（增加数组的长度）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">IncreaseSize</span><span class="p">(</span><span class="n">SqList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">len</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">L</span><span class="p">.</span><span class="n">MaxSize</span><span class="o">+</span><span class="n">len</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="p">.</span><span class="n">MaxSize</span><span class="o">+=</span><span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>顺序表的特点：
①随机访问，即可以在 O(1) 时间内找到第 i 个元素。
②存储密度高，每个节点只存储数据元素
③拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）
④插入、删除操作不方便，需要移动大量元素</li>
</ul>
<h2 id="顺序表的插入与删除">顺序表的插入与删除
</h2><h3 id="顺序表的基本操作--插入">顺序表的基本操作&ndash;插入
</h3><p>ListInsert(&amp;L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e。
注：本节代码建立在顺序表的“静态分配”实现方式之上，“动态分配” 也雷同。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">ListInsert</span><span class="p">(</span><span class="n">SqList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">||</span><span class="n">i</span><span class="o">&gt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//判断i的值是否有效
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">&gt;</span><span class="n">L</span><span class="p">.</span><span class="n">MaxSize</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span><span class="c1">//当前存储空间已满，不能插入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;=</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">e</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>注：好的算法，应该具有“健壮性”。能处理异常情况，并给使用者反馈</strong></p>
<ul>
<li><strong>时间复杂度的计算：</strong>
最好情况：新元素插入到表尾，不需要移动元素
i = n+1，循环0次；最好时间复杂度 = O(1)
最坏情况：新元素插入到表头，需要将原有的 n 个元素全都向后移动
i = 1，循环 n 次；最坏时间复杂度 = O(n);
平均情况：假设新元素插入到任何一个位置的概率相同，即 i = 1,2,3, &hellip; , length+1
平均时间复杂度 = O(n)</li>
</ul>
<h3 id="顺序表的基本操作--删除">顺序表的基本操作&ndash;删除
</h3><p>ListDelete(&amp;L,i,&amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">ListDelete</span><span class="p">(</span><span class="n">SqList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">||</span><span class="n">i</span><span class="o">&gt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">e</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="顺序表的查找">顺序表的查找
</h2><h3 id="按位查找">按位查找
</h3><p>GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。</p>
<h4 id="静态分配">静态分配
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#define MaxSize 10 </span><span class="c1">//定义最大长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ElemType</span> <span class="n">data</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span> <span class="c1">//用静态的“数组”存放数据元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span> <span class="c1">//顺序表的当前长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">SqList</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ElemType</span> <span class="nf">GetElem</span><span class="p">(</span><span class="n">SqList</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="动态分配">动态分配
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#define InitSize 10 </span><span class="c1">//顺序表的初始长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ElemType</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span> <span class="c1">//指示动态分配数组的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">MaxSize</span><span class="p">;</span> <span class="c1">//顺序表的最大容量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span> <span class="c1">//顺序表的当前长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">SeqList</span><span class="p">;</span> <span class="c1">//顺序表的类型定义（动态分配方式）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ElemType</span> <span class="nf">GetElem</span><span class="p">(</span><span class="n">SeqList</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意，时间复杂度为O(1)</p>
<h3 id="按值查找">按值查找
</h3><p>LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。</p>
<h4 id="静态分配-1">静态分配
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">LocateElem</span><span class="p">(</span><span class="n">SeqList</span> <span class="n">L</span><span class="p">,</span><span class="n">ElemType</span> <span class="n">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="c1">//数组下标为i的元素值等于e，返回其位序i+1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//退出循环，说明查找失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="动态分配-1">动态分配
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">LocateElem</span><span class="p">(</span><span class="n">SeqList</span> <span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="单链表的定义">单链表的定义
</h3><h4 id="顺序表与单链表的优缺点">顺序表与单链表的优缺点
</h4><ul>
<li>顺序表：优点：可随机存取，存储密度高
缺点：要求大片连续空间，改变容量不方便</li>
<li>单链表：优点：不要求大片连续空间，改变容量方便
缺点：不可随机存取，要耗费一定空间存放指针</li>
</ul>
<h4 id="单链表的代码实现">单链表的代码实现
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">LNode</span><span class="o">*</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ElemType</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="nc">LNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="n">LNode</span><span class="p">,</span><span class="n">LinkList</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>增加一个新的结点：在内存中申请一个结点所需空间，并用指针 p 指向这个结点
struct LNode * p = (struct LNode *) malloc(sizeof(struct LNode));</li>
<li>typedef 关键字 —— 数据类型重命名
typedef &lt;数据类型&gt; &lt;别名&gt;</li>
<li>强调这是一个单链表 ——使用 LinkList
强调这是一个结点 ——使用 LNode *</li>
<li>GetElem函数的代码实现（更好地理解LNode *和LinkList)</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">LNode</span> <span class="o">*</span><span class="nf">GetElem</span><span class="p">(</span><span class="n">LinkList</span> <span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">L</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">j</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="头插法">头插法
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">LinkList</span> <span class="nf">List_HeadInsert</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span><span class="c1">//逆向建立单链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">LNode</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">LinkList</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span><span class="c1">//创建头结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">L</span><span class="o">-</span><span class="n">next</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span><span class="c1">//初始化为空链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">x</span><span class="p">;</span><span class="c1">//输入结点的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="o">!=</span><span class="mi">9999</span><span class="err">）</span><span class="p">{</span><span class="c1">//输入9999表示结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="n">LNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span><span class="c1">//创建新结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">s</span><span class="p">;</span><span class="c1">//将新结点插入表中，L为头指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">L</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="不带头结点的单链表与带头结点的单链表">不带头结点的单链表与带头结点的单链表
</h4><ul>
<li>
<p>带头结点，写代码更方便，用过都说好
初始化代码实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">InitList</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>判空代码实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">Empty</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">L</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>不带头结点，写代码更麻烦对第一个数据结点和后续数据结点的处理需要用不同的代码逻辑对空表和非空表的处理需要用不同的代码逻辑
初始化代码实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">InitList</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">LNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span><span class="c1">//分配一个头结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//内存不足，分配失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="nb">NULL</span><span class="err">；</span><span class="c1">//头结点暂时还没有结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>判空代码实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">Empty</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="单链表的插入与删除">单链表的插入与删除
</h2><h3 id="按位序插入带头结点">按位序插入（带头结点）
</h3><p>ListInsert(&amp;L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">ListInsert</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">ElemType</span> <span class="n">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LNOde</span> <span class="o">*</span><span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="n">LNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">e</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="按位序插入不带头结点">按位序插入（不带头结点）
</h3><p>不存在 “第0个”结点，因此 i=1 时需要特殊处理</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">ListInsert</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">ElemType</span> <span class="n">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">LNode</span> <span class="o">*</span><span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="n">LNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">e</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">L</span><span class="o">=</span><span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LNOde</span> <span class="o">*</span><span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="n">LNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">e</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="指定结点的后插操作">指定结点的后插操作
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">InsertNextNode</span><span class="p">(</span><span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="n">ElemType</span> <span class="n">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LNode</span> <span class="o">*</span><span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="n">LNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//内存分配失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">e</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="指定结点的前插操作">指定结点的前插操作
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">InsertPriorNode</span><span class="p">(</span><span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="n">ElemType</span> <span class="n">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LNode</span> <span class="o">*</span><span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="n">LNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//内存分配失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">e</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>王道书版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">InsertPriorNode</span><span class="p">(</span><span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="n">LNode</span> <span class="o">*</span><span class="n">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="nb">NULL</span><span class="o">||</span><span class="n">s</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ElemType</span> <span class="n">temp</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="按位序删除带头结点">按位序删除（带头结点）
</h3><p>ListDelete(&amp;L,i,&amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">ListDelete</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">ElemType</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">){</span><span class="c1">//循环找到i-1个结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//i值不合法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//i-1后已无其他结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">LNode</span> <span class="o">*</span><span class="n">q</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">e</span><span class="o">=</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="指定结点的删除">指定结点的删除
</h3><p>ListDelete(LNode *p)：删除指定结点p。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">ListDelete</span><span class="p">(</span><span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LNode</span> <span class="o">*</span><span class="n">q</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-</span><span class="n">next</span><span class="o">=</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意：如果p是最后一个结点&hellip;只能从表头开始依次寻找p的前驱，时间复杂度 O(n)</p>
<h2 id="单链表的查找">单链表的查找
</h2><h3 id="按位查找-1">按位查找
</h3><p>GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">LNode</span> <span class="o">*</span><span class="nf">GetElem</span><span class="p">(</span><span class="n">LinkList</span> <span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="p">){</span><span class="c1">//循环找到i个结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>王道书版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">LNode</span> <span class="o">*</span><span class="nf">GetElem</span><span class="p">(</span><span class="n">LinkList</span> <span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">L</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="按值查找-1">按值查找
</h3><p>LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">LNode</span> <span class="o">*</span><span class="nf">LocateElem</span><span class="p">(</span><span class="n">LinkList</span> <span class="n">L</span><span class="p">,</span><span class="n">ElemType</span> <span class="n">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">!=</span><span class="n">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">         <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="求表的长度">求表的长度
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">length</span><span class="p">(</span><span class="n">LinkList</span> <span class="n">L</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">len</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="单链表的建立">单链表的建立
</h2><h3 id="头插法-1">头插法
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">LinkList</span> <span class="nf">List_HeadInsert</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span> <span class="c1">//逆向建立单链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">LNode</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">LinkList</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span> <span class="c1">//创建头结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span> <span class="c1">//初始为空链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">x</span><span class="p">;</span> <span class="c1">//输入结点的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="o">!=</span><span class="mi">9999</span><span class="p">){</span> <span class="c1">//输入9999表示结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="n">LNode</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span> <span class="c1">//创建新结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">s</span><span class="p">;</span> <span class="c1">//将新结点插入表中，L为头指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">L</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="尾插法">尾插法
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">LinkList</span> <span class="nf">List_TailInsert</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span><span class="c1">//正向建立单链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">LNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span><span class="c1">//建立头结点（初始化空表）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">LNode</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="o">*</span><span class="n">r</span><span class="p">;</span><span class="o">=</span><span class="n">L</span><span class="p">;</span><span class="c1">//r为表尾指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">x</span><span class="p">;</span><span class="c1">//输入结点的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="o">!=</span><span class="mi">9999</span><span class="p">){</span><span class="c1">//输入9999表示结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="n">LNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">s</span><span class="p">;</span><span class="c1">//以上三步表示在r结点之后插入x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">r</span><span class="o">=</span><span class="n">s</span><span class="p">;</span><span class="c1">//r指向新的结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span><span class="c1">//尾指针置空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">L</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>头插法的重要应用：链表的逆置</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">ListNode</span><span class="o">*</span> <span class="nf">reverseList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">newHead</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span><span class="c1">// 新链表头节点，初始为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span><span class="o">*</span> <span class="n">nextNode</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">// 保存原链表的下一个节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">newHead</span><span class="p">;</span><span class="c1">// 当前节点插入到新链表头部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">newHead</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span><span class="c1">// 更新新链表的头节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">head</span> <span class="o">=</span> <span class="n">nextNode</span><span class="p">;</span><span class="c1">// 移动到下一个节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">newHead</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="双链表">双链表
</h2><h3 id="单链表和双链表的区别">单链表和双链表的区别
</h3><ul>
<li>单链表：无法逆向检索，有时候不太方便</li>
<li>双链表：可进可退，存储密度更低一丢丢</li>
</ul>
<h3 id="双链表的初始化带头结点">双链表的初始化（带头结点）
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">DNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ElemType</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">DNode</span> <span class="o">*</span><span class="n">prior</span><span class="p">,</span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">DNode</span><span class="p">,</span> <span class="o">*</span><span class="n">DLinkList</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">InitDLinkList</span><span class="p">(</span><span class="n">DLinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">DNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">DNode</span><span class="p">));</span><span class="c1">//建立头结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="o">-&gt;</span><span class="n">prior</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span><span class="c1">//prior永远指向NULL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span><span class="c1">//next后暂时还没有结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="双链表的插入">双链表的插入
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">InsertNextNode</span><span class="p">(</span><span class="n">DNode</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="n">DNode</span> <span class="o">*</span><span class="n">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="nb">NULL</span><span class="o">||</span><span class="n">q</span><span class="o">==</span><span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prior</span><span class="o">=</span><span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">prior</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="双链表的删除">双链表的删除
</h3><h4 id="删除p结点的后续结点">删除p结点的后续结点
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">DeleteNextDNode</span><span class="p">(</span><span class="n">DNode</span> <span class="o">*</span><span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">DNode</span> <span class="o">*</span><span class="n">q</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">q</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//p没有后继
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span><span class="c1">//q结点不是最后一个结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prior</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span><span class="c1">//释放空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="删除整个双链表">删除整个双链表
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">DestroyList</span><span class="p">(</span><span class="n">DLinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">DeleteNextDNode</span><span class="p">(</span><span class="n">L</span><span class="p">);</span><span class="c1">//循环释放各个结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">free</span><span class="p">(</span><span class="n">L</span><span class="p">);</span><span class="c1">//释放头结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">L</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span><span class="c1">//头指针指向NULL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="双链表的遍历">双链表的遍历
</h3><h4 id="后向遍历">后向遍历
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//对结点p做相应处理，如打印
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="前向遍历">前向遍历
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//对结点p做相应处理，如打印
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prior</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="前向遍历不带头结点">前向遍历（不带头结点）
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span> <span class="n">prior</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//对结点p做相应处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prior</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="循环链表">循环链表
</h2><h3 id="循环单链表">循环单链表
</h3><p>循环单链表的特点：</p>
<ul>
<li>单链表：表尾结点的next指针指向 NULL
从一个结点出发只能找到后续的各个结点</li>
<li>循环单链表：表尾结点的next指针指向头结点
从一个结点出发可以找到其他任何一个结点</li>
</ul>
<h4 id="初始化循环单链表">初始化循环单链表
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">InitList</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">LNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">L</span><span class="p">;</span><span class="c1">//头结点next指向头结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="判断循环单链表是否为空">判断循环单链表是否为空
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">Empty</span><span class="p">(</span><span class="n">LinkList</span> <span class="n">L</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">==</span><span class="n">L</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="判断结点p是否为循环单链表的表尾结点">判断结点p是否为循环单链表的表尾结点
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">isTail</span><span class="p">(</span><span class="n">LinkList</span> <span class="n">L</span><span class="p">,</span><span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">==</span><span class="n">L</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="循环双链表">循环双链表
</h3><ul>
<li>双链表：表头结点的 prior 指向 NULL；
表尾结点的 next 指向 NULL</li>
<li>循环双链表：表头结点的 prior 指向表尾结点；
表尾结点的 next 指向头结点</li>
</ul>
<h4 id="初始化循环双链表">初始化循环双链表
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">InitDList</span><span class="p">(</span><span class="n">DLinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">DNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">DNode</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">L</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="o">-&gt;</span><span class="n">prior</span><span class="o">=</span><span class="n">L</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="判断循环单链表是否为空-1">判断循环单链表是否为空
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">Empty</span><span class="p">(</span><span class="n">DLinkList</span> <span class="n">L</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">==</span><span class="n">L</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="判断结点p是否为循环单链表的表尾结点-1">判断结点p是否为循环单链表的表尾结点
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">isTail</span><span class="p">(</span><span class="n">DLinkList</span> <span class="n">L</span><span class="p">,</span><span class="n">DNode</span> <span class="o">*</span><span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">==</span><span class="n">L</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="静态链表">静态链表
</h2><ul>
<li>单链表：各个结点在内存中星罗棋布、散落天涯。</li>
<li>静态链表：分配一整片连续的内存空间，各个结
点集中安置。</li>
</ul>
<h3 id="静态链表的定义">静态链表的定义
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#define MaxSize 10</span><span class="c1">//静态链表的最大长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">Node</span><span class="p">{</span><span class="c1">//静态链表结构类型的定义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ElemType</span> <span class="n">data</span><span class="p">;</span><span class="c1">//存储数据元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">next</span><span class="p">;</span><span class="c1">//下一个元素的数组下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">SLinkList</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>SLinkList b —— 相当于定义了一个长度为 MaxSize 的 Node型数组</p>
<h3 id="基本操作的简述">基本操作的简述
</h3><ul>
<li>初始化静态链表：把 a[0] 的 next 设为 -1，把其他结点的 next 设为一个特殊值用来表示结点空闲，如 -2</li>
<li>查找：从头结点出发挨个往后遍历结点</li>
<li>删除某个结点：
①从头结点出发找到前驱结点
②修改前驱结点的游标
③被删除结点 next 设为 -2</li>
<li>插入位序为i的结点：1.找到一个空的结点，存入数据元素
2.从头结点出发找到位序为i-1的结点
3.修改新结点的next
4.修改i-1号结点的next</li>
</ul>
<h3 id="静态链表的特点">静态链表的特点
</h3><p>静态链表：用数组的方式实现的链表
优点：增、删 操作不需要大量移动元素
缺点：不能随机存取，只能从头结点开始依次往后查找；容量固定不可变
适用场景：①不支持指针的低级语言；②数据元素数量固定不变的场景（如操作系统的文件分配表FAT）</p>
<h2 id="顺序表和链表的对比">顺序表和链表的对比
</h2><h3 id="逻辑结构-1">逻辑结构
</h3><p>都属于线性表，都是线性结构</p>
<h3 id="存储结构">存储结构
</h3><ul>
<li>顺序表：优点：支持随机存取、存储密度高
缺点：大片连续空间分配不方便，改变容量不方便</li>
<li>链表：优点：离散的小空间分配方便，改变容量方便
缺点：不可随机存取，存储密度低</li>
</ul>
<h3 id="基本操作-1">基本操作
</h3><ul>
<li>顺序表：1.需要预分配大片连续空间。若分配空间过小，则之后不方便拓展容量；若分配空间过大，则浪费内存资源
2.插入/删除元素要将后续元素都后移/前移
3.时间复杂度 O(n)，时间开销主要来自移动元素
4.移动的时间代价很高
5.按位查找：O(1)
6.按值查找：O(n)若表内元素有序，可在O(log2n) 时间内找到</li>
<li>链表：1.只需分配一个头结点（也可以不要头结点，只声明一个头指针），之后方便拓展
2.插入/删除元素只需修改指针即可
3.时间复杂度 O(n)，时间开销主要来自查找目标元素
4.查找元素的时间代价更低
5.按位查找：O(n)
6.按值查找：O(n）</li>
</ul>
<h1 id="栈队列和数组">栈、队列和数组
</h1><h2 id="栈的基本概念">栈的基本概念
</h2><ul>
<li>线性表是具有相同数据类型的n（n≥0）个数据元素的有限 序列，其中n为表长，当n = 0时线
性表是一个空表。若用L命名线性表，则其一般表示为
L = (a1, a2, &hellip; , ai, ai+1, &hellip; , an)</li>
<li>栈（Stack）是只允许在一端进行插入或删除操作的线性表</li>
</ul>
<h3 id="栈的基本操作">栈的基本操作
</h3><p>InitStack(&amp;S)：初始化栈。构造一个空栈 S，分配内存空间。</p>
<p>DestroyStack(&amp;S)：销毁栈。销毁并释放栈 S 所占用的内存空间。</p>
<p>Push(&amp;S,x)：进栈，若栈S未满，则将x加入使之成为新栈顶。</p>
<p>Pop(&amp;S,&amp;x)：出栈，若栈S非空，则弹出栈顶元素，并用x返回。</p>
<p>GetTop(S, &amp;x)：读栈顶元素。若栈 S 非空，则用 x 返回栈顶元素</p>
<p>其他常用操作：</p>
<p>StackEmpty(S)：判断一个栈 S 是否为空。若S为空，则返回true，否则返回false。</p>
<h3 id="常见问题栈的进出栈问题">常见问题：栈的进出栈问题
</h3><p>进栈顺序：
a-&gt;b-&gt;c-&gt;d-&gt;e
有哪些合法的出栈顺序？
n个不同元素进栈，出栈元素不同排列的个数为1/n+1C<sub>2n</sub><sup>n</sup></p>
<p>上述公式称为卡特兰（Catalan）数，可采用数学归纳法证明（不要求掌握）。</p>
<h2 id="顺序栈的实现">顺序栈的实现
</h2><h3 id="顺序栈的定义">顺序栈的定义
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#define MaxSize 10
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ElemType</span> <span class="n">data</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span><span class="c1">//静态数组中存放栈中元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">top</span><span class="p">;</span><span class="c1">//栈顶指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">SqStack</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="初始化操作">初始化操作
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">InitStack</span><span class="p">(</span><span class="n">SqStack</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">S</span><span class="p">.</span><span class="n">top</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="判空操作">判空操作
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">StackEmpty</span><span class="p">(</span><span class="n">SqStack</span> <span class="n">S</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">top</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="进栈操作">进栈操作
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">Push</span><span class="p">(</span><span class="n">SqStack</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">,</span><span class="n">ElemType</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">top</span><span class="o">==</span><span class="n">MaxSize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//栈满，操作失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">S</span><span class="p">.</span><span class="n">top</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">S</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">S</span><span class="p">.</span><span class="n">top</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//这两步可以直接写为S.data[++S.top]=x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="出栈操作">出栈操作
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">pop</span><span class="p">(</span><span class="n">SqStack</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">,</span><span class="n">ElemType</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">top</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//栈空，报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">x</span><span class="o">=</span><span class="n">S</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">S</span><span class="p">.</span><span class="n">top</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">S</span><span class="p">.</span><span class="n">top</span><span class="o">-=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//这两步可以直接写为x=S.data[S.top--]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="读栈顶元素">读栈顶元素
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">GetTop</span><span class="p">(</span><span class="n">SqStack</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">,</span><span class="n">ElemType</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">top</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="o">=</span><span class="n">S</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">S</span><span class="p">.</span><span class="n">top</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="另一种方式">另一种方式
</h3><p>另一种方式就是把S.top的初始值设为0，其他地方一致</p>
<h3 id="共享栈">共享栈
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#define MaxSize 10
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ElemType</span> <span class="n">data</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">top0</span><span class="p">;</span><span class="c1">//0号栈栈顶指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">top1</span><span class="p">;</span><span class="c1">//1号栈栈顶指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">ShStack</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>初始化栈</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">InitStack</span><span class="p">(</span><span class="n">SqStack</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">S</span><span class="p">.</span><span class="n">top0</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">S</span><span class="p">.</span><span class="n">top1</span><span class="o">=</span><span class="n">MaxSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意！栈满的条件：top0 + 1 == top1</p>
<h2 id="链栈的实现">链栈的实现
</h2><h3 id="链栈的定义">链栈的定义
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">LinkNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ElemType</span> <span class="n">data</span><span class="p">;</span><span class="c1">//数据域
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="nc">LinkNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="c1">//指针域
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="o">*</span><span class="n">LiStack</span><span class="p">;</span><span class="c1">//栈类型定义
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>进栈/出栈都只能在栈顶一端进行（链头作为栈顶）</p>
<h2 id="队列的基本概念">队列的基本概念
</h2><h3 id="队列的定义">队列的定义
</h3><ul>
<li>队列（Queue）是只允许在一端进行插入，在另一端删除的线性表</li>
<li>队列的特点：先进先出
First In First Out（FIFO）</li>
<li>队头：允许删除的一端</li>
<li>队尾：允许插入的一端</li>
</ul>
<h3 id="队列的基本操作">队列的基本操作
</h3><p>InitQueue(&amp;Q)：初始化队列，构造一个空队列Q。</p>
<p>DestroyQueue(&amp;Q)：销毁队列。销毁并释放队列Q所占用的内存空间。</p>
<p>EnQueue(&amp;Q,x)：入队，若队列Q未满，将x加入，使之成为新的队尾。</p>
<p>DeQueue(&amp;Q,&amp;x)：出队，若队列Q非空，删除队头元素，并用x返回。</p>
<p>GetHead(Q,&amp;x)：读队头元素，若队列Q非空，则将队头元素赋值给x。</p>
<p>其他常用操作：</p>
<p>QueueEmpty(Q)：判队列空，若队列Q为空返回true，否则返回false。</p>
<h2 id="队列的顺序实现">队列的顺序实现
</h2><h3 id="顺序队列的定义">顺序队列的定义
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#define MaxSize 10
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ElemType</span> <span class="n">data</span><span class="p">[</span><span class="n">MaxSzie</span><span class="p">];</span><span class="c1">//用静态数组存放队列元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">front</span><span class="p">,</span><span class="n">rear</span><span class="p">;</span><span class="c1">//队头指针和队尾指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">SqQueue</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意：rear指向队尾元素的后一个位置（下一个应该插入的位置）</p>
<h3 id="初始化操作-1">初始化操作
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">InitQueue</span><span class="p">(</span><span class="n">SqQueue</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="o">=</span><span class="n">Q</span><span class="p">.</span><span class="n">rear</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="判空操作-1">判空操作
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">QueueEmpty</span><span class="p">(</span><span class="n">SqQueue</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">Q</span><span class="p">.</span><span class="n">rear</span><span class="o">==</span><span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="入队操作">入队操作
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">EnQueue</span><span class="p">(</span><span class="n">SqQueue</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span><span class="n">ElemType</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">((</span><span class="n">Q</span><span class="p">.</span><span class="n">rear</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">MaxSize</span><span class="o">==</span><span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Q</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">Q</span><span class="p">.</span><span class="n">rear</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Q</span><span class="p">.</span><span class="n">rear</span><span class="o">=</span><span class="p">(</span><span class="n">Q</span><span class="p">.</span><span class="n">rear</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">MaxSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>队列已满的条件：队尾指针的再下一个位置是队头，即
(Q.rear+1)%MaxSize==Q.front</p>
<h3 id="判空操作-2">判空操作
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">QueueEmpty</span><span class="p">(</span><span class="n">SqQueue</span> <span class="n">Q</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">Q</span><span class="p">.</span><span class="n">rear</span><span class="o">==</span><span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="出队操作">出队操作
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">DeQueue</span><span class="p">(</span><span class="n">SqQueue</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span><span class="n">ElemType</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">Q</span><span class="p">.</span><span class="n">rear</span><span class="o">==</span><span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="o">=</span><span class="n">Q</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="o">=</span><span class="p">(</span><span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;</span><span class="n">MaxSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="获得对头元素的值用x的值">获得对头元素的值，用x的值
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">GetHead</span><span class="p">(</span><span class="n">SqQueue</span> <span class="n">Q</span><span class="p">,</span><span class="n">ElemType</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">Q</span><span class="p">.</span><span class="n">rear</span><span class="o">==</span><span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="o">=</span><span class="n">Q</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="判断队列已满已空">判断队列已满/已空
</h3><h4 id="方案一">方案一
</h4><ul>
<li>队列已满的条件：队尾指针的再下一个位置是队头，即(Q.rear+1)%MaxSize==Q.front</li>
<li>队空条件：Q.rear==Q.front</li>
<li>队列元素个数：(rear+MaxSize-front)%MaxSize</li>
<li>缺点：浪费了一个存储空间
<img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog10.png"
	
	
	
	loading="lazy"
	
	
></li>
</ul>
<h4 id="方案二">方案二
</h4><ul>
<li>定义数据结构时，多定义一个int类型的size，插入成功size++，插入失败size&ndash;</li>
<li>队列已满的条件：size==MaxSize</li>
<li>队空条件：size==0</li>
</ul>
<h4 id="方案三">方案三
</h4><ul>
<li>定义数据结构时，多定义一个int类型的tag，每次删除操作成功时，都令tag=0；每次插入操作成功时，都令tag=1；只有删除操作，才可能导致队空；只有插入操作，才可能导致队满</li>
<li>队满条件：front==rear &amp;&amp; tag == 1</li>
<li>队空条件：front==rear &amp;&amp; tag == 0</li>
</ul>
<h2 id="队列的链式实现">队列的链式实现
</h2><h3 id="链式队列的定义">链式队列的定义
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">LinkNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ElemType</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">LinkNode</span> <span class="o">*</span><span class="n">next</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">LinkNode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LinkNode</span> <span class="o">*</span><span class="n">front</span><span class="p">,</span><span class="o">*</span><span class="n">rear</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">LinkQueue</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="初始化链式队列带头结点">初始化链式队列（带头结点）
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">InitQueue</span> <span class="p">(</span><span class="n">LinkQueue</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//初始时 front、rear 都指向头结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Q</span><span class="p">.</span> <span class="n">front</span><span class="o">=</span><span class="n">Q</span><span class="p">.</span> <span class="n">rear</span><span class="o">=</span><span class="p">(</span><span class="n">LinkNode</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LinkNode</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">Q</span><span class="p">.</span> <span class="n">front</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="判空操作带头结点">判空操作（带头结点）
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">IsEmpty</span> <span class="p">(</span><span class="n">LinkQueue</span> <span class="n">Q</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">Q</span><span class="p">.</span> <span class="n">front</span><span class="o">==</span><span class="n">Q</span><span class="p">.</span> <span class="n">rear</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="初始化链式队列不带头结点">初始化链式队列（不带头结点）
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">InitQueue</span> <span class="p">(</span><span class="n">LinkQueue</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">){</span>
</span></span><span class="line"><span class="cl"><span class="c1">//初始时front、rear都指向NULL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Q</span><span class="p">.</span> <span class="n">front</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Q</span><span class="p">.</span> <span class="n">rear</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="判空操作不带头结点">判空操作（不带头结点）
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">IsEmpty</span> <span class="p">(</span><span class="n">LinkQueue</span> <span class="n">Q</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="入队带头结点">入队（带头结点）
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">EnQueue</span> <span class="p">(</span><span class="n">LinkQueue</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span> <span class="n">ElemType</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">LinkNode</span> <span class="o">*</span><span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="n">LinkNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LinkNode</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Q</span><span class="p">.</span><span class="n">rear</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">s</span><span class="p">;</span><span class="c1">//新结点插入到rear之后
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Q</span><span class="p">.</span><span class="n">rear</span><span class="o">=</span><span class="n">s</span><span class="p">;</span><span class="c1">//修改表尾指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="入队不带头结点">入队（不带头结点）
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">EnQueue</span><span class="p">(</span><span class="n">LinkQueue</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span> <span class="n">ElemType</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">LinkNode</span> <span class="o">*</span><span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="n">LinkNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LinkNode</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">NULLi</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">Q</span><span class="p">.</span><span class="n">front</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">){</span><span class="c1">//在空队列中插入第一个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Q</span><span class="p">.</span><span class="n">front</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Q</span><span class="p">.</span> <span class="n">rear</span><span class="o">=</span><span class="n">s</span><span class="p">;</span><span class="c1">//修改队头队尾指针不带头结点的队列，第一个元素入队时需要特别处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Q</span><span class="p">.</span> <span class="n">rear</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">s</span><span class="p">;</span><span class="c1">//新结点插入到 rear 结点之后
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Q</span><span class="p">.</span> <span class="n">rear</span><span class="o">=</span><span class="n">s</span><span class="p">;</span><span class="c1">//修改 rear 指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="出队带头结点">出队（带头结点）
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">DeQueue</span><span class="p">(</span><span class="n">LinkQueue</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span> <span class="n">ElemType</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="o">==</span><span class="n">Q</span><span class="p">.</span><span class="n">rear</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//空队
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">LinkNode</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span><span class="c1">//用变量x返回队头元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="c1">//修改头结点的 next 指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">Q</span><span class="p">.</span><span class="n">rear</span><span class="o">==</span><span class="n">p</span><span class="p">)</span><span class="c1">//此次是最后一个结点出队
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Q</span><span class="p">.</span> <span class="n">rear</span><span class="o">=</span><span class="n">Q</span><span class="p">.</span> <span class="n">front</span><span class="p">;</span><span class="c1">//修改 rear 指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="c1">//释放结点空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="出队不带头结点">出队（不带头结点）
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">DeQueue</span><span class="p">(</span><span class="n">LinkQueue</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span> <span class="n">ElemType</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">Q</span><span class="p">.</span> <span class="n">front</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//空队
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">LinkNode</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="p">;</span><span class="c1">//p指向此次出队的结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">x</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="c1">//用变量x返回队头元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Q</span><span class="p">.</span> <span class="n">front</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//修改 front 指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">Q</span><span class="p">.</span> <span class="n">rear</span><span class="o">==</span><span class="n">p</span><span class="p">){</span><span class="c1">//此次是最后一个结点出队
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Q</span><span class="p">.</span> <span class="n">front</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Q</span><span class="p">.</span> <span class="n">rear</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">free</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="c1">//释放结点空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="队列满的条件">队列满的条件
</h3><p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog11.png"
	
	
	
	loading="lazy"
	
	
></p>
<h2 id="双端队列">双端队列
</h2><p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog12.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>![](<a class="link" href="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/"  target="_blank" rel="noopener"
    >https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/</a>截屏2024-12-02 18.46.59.png)</p>
<h3 id="判断输出序列的合法性">判断输出序列的合法性
</h3><p>根据逻辑进行判断即可</p>
<h2 id="栈的应用--括号匹配">栈的应用&ndash;括号匹配
</h2><p>最后出现的左括号最先被匹配(LIFO)，每出现一个右括号，就“消耗”（出栈）一个左括号</p>
<ul>
<li>
<p>算法流程图
<img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog14.png"
	
	
	
	loading="lazy"
	
	
></p>
</li>
<li>
<p>算法实现</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">bracketCheck</span><span class="p">(</span><span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">SqStack</span> <span class="n">S</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">InitStack</span><span class="err">（</span><span class="n">S</span><span class="err">）；</span> <span class="c1">//初始化一个栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="err">（</span><span class="n">strlil</span><span class="o">==</span><span class="sc">&#39;（&#39;</span><span class="o">||</span> <span class="n">strlil</span><span class="o">==</span><span class="sc">&#39;［&#39;</span><span class="n">I</span><span class="o">|</span> <span class="n">strli</span><span class="err">］</span><span class="o">==</span><span class="sc">&#39;｛&#39;</span><span class="err">）｛</span>
</span></span><span class="line"><span class="cl">            <span class="n">Push</span><span class="err">（</span><span class="n">S</span><span class="err">，</span><span class="n">str</span><span class="err">［</span><span class="n">i</span><span class="err">］）；</span><span class="c1">//扫描到左括号，入栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">else</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">StackEmpty</span><span class="p">(</span><span class="n">S</span><span class="p">))</span><span class="mi">1</span><span class="o">/</span><span class="err">扫描到右括号，且当前栈空</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//匹配失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="n">topElem</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Pop</span><span class="err">（</span><span class="n">S</span><span class="p">,</span><span class="n">topElem</span><span class="err">）；</span> <span class="c1">//栈顶元素出栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="sc">&#39;)&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">topElem</span><span class="o">!=</span><span class="sc">&#39;(&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="sc">&#39;]&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">topElem</span><span class="o">!=</span><span class="sc">&#39;[&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="sc">&#39;}&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">topElem</span><span class="o">!=</span><span class="sc">&#39;{&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">StackEmpty</span><span class="err">（</span><span class="n">S</span><span class="err">）；</span> <span class="c1">//检索完全部括号后，栈空说明匹配成功
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意：考试中可直接使用基本操作，建议简要说明接口</p>
<p>//初始化栈
void InitStack(SqStack &amp;S)
//判断栈是否为空
bool StackEmpty(SqStack S)
//新元素入栈
bool Push(SqStack &amp;S, char x)
11栈顶元素出栈，用×返回
bool Pop (SqStack &amp;S, char &amp;x)</p>
<h2 id="栈的应用--表达式求值">栈的应用&ndash;表达式求值
</h2><p>表达式分为三个部分：操作数、运算符、界限符</p>
<ul>
<li>波兰科学家的一个灵感：可以不用界限符也能无歧义地表达运算顺序
Reverse Polish notation（逆波兰表达式=后缀表达式）
Polish notation（波兰表达式=前缀表达式）</li>
<li>中缀表达式&mdash;运算符在两个操作数中间
后缀表达式&mdash;运算符在两个操作数后面
前缀表达式&mdash;运算符在两个操作数前面</li>
</ul>
<h3 id="中缀表达式转后缀表达式手算">中缀表达式转后缀表达式（手算）
</h3><p>中缀转后缀的手算方法：
① 确定中缀表达式中各个运算符的运算顺序
② 选择下一个运算符，按照「左操作数 右操作数运算符」的方式组合成一个新的操作数
③ 如果还有运算符没被处理，就继续 ②</p>
<ul>
<li>
<p>私房菜：“左优先”原则，不要Freestyle，保证手算和机算结果相同
“左优先”原则：只要左边的运算符能先计算，就优先算左边的&mdash;-可保证运算顺序唯一</p>
</li>
<li>
<p>运算顺序不唯一，因此对应的后缀表达式也不唯一</p>
</li>
<li>
<p>后缀表达式的计算方法（手算）：
从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，合体为一个操作数
注意：两个操作数的左右顺序
特点：最后出现的操作数先被运算</p>
</li>
<li>
<p>用栈实现后缀表达式的计算（机算）：
①从左往右扫描下一个元素，直到处理完所有元素
②若扫描到操作数则压入栈，并回到①；否则执行③
③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①
注意：先出栈的是“右操作数”
若表达式合法，则最后栈中只会留下一个元素，就是最终结果</p>
</li>
</ul>
<h3 id="中缀表达式转前缀表达式手算">中缀表达式转前缀表达式（手算）
</h3><p>中缀转前缀的手算方法：
① 确定中缀表达式中各个运算符的运算顺序
② 选择下一个运算符，按照「运算符 左操作数 右操作数」的方式组合成一个新的操作数
③ 如果还有运算符没被处理，就继续②
“右优先”原则：只要右边的运算符能先计算，就优先算右边的
注意：先出栈的是“左操作数”</p>
<h3 id="中缀表达式转后缀表达式机算">中缀表达式转后缀表达式（机算）
</h3><p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。
从左到右处理各个元素，直到末尾。可能遇到三种情况：
① 遇到操作数。直接加入后缀表达式。
② 遇到界限符。遇到“(”直接入栈；遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到弹出“(”为止。注意：“(”不加入后缀表达式。
③ 遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“(”或栈空则停止。之后再把当前运算符入栈。
按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p>
<h3 id="中缀表达式的计算用栈实现">中缀表达式的计算（用栈实现）
</h3><p>用栈实现中缀表达式的计算：
初始化两个栈，操作数栈和运算符栈
若扫描到操作数，压入操作数栈
若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈）</p>
<ul>
<li>本质：中缀转后缀+后缀表达式求值，两个算法的结合</li>
</ul>
<h2 id="栈的应用--递归">栈的应用&ndash;递归
</h2><h3 id="函数调用背后的过程">函数调用背后的过程
</h3><ul>
<li>函数调用的特点：最后被调用的函数最先执行结束（LIFO）
函数调用时，需要用一个栈存储：
① 调用返回地址
② 实参
③ 局部变量</li>
</ul>
<h3 id="栈在递归中的应用">栈在递归中的应用
</h3><p>适合用“递归”算法解决：可以把原始问题转换为属性相同，但规模较小的问题</p>
<ul>
<li>Eg1：计算正整数的阶乘 n！
<img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog15.png"
	
	
	
	loading="lazy"
	
		alt="阶乘"
	
	
></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">factorial</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span> <span class="o">||</span> <span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">n</span><span class="o">*</span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>递归调用时，函数调用栈可称为“递归工作栈”
每进入一层递归，就将递归调用所需信息压入栈顶
每退出一层递归，就从栈顶弹出相应信息</p>
<p>缺点：太多层递归可能会导致栈溢出</p>
<ul>
<li>Eg 2：求斐波那契数列
<img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog16.png"
	
	
	
	loading="lazy"
	
	
></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">Fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">Fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以自定义栈将递归算法改造成非递归算法</p>
<h2 id="队列的应用">队列的应用
</h2><ul>
<li>队列应用一一树的层次遍历</li>
<li>队列应用——图的广度优先遍历</li>
<li>队列在操作系统中的应用
多个进程争抢着使用有限的系统资源时，FCFS（First Come First Service，先来先服务）&mdash;可用队列实现&mdash;是一种常用策略。
Eg：CPU资源的分配、打印数据缓冲区</li>
</ul>
<h1 id="串">串
</h1><h2 id="串的定义和基本操作">串的定义和基本操作
</h2><h3 id="串的定义">串的定义
</h3><p>串，即字符串（String）是由零个或多个字符组成的有限序列。一般记为
S=&lsquo;a<sub>1</sub>a<sub>2</sub>&hellip;&hellip;a<sub>n</sub>&rsquo;(n≥0)
其中，S是串名，单引号括起来的字符序列是串的值；a，可以是字母、数字或其他字符；串中字符的个数n称串的长度。n=0时的串称空串。</p>
<ul>
<li>串 VS 线性表</li>
</ul>
<p>串是一种特殊的线性表，数据元素之间呈线性关系
串的数据对象限定为字符集（如中文字符、英文字符、数字字符、标点字符等）</p>
<p>串的基本操作，如增删改查等通常以<strong>子串</strong>操作对象</p>
<h3 id="串的基本操作">串的基本操作
</h3><p>StrAssign（&amp;T,chars）：赋值操作。把串T赋值为chars。
StrCopy（&amp;T,S）：复制操作。由串S复制得到串T。
StrEmpty（S）：判空操作。若S为空串，则返回TRUE，否则返回FALSE。
StrLength（S）：求串长。返回串S的元素个数。
ClearString（&amp;S）：清空操作。将S清为空串。
DestroyString（&amp;S）：销毁串。将串S销毁（回收存储空间）。
Concat（&amp;T,S1,S2）：串联接。用T返回由S1和S2联接而成的新串
Substring（&amp;Sub,S,pos,len）：求子串。用Sub返回串S的第pos个字符起长度为len的子串。
Index（S,T）：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值&lt;0。
StrCompare（S,T）：比较操作。若S&gt;T，则返回值&gt;0；若S=T，则返回值=0；若S&lt;T，则返回值&lt;0。</p>
<h3 id="串的比较操作">串的比较操作
</h3><p>StrCompare（S,T）：比较操作。若S&gt;T，则返回值&gt;0；若S=T，则返回值=0；若S&lt;T，则返回值&lt;0。</p>
<ul>
<li>
<p>字符集编码</p>
<ul>
<li>
<p>y=f(x)</p>
<p><strong>字符集</strong>：函数定义域</p>
<p><strong>编码</strong>：函数映射规则f</p>
<p><strong>y</strong>：对应的二进制数</p>
</li>
<li>
<p>任何数据存到计算机中一定是二进制数。
需要确定一个字符和二进制数的对应规则这就是“编码”</p>
</li>
<li>
<p><strong>“字符集”</strong>：英文字符——ASCII字符集中英文——Unicode字符集
基于同一个字符集，可以有多种编码方案，
Eg: UTF-8, UTF-16
注：采用不同的编码方式，每个字符所占空间不同，考研中只需默认每个字符占1B即可</p>
</li>
</ul>
</li>
</ul>
<h2 id="串的存储结构">串的存储结构
</h2><h3 id="串的顺序存储">串的顺序存储
</h3><h4 id="定义-1">定义
</h4><ul>
<li>静态数组</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#define MAXLEN 255</span><span class="c1">//预定义最大串长为255
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">ch</span><span class="p">[</span><span class="n">MAXLEN</span><span class="p">];</span><span class="c1">//每个分量存储一个字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span><span class="c1">//串的实际长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">SString</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>动态数组</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span> <span class="c1">//按串长分配存储区，ch指向串的基地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span><span class="c1">//串的长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="nl">HString</span><span class="p">:</span>
</span></span><span class="line"><span class="cl"><span class="n">HString</span> <span class="n">S</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">S</span><span class="p">.</span><span class="n">ch</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">MAXLEN</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">S</span><span class="p">.</span><span class="n">lenath</span> <span class="o">=</span><span class="mi">0</span><span class="o">:</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="存储方式">存储方式
</h4><p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog17.png"
	
	
	
	loading="lazy"
	
	
></p>
<h3 id="串的链式存储">串的链式存储
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">StringNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span><span class="c1">//每个结点存1个字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="nc">StringNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">StringNode</span><span class="p">,</span> <span class="o">*</span><span class="n">String</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog18.png"
	
	
	
	loading="lazy"
	
	
></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">StringNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">ch</span> <span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="c1">//每个结点存多个字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="nc">StringNode</span> <span class="o">*</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">StringNode</span><span class="p">,</span> <span class="o">*</span> <span class="n">String</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog19.png"
	
	
	
	loading="lazy"
	
	
></p>
<h3 id="基本操作的实现">基本操作的实现
</h3><ul>
<li>
<p>SubString（&amp;Sub,S,pos,len）：求子串。用Sub返回串S的第pos个字符起长度为len的子串。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">SubString</span> <span class="p">(</span><span class="n">SString</span> <span class="o">&amp;</span><span class="n">Sub</span><span class="p">,</span><span class="n">SString</span> <span class="n">S</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//子串范围越界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="o">+</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">S</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">pos</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">pos</span><span class="o">+</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">Sub</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">il</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Sub</span><span class="p">.</span> <span class="n">length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>StrCompare(S,T):比较操作。若S&gt;T，则返回值&gt;0；若S=T，则返回值=0；若S&lt;T，则返回值&lt;0。</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//比较操作。若S&gt;T，则返回值&gt;0；若S=T， 则返回值=0；若S&lt;T，则返回值≤0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">StrCompare</span><span class="p">(</span><span class="n">SString</span> <span class="n">S</span><span class="p">,</span> <span class="n">SString</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">S</span><span class="p">.</span><span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">T</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="n">T</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">S</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">il</span><span class="o">-</span><span class="n">T</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">il</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>     
</span></span><span class="line"><span class="cl">    <span class="c1">//扫描过的所有字符都相同，则长度长的串更大
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">S</span><span class="p">.</span> <span class="n">length</span><span class="o">-</span><span class="n">T</span><span class="p">.</span> <span class="n">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Index（S,T）：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">Index</span><span class="p">(</span><span class="n">SString</span> <span class="n">S</span><span class="p">,</span> <span class="n">SString</span> <span class="n">T</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">StrLength</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">m</span><span class="o">=</span><span class="n">StrLength</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">SString</span> <span class="n">sub</span><span class="err">；</span> <span class="c1">//用于暂存子串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">Substring</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="n">m</span><span class="p">)</span><span class="err">；</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">StrCompare</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span><span class="n">T</span><span class="p">)</span><span class="err">！</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">++</span><span class="n">i</span><span class="err">；</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span> <span class="c1">//返回子串在主串中的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//S中不存在与T相等的子串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="字符串----朴素模式匹配算法">字符串&mdash;-朴素模式匹配算法
</h2><p>字符串模式匹配：在主串中找到与模式串相同的子串，并返回其所在位置。</p>
<ul>
<li>两种方法：朴素模式匹配算法、KMP算法</li>
</ul>
<h3 id="朴素模式匹配算法">朴素模式匹配算法
</h3><p>主串长度为n，模式串长度为 m
朴素模式匹配算法：将主串中所有长度为m的子串依次与模式串对比，直到找到一个完全匹配的子串，或所有的子串都不匹配为止。（最多对比 n-m+1个子串）</p>
<p>若当前子串匹配失败，则主串指针i指向下一个子串的第一个位置，模式串指针j回到模式串的第一个位置。若j&gt;T.length，则当前子串匹配成功，返回当前子串第一个字符的位置&mdash;-i- T.length</p>
<p>Index(S,T):定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">Index</span><span class="p">(</span><span class="n">SString</span> <span class="n">S</span><span class="p">,</span> <span class="n">SString</span> <span class="n">T</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">StrLength</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">m</span><span class="o">=</span><span class="n">StrLength</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">sub</span><span class="p">;</span><span class="c1">//用于暂存子串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span><span class="c1">//最多对比 n-m+1个子串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">SubString</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">m</span><span class="p">);</span><span class="c1">//取出从位置i开始，长度为m的子串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">Strcompare</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span><span class="n">T</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="c1">//子串和模式串对比，若不匹配，则匹配下一个子串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">else</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span> <span class="c1">//返回子串在主串中的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//S中不存在与T相等的子串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来：不使用字符串的基本操作，直接通过数组下标实现朴素模式匹配算法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">Index</span><span class="p">(</span><span class="n">SString</span> <span class="n">S</span><span class="p">,</span><span class="n">SString</span> <span class="n">T</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">S</span><span class="p">.</span><span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">T</span><span class="p">.</span><span class="n">length</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">ch</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">T</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="mi">1</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">;</span><span class="c1">//继续比较后继字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">-</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="c1">//指针后退重新开始匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">&gt;</span><span class="n">T</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">i</span><span class="o">-</span><span class="n">T</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>最坏的情况，每个子串都要对比 m 个字符，共n-m+1个子串，复杂度=O((n-m+1)m)=O(nm)</p>
<h2 id="字符串----kmp算法">字符串&mdash;-KMP算法
</h2><h3 id="kmp算法">KMP算法
</h3><p>由D.E.Knuth,J.H.Morris和V.R.Pratt提出，因此称为KMP算法</p>
<ul>
<li>不匹配的字符之前，一定是和模式串一致的</li>
<li>Eg：对于模式串 T= ‘abaabc&rsquo;
当第6个元素匹配失败时，可令主串指针i不变，模式串指针j=3
当第5个元素匹配失败时，可令主串指针i不变，模式串指针j=2
当第4个元素匹配失败时，可令主串指针i不变，模式串指针j=2
当第3个元素匹配失败时，可令主串指针i不变，模式串指针j=1
当第2个元素匹配失败时，可令主串指针i不变，模式串指针j=1
当第1个元素匹配失败时，匹配下一个相邻子串，令j=0,i++，j++</li>
</ul>
<h3 id="next数组">next数组
</h3><p>next数组只和短短的模式串有关，和长长的主串无关
<img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog20.png"
	
	
	
	loading="lazy"
	
	
></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">Index_KMP</span><span class="p">(</span><span class="n">SString</span> <span class="n">S</span><span class="p">,</span><span class="n">SString</span> <span class="n">T</span><span class="p">,</span><span class="kt">int</span> <span class="n">nextl</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">S</span><span class="p">.</span><span class="n">length</span><span class="o">&amp;&amp;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">T</span><span class="p">.</span><span class="n">length</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">j</span><span class="o">==</span><span class="mi">0</span><span class="o">||</span><span class="n">S</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">T</span><span class="p">.</span><span class="n">chljl</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">j</span><span class="p">;</span><span class="c1">//继续比较后继字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span><span class="o">=</span><span class="n">next</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="c1">//模式串向右移动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">&gt;</span><span class="n">T</span><span class="p">.</span> <span class="n">length</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">i</span><span class="o">-</span><span class="n">T</span><span class="p">.</span> <span class="n">length</span><span class="err">；</span><span class="c1">//匹配成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="kmp算法----求next数组">KMP算法&mdash;-求next数组
</h2><p>next数组的作用：当模式串的第j个字符失配时，从模式串的第 nextljl 的继续往后匹配</p>
<ul>
<li>任何模式串都一样，第一个字符不匹配时，只能匹配下一个子串，因此，往后余生，next［1］都无脑写0</li>
<li>任何模式串都一样，第2个字符不匹配时，应尝试匹配模式串的第1个字符，因此，往后余生，next［2］都无脑写1</li>
<li>在不匹配的位置前边，划一根美丽的分界线，模式串一步一步往后退，直到分界线之前“能对上”，或模式串完全跨过分界线为止，此时j指向哪儿，next数组值就是多少</li>
</ul>
<h2 id="kmp算法----进一步优化">KMP算法&mdash;-进一步优化
</h2><h1 id="树和二叉树">树和二叉树
</h1><h2 id="树的定义与基本术语">树的定义与基本术语
</h2><h3 id="树的基本概念">树的基本概念
</h3><ul>
<li>非空树的特性：
有且仅有一个根节点
没有后继的结点称为“叶子结点”（或终端结点）
有后继的结点称为“分支结点”（或非终端结点）
除了根节点外，任何一个结点都有且仅有一个前驱
每个结点可以有0个或多个后继。</li>
<li>除了根节点外，任何一个结点都有且仅有一个前驱</li>
<li>树是n(n&gt;=0)个结点的有限集合，n=0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：
1）有且仅有一个特定的称为根的结点。
2）当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集合T<sub>1</sub>，T<sub>2</sub>&hellip;&hellip;T<sub>m</sub>，其中每个集合本身又是一棵树，并且称为根结点的子树。</li>
<li>什么是两个结点之间的路径？&mdash;只能从上往下
什么是路径长度？&mdash;经过几条边</li>
<li>属性：
结点的层次(深度)&mdash;-从上往下数
结点的高度&mdash;-从下往上数
树的高度(深度)&mdash;-总共多少层
结点的度&mdash;-有几个孩子（分支）
树的度&mdash;-各结点的度的最大值</li>
</ul>
<h3 id="有序树vs无序树">有序树V.S无序树
</h3><p>有序树—-逻辑上看，树中结点的各子树从左至右是有次序的，不能互换
无序树—-逻辑上看，树中结点的各子树从左至右是无次序的，可以互换</p>
<h3 id="树vs森林">树V.S森林
</h3><p>森林。森林是m（m≥0）棵互不相交的树的集合</p>
<h2 id="树的常考性质">树的常考性质
</h2><ul>
<li>
<p>常见考点1：结点数=总度数+1
结点的度—一结点有几个孩子（分支）</p>
</li>
<li>
<p>树的度——各结点的度的最大值
m叉树一一每个结点最多只能有m个孩子的树</p>
</li>
</ul>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>度为m的树</th>
          <th>m叉树</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>任意结点的度≤m（最多m个孩子）</td>
          <td>任意结点的度≤m（最多m个孩子）</td>
      </tr>
      <tr>
          <td>至少有一个结点度=m（有m个孩子）</td>
          <td>允许所有结点的度都＜ m</td>
      </tr>
      <tr>
          <td>一定是非空树，至少有m+1个结点</td>
          <td>可以是空树</td>
      </tr>
  </tbody>
</table></div>
<ul>
<li>
<p>常见考点2：度为m的树、m叉树的区别</p>
</li>
<li>
<p>常见考点3：度为m的树第i层至多有m<sup>i-1</sup>个结点（i&gt;=1）
m叉树第i层至多有m<sup>i-1</sup> 个结点（1&gt;=1）</p>
</li>
<li>
<p>常见考点4：高度为h的m叉树至多有m<sup>h-1</sup>/m-1个结点。
等比数列求和公式：a+aq+aq<sup>2</sup>+&hellip;&hellip;+aq<sup>n-1</sup>=a(1-qn)/1-q</p>
</li>
<li>
<p>常见考点5：高度为h的m叉树至少有h个结点。
高度为h、度为m的树至少有h+m-1个结点。</p>
</li>
<li>
<p>常见考点6：具有n个结点的m又树的最小高度为 log<sub>m</sub>(n(m-1)+1)</p>
<p>高度最小的情况——所有结点都有m个孩子</p>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog21.png"
	
	
	
	loading="lazy"
	
	
></p>
</li>
</ul>
<h2 id="二叉树的定义与基本定语">二叉树的定义与基本定语
</h2><h3 id="二叉树的基本概念">二叉树的基本概念
</h3><p>二叉树是n(n&gt;=0)个结点的有限集合：
① 或者为<strong>空二叉树</strong>，即n=0。
② 或者由一个<strong>根结点</strong>和两个互不相交的被称为根的<strong>左子树</strong>和<strong>右子树</strong>组成。左子树和右子树又分别是一棵二叉树。
特点：①每个结点至多只有两棵子树 ②左右子树不能颠倒（二叉树是有序树）
*注意区别：度为2的有序树</p>
<ul>
<li>
<p>二叉树的五种状态</p>
<p>1.空二叉树</p>
<p>2.只有左子树</p>
<p>3.只有右子树</p>
<p>4.只有根结点</p>
<p>5.左右子树都有</p>
</li>
</ul>
<h3 id="几种特殊的二叉树">几种特殊的二叉树
</h3><ul>
<li>
<p>满二叉树。一棵高度h，且含有2-1个结点的二叉树</p>
<p>特点：
①只有最后一层有叶子结点
②不存在度为1的结点
③按层序从1开始编号，结点i的左孩子2i，右孩子为2i+1；结点i的父节点为|/2」（如果有的话）</p>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog22.png"
	
	
	
	loading="lazy"
	
	
></p>
</li>
<li>
<p>完全二叉树。当且仅当其每个结点都与高度为h的满二叉树中编号为1～n的结点一一对应时，称为完全二叉树</p>
<p>特点：
①只有最后两层可能有叶子结点
②最多只有一个度为1的结点
③按层序从1开始编号，结点i的左孩子2i，右孩子为2i+1；结点i的父节点为|/2」（如果有的话）
④i&lt;=[n/2]为分支结点，i&gt;[n/2]为叶子结点</p>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog23.png"
	
	
	
	loading="lazy"
	
	
></p>
</li>
<li>
<p>二叉排序树。一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：
左子树上所有结点的关键字均小于根结点的关键字；
右子树上所有结点的关键字均大于根结点的关键字。
左子树和右子树又各是一棵二叉排序树。
&mdash;-二叉排序树可用于元素的排序、搜索</p>
</li>
<li>
<p>平衡二叉树。树上任一结点的左子树和右子树的深度之差不超过1。</p>
</li>
</ul>
<h2 id="二叉树常考性质">二叉树常考性质
</h2><h3 id="二叉树常考性质-1">二叉树常考性质
</h3><ul>
<li>
<p>常见考点1：设非空二叉树中度为0、1和2的结点个数分别为n<sub>0</sub>、n<sub>1</sub>和n<sub>2</sub>，则<strong>n<sub>0</sub>=n<sub>2</sub>+1</strong>(叶子结点   比二分支结点多一个)</p>
<p><strong>证明</strong>：假设树中结点总数为n，则
(1)n = n<sub>0</sub>+ n<sub>1</sub>+ n<sub>2</sub>
(2)n = n<sub>1</sub>+ 2n<sub>2</sub>+1&mdash;-<strong>树的结点数=总度数+1</strong>
(1)-(2):n<sub>0</sub>=n<sub>2</sub>+1</p>
</li>
<li>
<p>常见考点2：二叉树第i层至多有2<sup>i-1</sup> 个结点（i≥1）
m叉树第i层至多有m<sup>i-1</sup> 个结点（i≥1）</p>
</li>
<li>
<p>常见考点3：高度为h的二叉树至多有 2<sup>h</sup>—1个结点（满二叉树）
高度为h的m叉树至多有m<sup>h</sup>-1/m-1个结点
等比数列求和公式：a+aq+aq<sup>2</sup>+&hellip;&hellip;+aq<sup>n-1</sup>=a(1-qn)/1-q</p>
</li>
</ul>
<h3 id="完全二叉树常考性质">完全二叉树常考性质
</h3><ul>
<li>
<p><strong>常见考点1：具有n个（n&gt;0）结点的完全二叉树的高度h为 log<sub>2</sub>(n+1) 或log<sub>2</sub>n +1</strong></p>
<ul>
<li>
<p><strong>log<sub>2</sub>(n+1)是怎么来的？</strong></p>
<p>高为h的满二叉树共有2<sup>h-1</sup>个结点，</p>
<p>高h-1的满二叉树共有2<sup>h-1</sup>—1个结点，</p>
<p>所以要想高度为h就必须满足：</p>
<p>2<sup>h-1</sup>-1 &lt;n≤2<sup>h-1</sup>
2<sup>h-1</sup> &lt; n+1≤2<sup>h</sup>
h - 1 &lt; log<sub>2</sub>(n+1) ≤ h
h = log<sub>2</sub>(n+ 1)</p>
</li>
<li>
<p><strong>log<sub>2</sub>n +1是怎么来的？</strong></p>
<p>高h-1的满二叉树共有2<sup>h-1</sup>—1个结点，</p>
<p>所以高为h的二叉树则至少比他多一个结点，</p>
<p>即至少为2<sup>h-1</sup>，</p>
<p>至多为2<sup>h-1</sup>-1</p>
</li>
</ul>
</li>
<li>
<p><strong>常见考点2：对于完全二叉树，可以由的结点数n推出度为0、1和2的结点个数为n<sub>0</sub>、n<sub>1</sub>和n<sub>2</sub></strong></p>
<p>完全二叉树最多只有一个度1的结点，即n<sub>0</sub>=0或1
n<sub>0</sub>=n<sub>2</sub>+1 &ndash;&gt; n<sub>0</sub>+n<sub>2</sub>一定是奇数</p>
<p>若完全二叉树有2k个(偶数)个结点，则必有n<sub>1</sub>=1，n<sub>0</sub>=k，n<sub>2</sub>=k-1
若完全二叉树有2k-1个(奇数)个结点，则必有n<sub>1</sub>=0, n<sub>0</sub>=k, n<sub>2</sub> = k-1</p>
</li>
</ul>
<h2 id="二叉树的存储结构">二叉树的存储结构
</h2><h3 id="二叉树的顺序存储">二叉树的顺序存储
</h3><ul>
<li>代码定义</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#define MaxSize 100
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">struct</span> <span class="nc">TreeNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ftemTypeyalue</span><span class="p">;</span> <span class="c1">//结点中的数据元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="n">isEmpty</span><span class="p">;</span><span class="c1">//结点是否为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">｝；</span>
</span></span><span class="line"><span class="cl"><span class="n">TreeNode</span> <span class="n">t</span> <span class="p">[</span><span class="n">MaxSizel</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>定义一个长度为 MaxSize 的数组t，按照从上至下、从左至右的顺序依次存储完全二叉树中的各个结点</p>
<ul>
<li>
<p>注意：可以让第一个位置为空，保证数组下标和结点编号一致</p>
</li>
<li>
<p>几个重要常考的基本操作：</p>
<ul>
<li>i 的左孩子——2i</li>
<li>i 的右孩子——2i+1</li>
<li>i 的父节点——i/2</li>
<li>i 所在的层次——log<sub>2</sub>(n+1) 或 [log<sub>2</sub>n ]+1</li>
<li>若<strong>完全二叉树</strong>中共有n个结点，则（注意，只有完全二叉树才符合这个规则 ）</li>
<li>判断 i 是否有左孩子？——2i ≤ n？</li>
<li>判断 i 是否有右孩子？——2i+1 ≤ n?</li>
<li>判断 i 是否是叶子/分支结点？ ——i&gt;[n/2]？</li>
</ul>
</li>
<li>
<p>如果不是完全二叉树怎么办？</p>
<p>二叉树的顺序存储中，一定要把二叉树的结点编号与完全二叉树对应起来</p>
<p><strong>结论：二叉树的顺序存储结构，只适合存储完全二叉树</strong></p>
</li>
</ul>
<h3 id="二叉树的链式存储">二叉树的链式存储
</h3><ul>
<li>
<p>代码定义</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//二叉树的结点（链式存储）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">BiTNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ElemType</span> <span class="nl">data</span><span class="p">:</span>  <span class="c1">//数据域
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="nc">BiNode</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="o">*</span><span class="n">rchild</span><span class="p">;</span><span class="c1">//左、右孩子指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">BiTNode</span> <span class="o">*</span><span class="nl">BiTree</span><span class="p">:</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>线索二叉树</p>
<p>若有n个结点，则有2n个指针，除了跟结点，每一个结点上面一定会有一个指针指向他，共有n-1个，所以有n+1个空的指针域，可以利用这些空间构造线索二叉树</p>
</li>
<li>
<p>二叉树的构建</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">ElemType</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">BiTNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ElemType</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">BiNode</span> <span class="o">*</span><span class="n">lchild</span><span class="p">,</span><span class="o">*</span><span class="n">rchild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">BiT</span> <span class="n">Node</span><span class="p">,</span><span class="o">*</span><span class="n">BiTree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//定义一棵空树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BiTree</span> <span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//插入根节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">root</span> <span class="o">=</span> <span class="p">(</span><span class="n">BiTree</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BiTNode</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//插入新结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BiTNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">BiTNode</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BiTNode</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">=</span><span class="n">p</span><span class="p">;</span><span class="n">v</span><span class="c1">//作为根节点的左孩子
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>三叉链表
可以增加一个父结点指针以方便找父结点</li>
</ul>
<h2 id="二叉树的先中后序遍历">二叉树的先中后序遍历
</h2><ul>
<li>
<p>先序遍历：根左右（NLR）</p>
<ul>
<li>
<p>代码实现</p>
<p>先序遍历（PreOrder）的操作过程如下：</p>
<ol>
<li>若二叉树空，则什么也不做；</li>
<li>若二叉树非空：
①访问根结点；
②先序遍历左子树；
③先序遍历右子树。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">PreOrder</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">T</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">visit</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">PreOrder</span> <span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">PreOrder</span> <span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p>中序遍历：左根右（LNR）</p>
<ul>
<li>
<p>代码实现</p>
<p>中序遍历（InOrder）的操作过程如下：</p>
<ol>
<li>若二叉树为空，则什么也不做；</li>
<li>若二叉树非空：
①先序遍历左子树；
②访问根结点；
③先序遍历右子树。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">InOrder</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">T</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">PreOrder</span> <span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">visit</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">PreOrder</span> <span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p>后序遍历：左右根（LRN）</p>
<p>后序遍历（InOrder）的操作过程如下：</p>
<ol>
<li>若二叉树为空，则什么也不做；</li>
<li>若二叉树非空：
①先序遍历左子树；
⑨先序遍历右子树；
③访问根结点。</li>
</ol>
</li>
<li>
<p>先序遍历 前缀表达式
中序遍历 中缀表达式（需要加界限符）
后序遍历  后缀表达式</p>
</li>
<li>
<p>脑补空结点，从根节点出发，画一条路：
如果左边还有没走的路，优先往左边走走到路的尽头（空结点）就往回走
如果左边没路了，就往右边走
如果左、右都没路了，则往上面走，经过三次时访问该结点</p>
</li>
<li>
<p>例：求树的深度</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">treeDepth</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">T</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">treeDepth</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">treeDepth</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//树的深度=Max（左子树深度，右子树深度）+1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">l</span><span class="o">&gt;</span><span class="n">r</span> <span class="o">?</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span> <span class="o">:</span> <span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="err">；</span>
</span></span><span class="line"><span class="cl">    <span class="err">｝</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="二叉树的层次遍历">二叉树的层次遍历
</h2><ul>
<li>算法思想：
1.初始化一个辅助队列
2.根结点入队
3.若队列非空，则队头结点出队，访问该结点：并将其左、右孩子插入队尾（如果有的话）
4.重复3直至队列为空</li>
<li>代码实现</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//层序遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">LevelOrder</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">D</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">LinkQueue</span> <span class="n">Q</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">InitQueue</span> <span class="p">(</span><span class="n">Q</span><span class="p">);</span><span class="c1">//初始化辅助队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">BiTree</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">EnQueue</span> <span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">T</span><span class="p">);</span><span class="c1">//将根结点入队
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">IsEmpty</span><span class="p">(</span><span class="n">Q</span><span class="p">)){</span><span class="c1">//队列不空则循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">DeQueue</span><span class="err">（</span><span class="n">Q</span><span class="p">,</span><span class="n">p</span><span class="err">）；</span><span class="c1">//队头结点出队
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="c1">//访问出队结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;|</span><span class="n">child</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">P</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span><span class="c1">//左孩子入队
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span><span class="c1">//右孩子入队
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>  
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="由遍历序列来构造二叉树">由遍历序列来构造二叉树
</h2><p>若只给出一棵二叉树的前/中/后/层序遍历序列中的一种，不能唯一确定一棵二叉树</p>
<ul>
<li>前序＋中序遍历序列</li>
</ul>
<p>前序遍历：根结点、前序遍历左子树、前序遍历右子树
中序遍历：中序遍历左子树、根结点、中序遍历右子树</p>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog24test.png"
	
	
	
	loading="lazy"
	
	
></p>
<ul>
<li>
<p>后序＋中序遍历序列</p>
<p>逻辑与前序+中序类似</p>
</li>
<li>
<p>层序＋中序遍历序列
<img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog25.png"
	
	
	
	loading="lazy"
	
	
></p>
</li>
</ul>
<h2 id="线索二叉树的概念">线索二叉树的概念
</h2><ul>
<li>
<p>二叉树存在的一些问题</p>
<ul>
<li>不能从一个指定结点开始中序遍历</li>
<li>找到前驱和后继比较麻烦
<ul>
<li>思路：
从根节点出发，重新进行一次中序 遍历，指针q记录当前访问的结点，指针 pre 记录上一个被访问的结点
①当q=p时，pre为p的前驱
②当pre=p时，q为p的后继</li>
</ul>
</li>
</ul>
</li>
<li>
<p>引入线索二叉树</p>
<p>因为n个结点的二叉树会存在n+1个空链域，所以可以利用这些空间存储二叉树的前驱和后继</p>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog26test.png"
	
	
	
	loading="lazy"
	
	
></p>
</li>
<li>
<p>代码定义</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//线索二叉树结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">ThreadNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ElemType</span> <span class="n">data</span><span class="err">；</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">ThreadNode</span> <span class="o">*</span><span class="n">lchild</span><span class="p">,</span><span class="o">*</span><span class="n">rchild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ltag</span><span class="p">,</span> <span class="n">rtag</span><span class="p">;</span><span class="c1">//左、右线索标志,tag==0表示指向的是孩子，tag==1表示指向的是线索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">ThreadNode</span><span class="p">,</span> <span class="o">*</span><span class="n">ThreadTree</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="二叉树的线索化">二叉树的线索化
</h2><ul>
<li>
<p>&ldquo;土方法&quot;找中序前驱</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">FindPre</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">InOrder</span> <span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">l</span> <span class="n">child</span><span class="p">);</span><span class="c1">//递归遍历左子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">visit</span> <span class="p">(</span><span class="n">T</span><span class="p">);</span><span class="c1">//访问根结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">InOrder</span> <span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span><span class="c1">//递归遍历右子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">visit</span><span class="p">(</span><span class="n">BiTNode</span> <span class="o">*</span> <span class="n">q</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">==</span><span class="n">p</span><span class="p">)</span><span class="c1">//当前访问结点刚好是结点人展
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">final</span> <span class="o">=</span> <span class="n">pre</span><span class="p">;</span><span class="c1">//找到p的前驱
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="n">pre</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span><span class="c1">//pre指向当前访问的结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//辅助全局变量，用于查找结点p的前驱
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BiTNode</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="c1">//p指向目标结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Biz</span><span class="p">[</span><span class="n">Node</span> <span class="o">*</span> <span class="n">pre</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span><span class="c1">//指向当前访问结点的前驱
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BiTNode</span> <span class="o">*</span> <span class="k">final</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span><span class="c1">//用于记录最终结果
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>中序线索化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//线索二叉树结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">ThreadNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ElemType</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">ThreadNode</span> <span class="o">*</span><span class="n">lchild</span><span class="p">,</span><span class="o">*</span><span class="n">rchild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ltag</span><span class="p">,</span><span class="n">rtag</span><span class="p">;</span><span class="c1">//左、右线索标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">ThreadNode</span><span class="p">,</span> <span class="o">*</span><span class="n">ThreadTree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//中序遍历二叉树，一边遍历一边线索化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">InThread</span><span class="p">(</span><span class="n">ThreadTree</span> <span class="n">T</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">InThread</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">)</span><span class="err">；</span><span class="c1">//中序遍历左子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">visit</span><span class="p">(</span><span class="n">T</span><span class="p">);</span><span class="c1">//访问根节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">InThread</span> <span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span><span class="c1">//中序遍历右子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">visit</span><span class="p">(</span><span class="n">ThreadNode</span> <span class="o">*</span><span class="n">q</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">==</span><span class="nb">NULL</span><span class="p">){</span><span class="c1">//左子树为空，建立前驱线索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">q</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">=</span><span class="n">pre</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">q</span><span class="o">-&gt;</span><span class="n">ltag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">pre</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">==</span><span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">pre</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">=</span><span class="n">q</span><span class="err">；</span> <span class="c1">//建立前驱结点的后继线索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pre</span><span class="o">-&gt;</span><span class="n">rtag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">｝</span>
</span></span><span class="line"><span class="cl"><span class="n">pre</span><span class="o">=</span><span class="n">q</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">｝</span>
</span></span><span class="line"><span class="cl"><span class="c1">//全局变量 pre，指向当前访问结点的前驱
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ThreadNode</span> <span class="o">*</span><span class="n">pre</span><span class="o">=</span><span class="nb">NULL</span><span class="o">:</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>中序线索化（王道教材版）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//中序线索化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">InThread</span> <span class="p">(</span><span class="n">ThreadTree</span> <span class="n">p</span><span class="p">,</span> <span class="n">ThreadTree</span> <span class="o">&amp;</span><span class="n">pre</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">InThread</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span> <span class="n">pre</span><span class="p">);</span><span class="c1">//递归，线索化左子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">==</span><span class="nb">NULL</span><span class="p">){</span><span class="c1">//左子树为空，建立前驱线索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">=</span><span class="n">pre</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">ltag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">pre</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">==</span><span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">=</span><span class="n">p</span><span class="p">;</span><span class="c1">//建立前驱结点的后继线索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">rtag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">pre</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">InThread</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">,</span> <span class="n">pre</span><span class="p">)</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="c1">//if(p!=NULL)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//中序线索化二叉树T
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">CreateInThread</span><span class="p">(</span><span class="n">ThreadTree</span> <span class="n">T</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">ThreadTree</span> <span class="n">pre</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">InThread</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">pre</span><span class="p">);</span><span class="c1">//非空二叉树，线索化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">=</span><span class="nb">NULL</span><span class="err">；</span><span class="c1">//线索化二叉树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">rtag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="c1">//处理遍历的最后一个结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>思考：处理遍历的最后一个结点时，为什么没有判断 rchild
是否为NULL？
答：中序遍历的最后一个结点右孩子指针必为空。</p>
</li>
<li>
<p>先序线索化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//全局变量 pre，指向当前访问结点的前驱
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ThreadNode</span> <span class="o">*</span><span class="n">pre</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//先序线索化二叉树T
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">CreatePreThread</span> <span class="p">(</span><span class="n">ThreadTree</span> <span class="n">T</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">pre</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span><span class="c1">//pre初始为NULL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span><span class="c1">//非空二叉树才能线索化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">PreThread</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">;</span><span class="c1">//先序线索化二叉树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">rtag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="c1">//处理遍历的最后一个结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//先序遍历二叉树，一边遍历一边线索化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">PreThread</span><span class="p">(</span><span class="n">ThreadTree</span> <span class="n">T</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">visit</span><span class="p">(</span><span class="n">T</span><span class="p">);</span><span class="c1">//先处理根节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">Ltag</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="c1">//lchild不是前驱线索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">PreThread</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;|</span><span class="n">child</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">PreThread</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">ThreadNode</span> <span class="o">*</span><span class="n">q</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">Lchild</span><span class="o">==</span><span class="nb">NULL</span><span class="p">){</span><span class="c1">//左子树为空，建立前驱线索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">q</span><span class="o">-&gt;</span><span class="n">Lchild</span><span class="o">=</span><span class="n">pre</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">q</span><span class="o">-&gt;</span><span class="n">ltag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">pre</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">==</span><span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">=</span><span class="n">q</span><span class="err">；</span> <span class="c1">//建立前驱结点的后继线索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">rtag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">pre</span><span class="o">=</span><span class="n">q</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>后序线索化</p>
</li>
</ul>
<h2 id="在线索二叉树中找前驱后继">在线索二叉树中找前驱后继
</h2><h3 id="中序线索二叉树找中序后继">中序线索二叉树找中序后继
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//找到以P为根的子树中，第一个被中序遍历的结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ThreadNode</span> <span class="o">*</span><span class="nf">Firstnode</span> <span class="p">(</span><span class="n">ThreadNode</span> <span class="o">*</span><span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//循环找到最左下结点（不一定是叶结点）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">Ltag</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//在中序线索二叉树中找到结点p的后继结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ThreadNode</span> <span class="o">*</span><span class="nf">Nextnode</span><span class="p">(</span><span class="n">ThreadNode</span> <span class="o">*</span><span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//右子树中最左下结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rtag</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">Firstnode</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span><span class="c1">//ctag==1直接返回后继线索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//对中序线索二叉树进行中序遍历（利用线索实现的非递归算法）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">Inorder</span><span class="p">(</span><span class="n">ThreadNode</span> <span class="o">*</span><span class="n">T</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">ThreadNode</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">Firstnode</span><span class="p">(</span><span class="n">T</span><span class="p">);</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">;</span><span class="n">p</span><span class="o">=</span><span class="n">Nextnode</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="n">visit</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="中序线索二叉树找中序前驱">中序线索二叉树找中序前驱
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//找到以P为根的子树中，最后一个被中序遍历的结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ThreadNode</span> <span class="o">*</span><span class="nf">Lastnode</span> <span class="p">(</span><span class="n">ThreadNode</span> <span class="o">*</span><span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//循环找到最右下结点（不一定是叶结点）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rtag</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">｝</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//在中序线索二叉树中找到结点p的前驱结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ThreadNode</span> <span class="o">*</span><span class="n">Prenode</span> <span class="p">(</span><span class="n">ThreadNode</span> <span class="o">*</span><span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//左子树中最右下结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ltag</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">Lastnode</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span> <span class="c1">//ltag==1直接返回前驱线索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">｝</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="c1">//对中序线索二叉树进行逆向中序遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">RevInorder</span><span class="p">(</span><span class="n">ThreadNode</span> <span class="o">*</span><span class="n">T</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">ThreadNode</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">Lastnode</span><span class="p">(</span><span class="n">T</span><span class="p">);</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">;</span> <span class="n">p</span><span class="o">=</span><span class="n">Prenode</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog30.png"
	
	
	
	loading="lazy"
	
	
></p>
<h2 id="树的存储结构">树的存储结构
</h2><h3 id="树的逻辑结构">树的逻辑结构
</h3><ul>
<li>树是n(n&gt;=0)个结点的有限集合，n=0时，称空树，这是一种特殊情况。在任意一棵非空树中应满足：
1）有且仅有一个特定的称次根的结点。
2）当n&gt;1时，其余结点可分为m（m&gt;0）个互不相交的有限集合T<sub>1</sub>，T<sub>2</sub>…，T<sub>m</sub>，其中每个集合本身又是一棵树，并且称为根结点的子树。</li>
<li>树是一种递归定义的数据结构</li>
</ul>
<h3 id="如何实现树的顺序存储">如何实现树的顺序存储
</h3><p>思路：用数组顺序存储各个结点。每个结点中保存数据元素、指向双亲结点（父节点）的“指针”</p>
<ul>
<li>
<p><strong>树的存储1:双亲表示法</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#define MAX_TREE_SIZE 100</span><span class="c1">//树中最多结点数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span><span class="c1">//树的结点定义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ElemType</span> <span class="n">data</span><span class="p">;</span><span class="c1">//数据元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">parent</span><span class="p">;</span><span class="c1">//双亲位置域
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="nl">PTNode</span><span class="p">:</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span><span class="c1">//树的类型定义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">PTNode</span> <span class="n">nodes</span><span class="p">[</span><span class="n">MAX_TREE_SIZE</span><span class="p">];</span><span class="c1">//双亲表示
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span><span class="c1">//结点数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">PTree</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>优点：找双亲（父节点）很方便
缺点：找孩子不方便，只能从头到尾遍历整个数组</p>
<p>适用于“找父亲”多，“找孩子”少的应用场景。如：并查集</p>
</li>
<li>
<p><strong>树的存储2：孩子表示法</strong></p>
<p>孩子表示法：用数组顺序存储各个结点。每个结点中保存数据元素、孩子链表头指针</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">CTNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">child</span><span class="p">;</span> <span class="c1">//孩子结点在数组中的位置、
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="nc">CTNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="c1">//下一个孩子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ElemType</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">CTNode</span> <span class="o">*</span><span class="n">firstChild</span><span class="p">;</span> <span class="c1">//第一个孩子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="err">СТВох</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">СТ</span><span class="n">Bох</span> <span class="n">nodes</span> <span class="p">[</span><span class="n">MAX_TREE_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">r</span><span class="p">;</span><span class="c1">//结点数和根的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">CTree</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>孩子表示法存储“森林”</strong></p>
</li>
<li>
<p><strong>孩子表示法的优缺点</strong></p>
<p>优点：找孩子很方便
缺点：找双亲（父节点）不方便，只能遍历每个链表</p>
</li>
<li>
<p><strong>树的存储3：孩子兄弟表示法</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//树的存储：孩子兄弟表示法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">CSNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ElemType</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">CSNode</span> <span class="o">*</span><span class="n">firstchild</span><span class="p">,</span><span class="o">*</span><span class="n">nextsibling</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">CSNode</span><span class="p">,</span> <span class="o">*</span><span class="n">CSTree</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>树的孩子兄弟表示法，与二叉树类似，采用二叉链表实现每个结点内保存数据元素和两个指针，但两个指针的含义与二叉树结点不同</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//二叉树的结点（链式存储）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">BiTNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ElemType</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">BiTNode</span> <span class="o">*</span><span class="n">lchild</span><span class="p">,</span><span class="o">*</span><span class="n">rchild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">BiTNode</span><span class="p">,</span> <span class="o">*</span><span class="n">BiTree</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当使用“孩子兄弟表示法”存储树或森林时，从存储视角来看形态上与二叉树类似，如下图：</p>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog32.png"
	
	
	
	loading="lazy"
	
	
></p>
</li>
</ul>
<h2 id="树森林与二叉树的转换">树、森林与二叉树的转换
</h2><h3 id="树-二叉树的转换">树-&gt;二叉树的转换
</h3><p>树-二叉树 转换技巧：
①先在二叉树中，画一个根节点。
②按“树的层序”依次处理每个结点。</p>
<p>处理一个结点的方法是：如果当前处理的结点在树中有孩子，就把所有孩子结点“用右指针串成糖葫芦”，并在二叉树中把第一个孩子挂在当前结点的左指针下方</p>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog33.png"
	
	
	
	loading="lazy"
	
	
></p>
<h3 id="森林-二叉树的转换">森林-&gt;二叉树的转换
</h3><p>注意：森林中各棵树的根节点视为平级的兄弟关系</p>
<p>森林-&gt;二叉树转换技巧：
①先把所有树的根结点画出来，在二叉树中用右指针串成糖葫芦。
②按“森林的层序”依次处理每个结点。
处理一个结点的方法是：如果当前处理的结点在树中有孩子，就把所有孩子结点“用右指针串成糖葫芦”，并在二叉树中把第一个孩子挂在当前结点的左指针下方</p>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog36.png"
	
	
	
	loading="lazy"
	
	
></p>
<h3 id="二叉树-树的转换">二叉树-&gt;树的转换
</h3><p>二叉树-&gt;树的转换技巧：
①先画出树的根节点
②从树的根节点开始，按“树的层序”恢复每个结点的孩子
如何恢复一个结点的孩子：在二叉树中，如果当前处理的结点有左孩子，就把左孩子和“一整串右指针糖葫芦”拆下来，按顺序挂在当前结点的下方</p>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog37.png"
	
	
	
	loading="lazy"
	
	
></p>
<h3 id="二叉树-森林的转换">二叉树-&gt;森林的转换
</h3><p>二叉树-&gt;森林的转换技巧：
①先把二叉树的根节点和“一整串右指针糖葫芦”拆下来，作多棵树的根节点
②按“森林的层序”恢复每个结点的孩子
如何恢复一个结点的孩子：在二叉树中，如果当前处理的结点有左孩子，就把左孩子和“一整串右指针糖葫芦”拆下来，按顺序挂在当前结点的下方</p>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog38.png"
	
	
	
	loading="lazy"
	
	
></p>
<h2 id="树森林的遍历">树、森林的遍历
</h2><h3 id="树的先根遍历和后根遍历">树的先根遍历和后根遍历
</h3><p> （1）先根遍历。若树非空，先访问根结点，再依次对每棵子树进行先根遍历。（深度优先遍历）</p>
<p>伪代码如下（具体代码实现需要根据具体树的存储结构编写）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//树的先根遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">PreOrder</span> <span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">R</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">R</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">visit</span><span class="p">(</span><span class="n">R</span><span class="p">);</span><span class="c1">//访问根节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span><span class="p">(</span><span class="n">R还有下一个子树T</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">             <span class="n">PreOrder</span><span class="p">(</span><span class="n">T</span><span class="p">);</span><span class="c1">//先根遍历下一棵子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>（2）后根遍历。若树非空，先依次对每棵子树进行后根遍历，最后再访问根结点。（深度优先遍历）</p>
<p>伪代码如下（具体代码实现需要根据具体树的存储结构编写）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//树的后根遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">PostOrder</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">R</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">R</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">R还有下一个子树T</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">PostOrder</span><span class="p">(</span><span class="n">T</span><span class="p">);</span><span class="c1">//后根遍历下一棵子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">visit</span><span class="p">(</span><span class="n">R</span><span class="p">);</span><span class="c1">//访问根节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="树的层次遍历">树的层次遍历
</h3><p>（3）层次遍历（用队列实现）（广度优先遍历）
①若树非空，则根节点入队
②若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队
③重复②直到队列为空</p>
<h3 id="森林的先序遍历中序遍历">森林的先序遍历、中序遍历
</h3><p>1） 先序遍历森林。
若森林非空，则按如下规则进行遍历：
访问森林中第一棵树的根结点。
先序遍历第一棵树中根结点的子树森林。
先序遍历除去第一棵树之后剩余的树构成的森林。</p>
<p>（效果等于先序遍历每个树）</p>
<p>2） 中序遍历森林。
若森林为非空，则按如下规则进行遍历：
中序遍历森林中第一棵树的根结点的子树森林。
访问第一棵树的根结点。
中序遍历除去第一棵树之后剩余的树构成的森林。</p>
<h2 id="哈夫曼树">哈夫曼树
</h2><h3 id="带权路径长度">带权路径长度
</h3><p><strong>结点的权</strong>：有某种现实含义的数值（如：表示结点的重要性等）
<strong>结点的带权路径长度</strong>：从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积
<strong>树的带权路径长度</strong>：树中所有叶结点的带权路径长度之和（WPL, Weighted Path Length）</p>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog39.png"
	
	
	
	loading="lazy"
	
	
></p>
<h3 id="哈夫曼树的定义">哈夫曼树的定义
</h3><p>在含有n个带权叶结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称<strong>哈夫曼树</strong>，也称<strong>最优二叉树</strong></p>
<h3 id="哈夫曼树的构造">哈夫曼树的构造
</h3><p>给定n个权值分别为w<sub>1</sub>，w<sub>2</sub>…，w<sub>n</sub>的结点，构造哈夫曼树的算法描述如下：
1）将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。
2）构造一个新结点，从F中选取两棵根结点权值最小的树作新结点的左、右子树，并且将新结点的权值置左、右子树上根结点的权值之和。
3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中。
4）重复步骤2）和3），直至F中只剩下一棵树为止。</p>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog41.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>最后：
1）每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大
2）哈夫曼树的结点总数为2n-1
3）哈夫曼树中不存在度1的结点。
4）哈夫曼树并不唯一，但WPL必然相同且为最优</p>
<h3 id="哈夫曼编码">哈夫曼编码
</h3><p>Eg：</p>
<p>A&ndash;00</p>
<p>B&ndash;01</p>
<p>C&ndash;10</p>
<p>D&ndash;11</p>
<p>假设，100题中有80题选C，10题选A，8题选B，2题选D,所有答案的二进制长度=80*2+10*2+8*2+2*2=200bit</p>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog42.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>因为选C的概率大，所以我们可以把哈夫曼编码改良为：</p>
<p>C&ndash;0</p>
<p>A&ndash;10</p>
<p>B-111</p>
<p>D-110</p>
<p>这是一种<strong>可变长度编码—一允许对不同字符用不等长的二进制位表示</strong></p>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog43.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>但是，如果改为：</p>
<p>C&ndash;0</p>
<p>A&ndash;1</p>
<p>B&ndash;111</p>
<p>D&ndash;110</p>
<p>这样是不对的，因为会导致歧义，究其根本原因是字符A没有作为叶子结点</p>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog44.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>固定长度编码一一每个字符用相等长度的二进制位表示</p>
<p>可变长度编码—一允许对不同字符用不等长的二进制位表示</p>
<p>若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码
有哈夫曼树得到哈夫曼编码——字符集中的每个字符作为一个叶子结点，各个字符出现的频度作为结点的权值，根据之前介绍的方法构造哈夫曼树</p>
<h1 id="图">图
</h1><h2 id="图的基本概念">图的基本概念
</h2><h3 id="图的定义">图的定义
</h3><p>图G（Graph）由顶点集V（Vertex）和边集E（Edge）组成，记为G=（V,E），其中V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系（边）集合。若V={v<sub>1</sub>，v<sub>2</sub>..， v<sub>n</sub>}，则用|V|表示图G中<strong>顶点的个数</strong>，也称图G的<strong>阶</strong>，E={u,v)| u∈V,v∈V}，用|E|表示图G中边的条数。
注意：线性表可以是空表，树可以是空树，但<strong>图不可以是空</strong>，即V一定是非空集</p>
<h3 id="无向图有向图">无向图、有向图
</h3><ul>
<li>若E是无向边（简称边）的有限集合时，则图G为无向图。边是顶点的无序对，记为（v,w）或（w, v），因为（v,w）=（w, v），其中v、w是顶点。可以说顶点w和顶点v互为邻接点。边（v,w）依附于顶点w和v，或者说边（v,w）和顶点 、w相关联。</li>
<li>若E是有向边（也称弧）的有限集合时，则图G为有向图。弧是顶点的有序对，记为&lt;v，w&gt;，其中v、w是顶点，v称为弧尾，w称为弧头，&lt;v，w&gt;称为从顶点到顶点w的弧，也称v邻接到w，或w邻接自v。&lt;v,w&gt;≠&lt;w,v&gt;</li>
</ul>
<h3 id="简单图多重图">简单图、多重图
</h3><ul>
<li>简单图——① 不存在重复边；
② 不存在顶点到自身的边</li>
<li>多重图——图G中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联，则G为多重图</li>
</ul>
<h3 id="顶点的度入度出度">顶点的度、入度、出度
</h3><ul>
<li>对于无向图：顶点v的度是指依附于该顶点的边的条数，记为 TD(v)。
在具有n个顶点、e条边的无向图中，∑<sub>i=1</sub><sup>n</sup>TD(v<sub>i</sub>)=2e
即<strong>无向图的全部顶点的度的和等于边数的2倍</strong></li>
<li>对于有向图：
入度是以顶点v为终点的有向边的数目，记为ID(v)；
出度是以顶点v为起点的有向边的数目，记为OD(v)。
顶点v的度等于其入度和出度之和，即TD（v）=ID（V）+ OD（w）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog45.png"
	
	
	
	loading="lazy"
	
	
></p>
<h3 id="顶点-顶点的关系描述">顶点-顶点的关系描述
</h3><ul>
<li>路径一一顶点v<sub>p</sub>到顶点v<sub>q</sub>之间的一条路径是指顶点序列&mdash;&ndash;v<sub>p</sub>,v<sub>i<sub>1</sub></sub>&hellip;&hellip;v<sub>i<sub>m</sub></sub>,v<sub>q</sub></li>
<li>回路一一第一个顶点和最后一个顶点相同的路径称为回路或环</li>
<li>简单路径一一在路径序列中，顶点不重复出现的路径称为简单路径。</li>
<li>简单回路—-除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。</li>
<li>路径长度一一路径上边的数目</li>
<li>点到点的距离一一从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到v的距离。
若从u到v根本不存在路径，则记该距离为无穷（∞）。</li>
<li>无向图中，若从顶点v到顶点w有路径存在，则称v和w是连通的</li>
<li>有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的</li>
</ul>
<h3 id="连通图强连通图">连通图、强连通图
</h3><ul>
<li>
<p>若图G中任意两个顶点都是连通的，则称图G
连通图，否则称为非连通图。</p>
<p>常见考点：
对于n个顶点的无向图G，
若G是连通图，则最少有n-1条边
若G是非连通图，则最多可能有C<sup>2</sup><sub>n-1</sub>条边</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog47.png"
	
	
	
	loading="lazy"
	
	
></p>
<ul>
<li>
<p>若图中任何一对顶点都是强连通的，则称此图为强连通图。</p>
<p>常见考点：
对于n个顶点的有向图G，
若G是强连通图，则最少有n条边（形成回路）</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog48.png"
	
	
	
	loading="lazy"
	
	
></p>
<h3 id="研究图的局部一一子图">研究图的局部一一子图
</h3><p>设有两个图G=(V, E)和G’=(V’,E’)，若<strong>V’是V的子集</strong>，且<strong>E是E’的子集</strong>，则称G’是G的子图。
若有满足<strong>V(G’)=V(G)<strong>的子图G&rsquo;，也就是</strong>顶点相同</strong>，则称其为G的<strong>生成子图</strong></p>
<h3 id="连通分量">连通分量
</h3><ul>
<li>无向图中的<strong>极大连通子图</strong>（<strong>子图必须连通，且包含尽可能多的顶点和边</strong>）称<strong>连通分量</strong>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog52.png"
	
	
	
	loading="lazy"
	
	
></p>
<ul>
<li>有向图中的<strong>极大强连通子图</strong>（<strong>子图必须强连通，同时保留尽可能多的边</strong>）称有向图的<strong>强连通分量</strong></li>
</ul>
<h3 id="生成树">生成树
</h3><ul>
<li>
<p>连通图的<strong>生成树</strong>是包含图中全部顶点的一个<strong>极小连通子图</strong>（<strong>边尽可能的少，但要保持连通</strong>）。</p>
<p>若图中顶点数为n，则它的生成树含有<strong>n-1</strong>条边。<strong>对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。</strong></p>
</li>
<li>
<p>在非连通图中，连通分量的生成树构成了非连通图的<strong>生成森林</strong>。</p>
</li>
</ul>
<h3 id="边的权带权图网">边的权、带权图/网
</h3><ul>
<li><strong>边的权</strong>一一在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。</li>
<li>**带权图/网****一一边上带有权值的图称为带权图，也称网。</li>
<li><strong>带权路径长度</strong>一一当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度</li>
</ul>
<h3 id="几种特形态的图">几种特形态的图
</h3><ul>
<li>
<p><strong>无向完全图</strong></p>
<p>无向完全图一一无向图中任意两个顶点之间都存在边
若无向图的顶点数IVI=n，则IEI ∈ [0, C<sup>2</sup><sub>n</sub>] = [0, n(n-1)/2]</p>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog53.png"
	
	
	
	loading="lazy"
	
	
></p>
</li>
<li>
<p><strong>有向完全图</strong></p>
<p>有向完全图——有向图中任意两个顶点之间都存在方向相反的两条弧
若有向图的顶点数IVI=n，则IEI ∈ [0,2C<sup>2</sup><sub>n</sub>] = [0, n(n-1)]</p>
<p><img src="https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/blog54.png"
	
	
	
	loading="lazy"
	
	
></p>
</li>
</ul>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Red is the right color of Manchester.</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2025 Example Person
    </section>
    
    <section class="powerby">
        
            MU Blog - 分享知识与想法 | 让我们一起进步！ <br/>
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.29.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.792827e77d7f8370f67128f7b2627308cd0fc0f904cb68599da42be10947a225.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
