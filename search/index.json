[{"content":"基础算法 快速排序 基于分治的思想 算法思想 第一步：确定分界点。随机找一个元素作为分界点一般找第一个,也可以是中间值或者随机） 第二步：调整区间。让第一个区间都小于等于中间值，让第二个区间都大于等于中间值。 第三步：递归处理左右两段。 第二步很关键，所以如何处理第二步是最大的问题。\n这里给出一个最易于理解的方法，只是需要额外的空间，可以在忘记其他做法的时候使用此方法。\n第一步：建立两个数组，a[ ] 和 b[ ] 第二步：扫描 q [ l - r ]，把小于中间值的放到 a，其余放到 b 第三步：把 a 放到 q，再把 b 放到 q 模版题 给定你一个长度为n的整数数列。\n请你使用快速排序对这个数列按照从小到大进行排序。\n并将排好序的数列按顺序输出。\n输入格式\n输入共两行，第一行包含整数n。\n第二行包含n个整数（所有整数均在1～10°范围内），表示整个数列。\n输出格式\n输出共一行，包含 n个整数，表示排好序的数列。\n数据范围\n1 ≤ n ≤ 100000\n输入样例：\n5\n31245\n输出样例：\n1 2 3 4 5\n代码样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 1e6 + 10; int n; int q[N]; void quick_sort(int q[],int l,int r){ if(l \u0026gt;= r) return; int x = q[l + r \u0026gt;\u0026gt; 1],i= l - 1,j = r + 1; //为什么不是i=l，j=r？ //和之后的写法有关，此写法会将两个指针开始就向中间移动一次，所以要把指针放到数组的“两侧” while(i \u0026lt; j){ do i ++ ; while(q[i] \u0026lt; x); do j -- ; while(q[j] \u0026gt; x); if(i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j); quick_sort(q, j + 1, r); } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i + 0; i \u0026lt; n ;i ++ ) scanf(\u0026#34;%d\u0026#34;, \u0026amp;q[i]); quick_sort(q, 0, n - 1); for (int i=0; i \u0026lt; n; i ++) printf(\u0026#34;%d\u0026#34;, q[i]); return 0; } 例题(第k个数) 给定一个长度为n的整数数列，以及一个整数K，请用快速选择算法求出数列的第k小的数是多少。\n输入格式 第一行包含两个整数n和k。 第二行包含n个整数（所有整数均在1～10°范围内），表示整数数列。\n输出格式 输出一个整数，表示数列的第k小数。\n数据范围 1≤n≤ 100000，1≤k≤n\n输入样例： 5 3 2 4 1 5 3\n输出样例：\n3\n若用快排时间复杂度为nlogn，用快速排序则只需要n 代码思路（快速排序）：\n找到分界点x（可以用第一个数，中间值，或最后一个数） 左边所有数Left \u0026lt;= x，右边所有数Right \u0026gt;= x 递归排序Left，递归排序Right SL为左边所有数的个数，SR为右边所有数的和\nk \u0026lt;= SL，递归Left k \u0026gt; SR，递归Right 代码样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int n, k; int q[N]; int quick_sort(int l, int r, int k) { if (l \u0026gt;= r) return q[l]; int x = q[l], i = l - 1, j = r + 1; while (i \u0026lt; j) { while (q[ ++ i ] \u0026lt; x); while (q[ -- j ] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } int sl = j - l + 1; if (k \u0026lt;= sl) return quick_sort(l, j, k); return quick_sort(j + 1, r, k - sl); } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for(int i = 0; i \u0026lt; n; i ++ ) cin \u0026gt;\u0026gt; q[i]; cout \u0026lt;\u0026lt; quick_sort(0, n - 1, k) \u0026lt;\u0026lt; endl; return 0; } 归并排序 基于分治的思想\n时间复杂度：nlog2n\n算法思想 第一步：找分界点 第二步：递归排序 left 和 right 第三步：归并 最难处理的为第三步，下面是第三步的处理方法\n第一步：建立两个指针，分别指向两个序列的最小值 第二步：比较两个指针的值，将较小者输出，并指向下一个 第三步：循环执行第二步，直至一个序列的值输出完，将另一个序列的值全部输出 模版题 给定你一个长度为n的整数数列。\n请你使用归并排序对这个数列按照从小到大进行排序。\n并将排好序的数列按顺序输出。\n输入格式\n输入共两行，第一行包含整数n。\n第二行包含 n 个整数（所有整数均在1～10°范围内），表示整个数列。\n输出格式\n输出共一行，包含 n个整数，表示排好序的数列。\n数据范围\n1 ≤ n ≤ 100000\n输入样例：\n5\n3 1 2 4 5\n输出样例：\n1 2 3 4 5\n代码样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; int n; int tmp[N]; int q[N]; void merge_sort(int q[], int l, int r) { if ( l \u0026gt;= r) return; int mid = l + r \u0026gt;\u0026gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if ( q[i] \u0026lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while ( i \u0026lt;= mid ) tmp[k ++ ] = q[i ++ ]; while ( j \u0026lt;= r) tmp[k ++ ] = q[j ++ ]; for ( i = l, j = 0; i \u0026lt;= r; i ++, j ++ ) q[i] = tmp[j]; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for ( int i = 0; i \u0026lt;n; i ++ ) scanf(\u0026#34;%d\u0026#34;, \u0026amp;q[i]); merge_sort(q, 0, n - 1); for ( int i = 0; i \u0026lt; n; i ++ ) printf(\u0026#34;%d \u0026#34;, q[i]); return 0; } 例题(逆序对的数量) 给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。\n逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i \u0026lt; j 且 a [ i ] \u0026gt; a [ j ] ，则其为一个逆序对；否则不是。\n输入格式\n第一行包含整数 n，表示数列的长度。\n第二行包含 n 个整数，表示整个数列。\n输出格式\n输出一个整数，表示逆序对的个数。\n数据范围\n1 ≤ n ≤ 100000\n数列中的元素的取值范围 [1,109]。\n输入样例：\n1 2 6 2 3 4 5 6 1 输出样例：\n1 5 思想 逆序对的定义：在一个数字数组中，如果存在索引 i 和 j（其中 i \u0026lt; j），使得 arr[i] \u0026gt; arr[j]，则称其为一个逆序对。\n暴力解法：\n最简单的计算逆序对的方法是通过两层嵌套循环遍历数组，比较每一对元素，并在找到逆序对时递增计数器。然而，这种方法的时间复杂度为 O(n^2)，对于大型数组可能效率较低。\n基于归并排序的解法 一种高效的计算逆序对的方法是使用修改后的归并排序算法。基本思想是将数组分割为较小的子数组，递归地对它们进行排序，然后在合并过程中计算逆序对。\n**归并排序步骤：**将数组递归地分割为两半，直到每个子数组只有一个元素。然后，将子数组按照排序顺序合并回来，同时在合并过程中计算逆序对。\n合并过程中计算逆序对：在合并两个已排序的子数组时，如果发现逆序对（即 arr[i] \u0026gt; arr[j]），则将逆序对的数量递增为第一个子数组中剩余的元素数量（即 (mid - i + 1)，其中 mid 是合并的子数组的中间索引）。\n这是因为在合并过程中，如果左边的子数组元素 arr[i] 大于右边的子数组元素 arr[j]，则 arr[i] 大于右边子数组中的所有元素，形成逆序对。\n示例 假设一个数组 arr = [4, 3, 2, 1]。\n使用基于归并排序的方法，我们可以如下计算逆序对的数量：\n初始数组：[4, 3, 2, 1]\n归并排序步骤1：[4, 3, 2, 1] -\u0026gt; [4, 3], [2, 1]\n归并排序步骤2：[4, 3], [2, 1] -\u0026gt; [4], [3], [2], [1]\n归并排序步骤3：合并 [4], [3]，得到[3, 4]\n合并过程中计算逆序对： [4] 与 [3] 合并，总逆序对数量 = 1（因为 4 \u0026gt; 3 且 且 4 后面没有其他元素）\n归并排序步骤4：合并 [2], [1], 得到[1, 2]\n合并过程中计算逆序对： [2] 与 [1] 合并，总逆序对数量 = 1（因为 2 \u0026gt; 1 且 且 2 后面没有其他元素）\n归并排序步骤5：[3, 4], [1, 2] -\u0026gt; [1, 2, 3, 4]\n合并过程中计算逆序对：[3, 4] 与 [1, 2] 合并，总逆序对数量 = 4（最开始 3 和 1 比较，因为 3 \u0026gt; 1, 所以逆序对为 mid - l + 1 = 1 - 0 + 1 = 2 个。 接下来3 与 2 比较：因为 3 \u0026gt; 2, 所以逆序对为 mid - l + 1 = 1 - 0 + 1 = 2 个。）\n最终逆序对数量：1 + 1 + 2 + 2 = 6\n时间复杂度：该方法的时间复杂度为 O(n log n)。 归并排序合并过程中计算逆序对数量 若 a[i] \u0026gt; a[j]，则a[i] 和它后面的元素都大于 a[j]，a[i] 构成逆序对数量：res += mid - i + 1; 二分排序 整数二分 有单调性一定可以二分，但二分不一定有单调性 本质：找到一个性质，可以把区间分为两半\n性质：整数二分一定有解，根据题目去判断无解的情况\n算法思想 如果 check 是不是在左半边： 求 mid = ( l + r + 1 ) / 2\nif ( check ( mid ) )\n若 check 为 true : 区间为 [ mid, r ]，更新方式为 l = mid 若 check 为 false : 区间为[ l , mid - 1 ]，更新方式为r = mid - 1 如果 check 是不是在右半边： 求 mid = ( l + r ) / 2\nif ( check ( mid ) )\n若 check 为 true : 区间为 [ l , mid ]，更新方式为 r = mid 若 check 为 false : 区间为 [ mid + 1, r ]，更新方式为 l = mid + 1 记忆方法 有加必有减 int mid = l + r + 1 (加)\u0026raquo; 1; if (check(mid)) l = mid; else r = mid - 1 (减);\n模版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 bool check(int x) {/* ... */} // 检查x是否满足某种性质 // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： int bsearch_1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; } return l; } // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： int bsearch_2(int l, int r) { while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } 数的范围 给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。\n对于每个查询，返回一个元素k的起始位置和终止位置（位置从 0 开始计数）。\n如果数组中不存在该元素，则返回 -1 -1。\n输入格式\n第一行包含整数 n 和 q，表示数组长度和询问个数。\n第二行包含 n 个整数（均在1～10000范围内），表示完整数组。\n接下来 q 行，每行包含一个整数 k，表示一个询问元素。\n输出格式\n共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。\n如果数组中不存在该元素，则返回 -1 -1。\n数据范围\n1 ≤ n ≤ 100000\n1 ≤ q ≤ 10000\n1 ≤ K ≤ 10000\n输入样例：\n6 3\n1 2 2 3 3 4\n3\n4\n5\n输出样例：\n3 4\n5 5\n-1 -1\n代码样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int n, q; int a[N]; int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for (int i = 0; i \u0026lt; n; i ++ ) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); while(q -- ) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); int l = 0, r = n - 1; while(l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if(a[mid] \u0026gt;= x) r = mid; else l = mid + 1; } if(a[l] != x) printf(\u0026#34;-1 -1\\n\u0026#34;); else { printf(\u0026#34;%d \u0026#34;, l); l = 0, r = n - 1; while(l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if(a[mid] \u0026lt;= x) l = mid; else r = mid - 1; } printf(\u0026#34;%d\\n\u0026#34;, l); } } return 0; } 浮点数二分 因为区间可以严格的分为两部分，所以不存在区间问题，所以相较于整数二分比较简单\n模版 1 2 3 4 5 6 7 8 9 10 11 12 13 bool check(double x) {/* ... */} // 检查x是否满足某种性质 double bsearch_3(double l, double r) { const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l \u0026gt; eps) { double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; } return l; } 数的三次方根 给定一个浮点数n，求它的三次方根。\n输入格式\n共一行，包含一个浮点数n。\n输出格式\n共一行，包含一个浮点数，表示问题的解。\n注意，结果保留 6 位小数。\n数据范围\n-10000 ≤ n ≤ 10000\n输入样例：\n1000.00\n输出样例：\n10.000000\n代码样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int e = 1e8; double n; int main(){ cin \u0026gt;\u0026gt; n; double l = -10000, r = 10000; while(r - l \u0026gt; 1e-7) { double mid = (l + r)/2; if (mid * mid * mid \u0026gt;= n) r = mid; else l = mid; } printf(\u0026#34;%lf\u0026#34;, l); return 0; } 高精度（C++） 一般常见的有四种情况：\nA(大整数) + B(大整数) A - B A * B A / B 第一种：A+B 大整数的存储\n第一位存高位还是低位？\u0026ndash;低位（也就是个位）\n模拟人工加法\nvector 这部分代码用到了vector，下面是一些介绍\n在 C++ 中，std::vector 是一个动态数组容器，可以自动调整大小，存储元素。你可以通过以下基本方式来使用 vector：\n引入头文件 1 #include \u0026lt;vector\u0026gt; 定义和初始化 1 2 std::vector\u0026lt;int\u0026gt; vec; // 创建一个空的 vector，存储 int 类型的元素 std::vector\u0026lt;int\u0026gt; vec2 = {1, 2, 3, 4}; // 用初始值初始化 添加元素 1 2 vec.push_back(10); // 向末尾添加一个元素 10 vec.push_back(20); // 向末尾添加一个元素 20 访问元素 1 2 int first = vec[0]; // 使用下标访问元素 int second = vec.at(1); // 使用 at() 方法访问，提供越界检查 获取大小 1 std::cout \u0026lt;\u0026lt; \u0026#34;Size: \u0026#34; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; std::endl; // 获取元素个数 遍历元素 1 2 3 4 5 6 7 for (int i = 0; i \u0026lt; vec.size(); ++i) { std::cout \u0026lt;\u0026lt; vec[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } for (auto\u0026amp; v : vec) { // 使用范围基的 for 循环 std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 删除元素 1 2 vec.pop_back(); // 删除末尾的元素 vec.clear(); // 删除所有元素 修改元素 1 vec[0] = 100; // 修改指定下标的元素 使用 resize 调整大小 1 vec.resize(10, 0); // 将 vector 的大小调整为 10，未初始化的元素值为 0 使用 reserve 为容器预留空间 1 vec.reserve(50); // 为 vector 预留 50 个元素的空间，减少动态扩容的次数 这只是一些基本用法，vector 提供了很多其他方法，可以参考 C++ 官方文档 进一步了解。\n其中还用到了push_back，下面是一些介绍\npush_back 是 C++ 中 std::vector 容器提供的一个成员函数，用来在 vector 的末尾添加一个元素。这个方法会将指定的元素添加到 vector 的末尾，并自动调整容器的大小（如果需要的话），以便容纳新元素。\n语法：\n1 vector.push_back(value); ​\t•\tvalue 是你想要添加到 vector 末尾的元素。\n特点：\n​\t•\t自动扩容：当 vector 的容量不足以容纳新的元素时，push_back 会自动为 vector 分配更多的内存。\n​\t•\t时间复杂度：大多数情况下，push_back 操作的时间复杂度为 O(1)，但是如果发生了扩容（当空间不足时），它的时间复杂度会是 O(n)，其中 n 是当前 vector 中元素的个数。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; vec; // 使用 push_back 向 vector 中添加元素 vec.push_back(10); vec.push_back(20); vec.push_back(30); // 输出 vec 中的元素 for (int v : vec) { std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 输出：\n1 10 20 30 在这个例子中，我们通过 push_back 向 vector 添加了三个整数 10、20 和 30。\nC++11中添加了一种新特性——范围遍历\nC++11 引入了一种新的方式来遍历容器，称为 范围基 for 循环（range-based for loop）。它使得遍历容器变得更加简洁和易读。\n语法：\n1 2 3 for (declaration : container) { // 代码块 } ​\t•\tdeclaration 是你想要访问容器元素的声明。可以是值，也可以是引用。\n​\t•\tcontainer 是你要遍历的容器，比如 vector、array、list 等。\n特点：\n​\t1.\t简洁：范围基 for 循环自动处理了迭代器或下标，避免了传统 for 循环中手动增加迭代器或下标的繁琐。\n​\t2.\t安全：对于容器元素，范围基 for 循环会确保访问的每个元素都是有效的，并且不会发生越界。\n​\t3.\t支持任何容器：不仅限于数组，vector、list、set 等容器都可以使用范围基 for 循环。\n示例：\n遍历数组： 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; int main() { int arr[] = {1, 2, 3, 4, 5}; // 使用范围基 for 循环遍历数组 for (int x : arr) { std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 输出：\n1 1 2 3 4 5 这里，x 是数组中的每个元素，范围基 for 循环自动遍历整个数组。\n遍历 vector： 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; vec = {10, 20, 30, 40}; // 使用范围基 for 循环遍历 vector for (int x : vec) { std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 输出：\n1 10 20 30 40 使用引用避免不必要的拷贝： 如果容器元素比较大，使用引用可以避免不必要的拷贝操作，提高性能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;std::string\u0026gt; vec = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;}; // 使用引用来避免拷贝 for (const std::string\u0026amp; fruit : vec) { std::cout \u0026lt;\u0026lt; fruit \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 输出：\n1 apple banana cherry 这里使用了 const std::string\u0026amp; 来避免复制 vector 中的字符串。\n修改容器中的元素： 如果你想修改容器中的元素，可以使用非 const 引用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4}; // 使用引用来修改容器中的元素 for (int\u0026amp; x : vec) { x *= 2; // 每个元素乘以 2 } // 输出修改后的结果 for (int x : vec) { std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 输出：\n1 2 4 6 8 总结：\nC++11 中的范围基 for 循环使得遍历容器变得更加简洁且易于理解。它既可以用于读取容器中的元素，也可以用于修改元素，提升了代码的可读性和效率。\n高精度加法 —— 模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // C = A + B, A \u0026gt;= 0, B \u0026gt;= 0 vector\u0026lt;int\u0026gt; add(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt; \u0026amp;B) { if (A.size() \u0026lt; B.size()) return add(B, A); vector\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size(); i ++ ) { t += A[i]; if (i \u0026lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if (t) C.push_back(t); return C; } 例题 给定两个正整数（不含前导 O），计算它们的和。\n输入格式\n共两行，每行包含一个整数。\n输出格式\n共一行，包含所求的和。\n数据范围\n1 ≤ 整数长度 ≤ 100000\n输入样例：\n12\n23\n输出样例：\n35\n代码样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector \u0026lt;int\u0026gt; add(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt; \u0026amp;B) { vector\u0026lt;int\u0026gt; C; int t = 0; if (A.size() \u0026lt; B.size()) return add(B, A); for (int i = 0; i \u0026lt; A.size(); i ++ ) { t += A[i]; if(i \u0026lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if (t) C.push_back(1); return C; } int main() { string a, b; vector\u0026lt;int\u0026gt; A, B; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; for (int i = a.size() - 1; i \u0026gt;= 0; i -- ) A.push_back(a[i] - \u0026#39;0\u0026#39;); for (int i = b.size() - 1; i \u0026gt;= 0; i -- ) B.push_back(b[i] - \u0026#39;0\u0026#39;); auto C = add (A, B); for (int i = C.size() - 1; i \u0026gt;= 0; i -- ) cout \u0026lt;\u0026lt; C[i]; return 0; } 第二种：A-B 整体思想\n分两种情况:\nA \u0026gt;= B : A - B A \u0026lt; B : - ( B - A ) 模版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // C = A - B, 满足A \u0026gt;= B, A \u0026gt;= 0, B \u0026gt;= 0 vector\u0026lt;int\u0026gt; sub(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt; \u0026amp;B) { vector\u0026lt;int\u0026gt; C; for (int i = 0, t = 0; i \u0026lt; A.size(); i ++ ) { t = A[i] - t; if (i \u0026lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t \u0026lt; 0) t = 1; else t = 0; } while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); return C; } 例题 给定两个正整数（不含前导 O），计算它们的差，计算结果可能为负数。\n输入格式\n共两行，每行包含一个整数。\n输出格式\n共一行，包含所求的差。\n数据范围\n1 ≤ 整数长度 ≤ 105\n输入样例：\n32\n11\n输出样例：\n21\n代码样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; bool cmp(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt; \u0026amp;B) { if (A.size() != B.size()) return A.size() \u0026gt; B.size(); for (int i = A.size() - 1; i \u0026gt;= 0; i -- ) { if (A[i] != B[i]) return A[i] \u0026gt; B[i]; } return true; } vector \u0026lt;int\u0026gt; sub(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt; \u0026amp;B) { vector\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size(); i ++ ) { t = A[i] - t; if(i \u0026lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t \u0026lt; 0) t = 1; else t = 0; } while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); return C; } int main() { string a, b; vector\u0026lt;int\u0026gt; A, B; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; for (int i = a.size() - 1; i \u0026gt;= 0; i -- ) A.push_back(a[i] - \u0026#39;0\u0026#39;); for (int i = b.size() - 1; i \u0026gt;= 0; i -- ) B.push_back(b[i] - \u0026#39;0\u0026#39;); if (cmp (A, B)){ auto C = sub (A, B); for (int i = C.size() - 1; i \u0026gt;= 0; i -- ) cout \u0026lt;\u0026lt; C[i]; } else{ auto C = sub (B, A); printf(\u0026#34;-\u0026#34;); for (int i = C.size() - 1; i \u0026gt;= 0; i -- ) cout \u0026lt;\u0026lt; C[i]; } return 0; } 第三种：A*B 模版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // C = A * b, A \u0026gt;= 0, b \u0026gt;= 0 vector\u0026lt;int\u0026gt; mul(vector\u0026lt;int\u0026gt; \u0026amp;A, int b) { vector\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size() || t; i ++ ) { if (i \u0026lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; } while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); return C; } 例题 给定两个非负整数（不含前导 O）A 和B，请你计算A ×B的值。\n输入格式\n共两行，第一行包含整数 A，第二行包含整数 B。\n输出格式\n共一行，包含A×B的值。\n数据范围\n1 ≤ A的长度 ≤ 100000\n0 ≤ B ≤ 10000\n输入样例：\n2\n3\n输出样例：\n6\n代码样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; mul(vector\u0026lt;int\u0026gt; \u0026amp;A, int b) { vector\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size() || t; i ++ ) { if (i \u0026lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; } // while(t){ // C.push_back((t + 10) % 10); // t /= 10; // } while(C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); return C; } int main() { string a; int b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; vector\u0026lt;int\u0026gt; A; for (int i = a.size() - 1; i \u0026gt;= 0; i -- ) A.push_back(a[i] - \u0026#39;0\u0026#39;); auto C = mul(A, b); for (int i = C.size() - 1; i \u0026gt;= 0; i -- ) printf(\u0026#34;%d\u0026#34;, C[i]); return 0; } 第四种：A/B 模版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // A / b = C ... r, A \u0026gt;= 0, b \u0026gt; 0 vector\u0026lt;int\u0026gt; div(vector\u0026lt;int\u0026gt; \u0026amp;A, int b, int \u0026amp;r) { vector\u0026lt;int\u0026gt; C; r = 0; for (int i = A.size() - 1; i \u0026gt;= 0; i -- ) { r = r * 10 + A[i]; C.push_back(r / b); r %= b; } reverse(C.begin(), C.end()); while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); return C; } 例题 给定两个非负整数（不含前导 O）A，B，请你计算 A/B的商和余数。\n输入格式\n共两行，第一行包含整数 A，第二行包含整数 B。\n输出格式\n共两行，第一行输出所求的商，第二行输出所求余数。\n数据范围\n1 ≤ A的长度 ≤ 100000\n1 ≤ B ≤10000，\nB 一定不为0\n输入样例：\n7\n2\n输出样例：\n3\n1\n代码样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; div(vector\u0026lt;int\u0026gt; \u0026amp;A, int \u0026amp;b, int \u0026amp;r) { vector\u0026lt;int\u0026gt; C; r = 0; for (int i = A.size() - 1; i \u0026gt;= 0; i -- ) { r = r * 10 + A[i]; C.push_back(r / b); r %= b; } reverse(C.begin(), C.end()); while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); return C; } int main() { string a; int b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; vector\u0026lt;int\u0026gt; A; for (int i = a.size() - 1; i \u0026gt;= 0; i -- ) A.push_back(a[i] - \u0026#39;0\u0026#39;); int r; auto C = div(A, b, r); for (int i = C.size() - 1; i \u0026gt;= 0; i -- ) cout \u0026lt;\u0026lt; C[i]; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; return 0; } 前缀和 一维前缀和 定义：一个数组的前 i 项和 Si , 下标一定从 1 开始！\n如何求 Si ?\nfor 循环遍历，Si = Si - 1 + a[i]\nSi 的作用？\n快速的求出数组中一段数的和\n公式：S[i , j] = S[i - 1, j] + S[i, j - 1] - S[i - 1, j - 1] + a[i , j]\n具体做法：\n首先做一个预处理，定义一个sum [ ] 数组，sum [ i ] 代表 a 数组中前 i 个数的和。\n求前缀和运算：\n1 2 3 4 5 6 const int N = 1e5+10; int sum[N], a[N]; //sum[i] = a[1] + a[2] + a[3] ..... a[i]; for(int i = 1; i \u0026lt;= n;i++) { sum[i] = sum[i - 1] + a[i]; } 然后查询操作：\n1 2 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); printf(\u0026#34;%d\\n\u0026#34;, sum[r] - sum[l - 1]); 对于每次查询，只需执行sum[r] - sum[l - 1] ，时间复杂度为O(1)\n原理\n1 2 3 sum[r] = a[1] + a[2] + a[3] + a[l-1] + a[l] + a[l+1] ...... a[r]; sum[l - 1] = a[1] + a[2] + a[3] + a[l - 1]; sum[r] - sum[l - 1] = a[l] + a[l + 1]+......+ a[r]; 图解\n这样，对于每个询问，只需要执行 sum[r]-sum[l-1]。输出原序列中从第l个数到第r个数的和的时间复杂度变成了O(1)。\n我们把它叫做一维前缀和。\n例题 (前缀和) 输入一个长度为 n 的整数序列。\n接下来再输入 m 个询问，每个询问输入一对！，「。\n对于每个询问，输出原序列中从第1 个数到第r个数的和。\n输入格式\n第一行包含两个整数 n 和 m。\n第二行包含 n个整数，表示整数数列。\n接下来 m 行，每行包含两个整数！和「，表示一个询问的区间范围。\n输出格式\n共m行，每行输出一个询问的结果。\n数据范围\n1 =\u0026lt; l =\u0026lt; r =\u0026lt; n，\n1 ≤ n , m ≤ 100000，\n-1000 ≤ 数列中元素的值 ≤ 1000\n输入样例：\n5 3\n2 1 3 6 4\n1 2\n1 3\n2 4\n输出样例：\n3\n6\n10\n代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int n, m; int s[N], a[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i ++ ) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; i ++ ) s[i] = s[i - 1] + a[i - 1]; while (m -- ) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; s[r] - s[l - 1] \u0026lt;\u0026lt; endl; } return 0; } 二维前缀和 两个问题\ns [i , j] 如何计算？\n公式：S[i , j] = S[i - 1, j] + S[i, j - 1] - S[i - 1, j - 1] + a[i , j]\n(x1, y1) , (x2, y2) 这一子矩阵中所有数的和该如何计算？\n公式：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\n如图：\n紫色面积是指 (1,1) 左上角到 (i, j - 1) 右下角的矩形面积, 绿色面积是指 (1,1) 左上角到 ( i - 1, j ) 右下角的矩形面积。每一个颜色的矩形面积都代表了它所包围元素的和。\n从图中我们很容易看出，整个外围蓝色矩形面积 s [i] [j] = 绿色面积s [i-1] [j] + 紫色面积 s [i] [j-1] - 重复加的红色的面积s [i-1] [j-1] + 小方块的面积a [i] [j];\n因此得出二维前缀和预处理公式\ns[i] [j] = s [i-1] [j] + s [i] [j-1 ] + a[i] [j] - s [i-1] [ j-1]\n接下来回归问题去求以 ( x1, y1 ) 为左上角和以 ( x2, y2 ) 为右下角的矩阵的元素的和。\n紫色面积是指 ( 1,1 )左上角到 (x1-1,y2) 右下角的矩形面积 ，黄色面积是指 (1,1) 左上角到(x2,y1-1)右下角的矩形面积；\n不难推出：\n绿色矩形的面积 = 整个外围面积s[x2, y2] - 黄色面积s[x2, y1 - 1] - 紫色面积s[x1 - 1, y2] + 重复减去的红色面积 s[x1 - 1, y1 - 1]\n因此二维前缀和的结论为：\n以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： s[x2, y2] - s[x1 - 1, y2] - s[x2, y1 - 1] + s[x1 - 1, y1 - 1]\n例题 (子矩阵的和) 输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。\n对于每个询问输出子矩阵中所有数的和。\n输入格式 第一行包含三个整数 n，m，q。\n接下来 n 行，每行包含 m 个整数，表示整数矩阵。\n接下来 q 行，每行包含四个整数 x1,y1,x2,y2，表示一组询问。\n输出格式 共 q 行，每行输出一个询问的结果。\n数据范围 1 ≤ n, m ≤ 1000,\n1 ≤ q ≤ 200000,\n1 ≤ x1 ≤ x2 ≤ n,\n1 ≤ y1 ≤ y2 ≤ m,\n−1000 ≤ 矩阵内元素的值 ≤ 1000\n输入样例： 1 2 3 4 5 6 7 3 4 3 1 7 2 4 3 6 2 8 2 1 2 3 1 1 2 2 2 1 3 4 1 3 3 4 输出样例： 1 2 3 17 27 21 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1010; int n, m, q; int a[N][N], s[N][N]; int main() { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;q); for (int i = 1; i \u0026lt;= n; i ++) for (int j = 1; j \u0026lt;= m; j ++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); //初始化前缀和数组 for (int i = 1; i \u0026lt;= n; i ++) for (int j = 1; j \u0026lt;= m; j ++) s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; while(q --) { int x1, x2, y1, y2; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;x1, \u0026amp;y1, \u0026amp;x2, \u0026amp;y2); printf(\u0026#34;%d\\n\u0026#34;, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]); } return 0; } 差分 类似于数学中的求导和积分，差分可以看成前缀和的逆运算。\n差分适用于这样的问题：在一个区间内，每个数都加上一个数\n差分数组：\n首先给定一个原数组 a：a[1], a[2], a[3]\u0026hellip; \u0026hellip;a[n];\n然后我们构造一个数组 b ： b[1] ,b[2] , b[3]\u0026hellip; \u0026hellip; b[i];\n使得 a[i] = b[1] + b[2 ]+ b[3] + \u0026hellip; \u0026hellip; + b[i]\n也就是说，a 数组是 b 数组的前缀和数组，反过来我们把 b 数组叫做 a 数组的差分数组。换句话说，每一个 a[i] 都是 b 数组中从头开始的一段区间和。\n考虑如何构造差分 b 数组？\n最为直接的方法\n如下：\na[0 ]= 0;\nb[1] = a[1] - a[0];\nb[2] = a[2] - a[1];\nb[3] =a [3] - a[2];\n\u0026hellip;\u0026hellip;..\nb[n] = a[n] - a[n-1];\n图示:\n我们只要有b数组，通过前缀和运算，就可以在O(n) 的时间内得到a数组 。\n知道了差分数组有什么用呢？ 别着急，慢慢往下看。\n话说有这么一个问题：\n给定区间 [l ,r ]，让我们把a数组中的 [l, r] 区间中的每一个数都加上 c, 即 a[l] + c , a[l+1] + c , a[l+2] + c \u0026hellip; \u0026hellip; a[r] + c;\n暴力做法是 for 循环 l 到 r 区间，时间复杂度 O ( n )，如果我们需要对原数组执行 m 次这样的操作，时间复杂度就会变成 O (n*m)。有没有更高效的做法吗? 考虑差分做法。\n始终要记得，a数组是b数组的前缀和数组，比如对b数组的b[i]的修改，会影响到a数组中从a[i]及往后的每一个数。\n首先让差分b数组中的 b[l] + c ,a数组变成 a[l] + c ,a[l+1] + c,,,,,, a[n] + c;\n然后我们打个补丁，b[r+1] - c, a数组变成 a[r+1] - c,a[r+2] - c,,,,,,,a[n] - c;\n为啥还要打个补丁？\n我们画个图理解一下这个公式的由来:\nb[l] + c，效果使得 a 数组中 a[l]及以后的数都加上了c(红色部分)，但我们只要求 l 到 r 区间加上 c, 因此还需要执行 b[r+1] - c,让a数组中a[r+1]及往后的区间再减去c(绿色部分)，这样对于a[r] 以后区间的数相当于没有发生改变。\n因此我们得出一维差分结论：给a数组中的[ l, r]区间中的每一个数都加上c,只需对差分数组b做 b[l] + = c, b[r+1] - = c。时间复杂度为O(1), 大大提高了效率。\n例题(差分) 输入一个长度为 n 的整数序列。\n接下来输入 m 个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r] 之间的每个数加上 c。\n请你输出进行完所有操作后的序列。\n输入格式 第一行包含两个整数 n 和 m。\n第二行包含 n 个整数，表示整数序列。\n接下来 m 行，每行包含三个整数 l，r，c，表示一个操作。\n输出格式 共一行，包含 n 个整数，表示最终序列。\n数据范围 1≤n,m≤100000, 1≤l≤r≤n, −1000≤c≤1000, −1000≤整数序列中元素的值≤1000\n输入样例： 1 2 3 4 5 6 3 1 2 2 1 2 1 1 3 1 3 5 1 1 6 1 输出样例： 1 3 4 5 3 4 2 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int n, m; int a[N], b[N]; void insert(int l, int r, int c) { b[l] += c; b[r + 1] -= c; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i ++ ) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; i ++) insert(i, i, a[i]); while(m --) { int l, r, c; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; c; insert(l, r, c); } for (int i = 1; i \u0026lt;= n; i ++) b[i] += b[i - 1]; for (int i = 1; i \u0026lt;= n; i ++ ) cout \u0026lt;\u0026lt; b[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } 二维差分 如果扩展到二维，我们需要让二维数组被选中的子矩阵中的每个元素的值加上 c,是否也可以达到 O(1) 的时间复杂度。答案是可以的，考虑二维差分。\na [ ] [ ] 数组是 b [ ] [ ] 数组的前缀和数组，那么b [ ] [ ] 是 a [ ] [ ] 的差分数组\n原数组： a[ i ] [ j ]\n我们去构造差分数组： b [ i ] [ j ]\n使得 a 数组中a [ i ] [ j ] 是 b 数组左上角 ( 1 , 1 ) 到右下角 ( i , j ) 所包围矩形元素的和。\n如何构造b数组呢？\n我们去逆向思考。\n同一维差分，我们构造二维差分数组目的是为了让原二维数组 a 中所选中子矩阵中的每一个元素加上 c 的操作，可以由O ( n * n ) 的时间复杂度优化成 O ( 1 )\n已知原数组 a 中被选中的子矩阵为以 ( x1 , y1 ) 为左上角，以 ( x2 , y2 ) 为右下角所围成的矩形区域;\n始终要记得，a 数组是 b 数组的前缀和数组，比如对 b 数组的 b [ i ] [ j ] 的修改，会影响到a数组中从 a\n[ i ] [ j ] 及往后的每一个数。\n假定我们已经构造好了 b 数组，类比一维差分，我们执行以下操作 来使被选中的子矩阵中的每个元素的值加上 c\n1 2 3 4 5 6 7 b [x1] [y1] += c; b [x1,] [y2 + 1] -= c; b [x2 + 1] [y1] -= c; b [x2+1] [y2+1] += c; 每次对b数组执行以上操作，等价于：\n1 2 3 for(int i=x1;i\u0026lt;=x2;i++) for(int j=y1;j\u0026lt;=y2;j++) a[i][j]+=c; 我们画个图去理解一下这个过程：\nb [x1] [ y1 ] +=c ; 对应图1 ,让整个a数组中蓝色矩形面积的元素都加上了c。\nb [x1,] [y2 + 1]-=c ; 对应图2 ,让整个a数组中绿色矩形面积的元素再减去c，使其内元素不发生改变。\nb [x2 + 1] [y1] -= c ; 对应图3 ,让整个a数组中紫色矩形面积的元素再减去c，使其内元素不发生改变。\nb [x2 + 1] [y2 + 1]+=c; 对应图4,,让整个a数组中红色矩形面积的元素再加上c，红色内的相当于被减了两次，再加上一次c，才能使其恢复。\n我们可以先假想 a 数组为空，那么 b 数组一开始也为空，但是实际上 a 数组并不为空，因此我们每次让 b 数组以 ( i , j ) 为左上角到以 ( i , j ) 为右下角面积内元素（ 其实就是一个小方格的面积 ）去插入 c = a [i] [j]，等价于原数组 a 中 ( i , j ) 到 ( i , j ) 范围内 加上了 a [i] [j] ,因此执行 n * m 次插入操作，就成功构建了差分 b 数组.\n代码如下：\n1 2 3 4 5 6 7 for(int i=1;i\u0026lt;=n;i++) { for(int j=1;j\u0026lt;=m;j++) { insert(i,j,i,j,a[i][j]); //构建差分数组 } } 公式：\n1 2 3 4 b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c; 差分矩阵 输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c，其中 (x1,y1) 和 (x2,y2) 表示一个子矩阵的左上角坐标和右下角坐标。\n每个操作都要将选中的子矩阵中的每个元素的值加上 c。\n请你将进行完所有操作后的矩阵输出。\n输入格式 第一行包含整数 n,m,q。\n接下来 n 行，每行包含 m 个整数，表示整数矩阵。\n接下来 q 行，每行包含 5 个整数 x1,y1,x2,y2,c，表示一个操作。\n输出格式 共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。\n数据范围 1 ≤ n, m ≤ 1000,\n1 ≤ q ≤ 100000,\n1 ≤ x1 ≤ x2 ≤ n,\n1 ≤ y1 ≤ y2 ≤ m,\n−1000 ≤ c ≤ 1000,\n−1000 ≤ 矩阵内元素的值 ≤ 1000\n输入样例： 1 2 3 4 5 6 7 3 4 3 1 2 2 1 3 2 2 1 1 1 1 1 1 1 2 2 1 1 3 2 3 2 3 1 3 4 1 输出样例： 1 2 3 2 3 4 1 4 3 4 1 2 2 2 2 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; const int N = 1e3 + 10; int a[N][N], b[N][N]; void insert(int x1, int y1, int x2, int y2, int c) { b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c; } int main() { int n, m, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) cin \u0026gt;\u0026gt; a[i][j]; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { insert(i, j, i, j, a[i][j]); //构建差分数组 } } while (q--) { int x1, y1, x2, y2, c; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2 \u0026gt;\u0026gt; c; insert(x1, y1, x2, y2, c); } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1]; //二维前缀和 } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { printf(\u0026#34;%d \u0026#34;, b[i][j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 双指针算法 第一类：两个指针指向两个序列 例如：归并排序 第二类：两个指针指向一个序列 例如：快速排序 通用模版 1 2 3 4 for(u=0,j=0:i\u0026lt;n;i++) { while(j\u0026lt;i \u0026amp;\u0026amp; check(i,j)) j++; } 核心思想：\n1 2 for(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;n;j++) 可以将以上算法(O(n2))优化到n\n例题 最长连续不重复子序列\n给定一个长度为n的整数序列，请找出最长的不包含重复数字的连续子序列，输出它的长度。\n输入格式\n第一行包含整数n。\n第二行包含n个婺数（均在0~100000范围内），表示婺数序列。\n输出格式\n共一行，包含一个整数，表示最长的不包含重复数字的连续子序列的长度。\n数据范围\n1 ≤ n ≤ 105\n暴力做法\n1 2 3 4 5 6 for(int i=0;i\u0026lt;=n:i++) for(int j=0;j\u0026lt;=i;j++) if(check(j,i)) { res=max(res,i-j+1) } 优化做法\n思路：因为 j 不可能向前移动，所以不必两重循环，只需循环 i，判断 j 是否需要向后移动即可 1 2 3 4 5 6 for(int i=0;i\u0026lt;=n;i++) { while(j\u0026lt;=i \u0026amp;\u0026amp; check(j,i)) j++ res = max(res,i-j+1) } 至于 check 函数，可以引入一个数组 s[N]，动态记录每个数出现了多少次 完整做法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int n; int a[N],s[N]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i ++ ) cin \u0026gt;\u0026gt; a[i]; int res = 0; for (int i = 0, j = 0; i \u0026lt; n; i ++ ) { s[a[i]] ++; while (s[a[i]] \u0026gt; 1) { s[a[j]] --; j ++; } res = max(res, i - j + 1); } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } Tips: 如果数据很大，或者不想开数组，可以用哈希表 双指针算法思路 先写一个暴力算法，看一下 i 和 j 之间有什么单调关系，利用这种单调关系和模版，来使数量级从 n2 到 n。 位运算 基本问题：n的二进制表示中第k位是几\n基本思路：\n先把第k位移到最后一位\u0026mdash;n \u0026raquo; k 看个位是几\u0026mdash;x \u0026amp; 1 Lowbit：\nlowbit(x)：返回x的最后一位1（以二进制的形式返回）\n～x：x取反\n-x=～x+1\nx \u0026amp; -x：这就是lowbit的执行过程\n应用：\n计算出x中1的个数 例题（二进制中1的个数） 给定一个长度为n的数列，请你求出数列中每个数的二进制表示中1的个数。\n输入格式\n第一行包含整数n。\n第二行包含n个整数，表示整个数列。\n输出格式\n共一行，包含n 个整数，其中的第i个数表示数列中的第i个数的二进制表示中1的个数。\n数据范围\n1 ≤ n ≤ 100000\n0 ≤ 数列中元素的值 ≤ 109\n输入样例：\n5\n1 2 3 4 5\n输出样例：\n1 1 2 1 2\n代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; int lowbit(int x) { return x \u0026amp; -x； } int main() { int n; cin \u0026gt;\u0026gt; n; while (n -- ){ int x; cin \u0026gt;\u0026gt; x; int res = 0; while (x) x-= lowbit(x), res ++ ; } return 0; } 离散化（整数，保序） 基本问题：存在一组数，值域很大，但是个数很少，把这一组数映射到从 0 开始的自然数中，就是离散化 两个基本问题：\n可能有重复元素\u0026mdash;去重 1 2 3 4 5 vector\u0026lt;int\u0026gt; alls;// 存储所有待离散化的值 sort(alls.begin(), alls.endO);// 将所有值排序 alls.erase(unique(alls.begin(), alls.end()), alls.end());// 去掉重复元素 ​\n​\tunique会把数组中所有重复的值放到最后，并返回去重后数组的最后一个下标\n如何算出x离散化的值\u0026mdash;二分 1 2 3 4 5 6 7 8 9 10 int find()//找到第一个大于x的位置 { int i = 0,r = alls.size() - 1; while(i \u0026lt; r){ int mid = i + r \u0026gt;\u0026gt; 1; if (alls[mid] \u0026gt;= x) r = mid; else i = mid + 1; } return r + 1;//映射到1，2......n } 例题（区间和） 假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。\n现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。\n近下来，进行 m 次询问，每个询问包含两个整数 l 和 r ，你需要求出在区间 [ l,r ] 之间的所有数的和。\n输入格式\n第一行包含两个整数 n 和 m 。\n接下来 n 行，每行包含两个整数 x 和 c 。\n再接下里 m 行，每行包含两个整数 l 和 r。\n输出格式\n共m行，每行输出一个询问中所求的区间内数字和。\n数据范围\n-109 ≤ x ≤ 109 1 ≤ n , m ≤ 105 -109≤ l ≤ r ≤ 109 -10000 ≤ c ≤ 10000\n输入样例：\n3 3\n1 2\n3 6\n7 5\n1 3\n4 6\n7 8\n输出样例：\n8\n0\n5\n数据范围较小可以用前缀和 代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 300010; typedef pair\u0026lt;int , int\u0026gt; PII; int n,m; int a[N], s[N]; vector\u0026lt;int\u0026gt; alls; vector\u0026lt;PII\u0026gt; add, query; int find (int x) { int l = 0, r = alls.size() - 1; while (l \u0026lt; r) { int mid = (l+ r)/2; if (alls[mid] \u0026gt;= x) r = mid; else l = mid + 1; } return r + 1; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i ++ ) { int x, c; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; c; add.push_back({x, c}); alls.push_back(x); } for (int i = 0; i \u0026lt; m; i ++ ) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; query.push_back({l,r}); alls.push_back(l); alls.push_back(r); } sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(),alls.end()), alls.end()); for (auto item : add) { int x = find(item.first); a[x] += item.second; } for (int i = 1; i \u0026lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i]; for (auto item : query) { int l = find(item.first), r = find(item.second); cout \u0026lt;\u0026lt; s[r] - s[l - 1] \u0026lt;\u0026lt; endl; } } unique函数怎么手动实现？（双指针算法） 1 2 3 4 5 6 7 8 9 10 11 vector\u0026lt;int\u0026gt;::iterator unique(vector\u0026lt;int\u0026gt; \u0026amp;a) { int j = 0; for (int i = 0; i \u0026lt; a.size(); i ++ ) if(!i || a[i] != a[i - 1]) a[j ++ ] = a[i]; // a[0] ~ a[j - 1] 所有a中不重复的数 return a.begin() + j; } 区间合并 **基本问题：**把有交集的区间合并（有端点相交也合并） 解题步骤： 按左端点合并 扫描并合并区间 例题（区间合并） 给定n个区间 [ li，ri ] , 要求合并所有有交集的区间。 注意如果在端点处相交，也算有交集。 输出合并完成后的区间个数。\n输入格式 第一行包含堥数n。 接下来n行，每行包含两个整数1和 r\n输出格式 共一行，包含一个整数，表示合并区间完成后的区间个数。\n数据范围 1 ≤ n ≤ 100000 -109 ≤ li ≤ ri ≤ 109\n输入样例：\n5\n1 2\n2 4\n5 6\n7 8\n7 9 输出样例： 3\n代码样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 100010; int n; vector\u0026lt;PII\u0026gt; segs; void merge(vector\u0026lt;PII\u0026gt; \u0026amp;segs) { vector\u0026lt;PII\u0026gt; res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for (auto seg : segs) if (ed \u0026lt; seg.first) { if (st != -2e9) res.push_back({st, ed}); st = seg.first, ed = seg.second; } else ed = max(ed, seg.second); if (st != -2e9) res.push_back({st, ed}); segs = res; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i ++ ) { int l,r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; segs.push_back({l,r}); } merge(segs); cout \u0026lt;\u0026lt; segs.size() \u0026lt;\u0026lt; endl; return 0; } 数据结构 链表与邻接表 TIps： 1 2 3 4 struct Node{ Int val; Node *next; } 这种动态创建的方式太慢了，不建议使用。\n数组模拟单链表 最常用的一种单链表\n邻接表\u0026mdash;存储图和树\n例题（单链表） 实现一个单链表，链表初始为空，支持三种操作：\n（1）向链表头插入一个数；\n（2） 删除第k个插入的数后面的数；\n（3） 在第k个插入的数后插入一个数\n现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。\n注意：题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺\n序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。\n输入格式\n第一行包含整数M，表示操作次数。\n接下来M行，每行包含一个操作命令，操作命令可能为以下几种：\n（1）“Hx，表示向链表头插入一个数X。\n（2）“D K”，表示删除第k个输入的数后面的数（当k为0时，表示删除头结点）。\n（3）“1kx，表示在第k个输入的数后面插入一个数x（此操作中K均大于O）。\n输出格式\n共一行，将整个链表从头到尾输出。\n数据范围\n1 ≤ M ≤ 100000\n所有操作保证合法。\n输入样例：\n10\nH 9\nI 1 1\nD 1\nD 0\nH 6\nI 3 6\n1 4 5\n1 4 5\n1 3 4\nD 6\n输出样例：\n6 4 6 5\n代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; // head 表示头结点的下标 // e[i]表示节点立的值 // ne[i] 表示节点i的next描针是多少 // idx 存储当前己经用到了哪个点 int head, e[N], ne[N], idx; int x; //初始化 void init() { head = -1; idx = 0; } //将x插到头结点 void add_to_head(int x) { e[idx] = x; ne[idx] = head; head = idx; idx ++; } //将x插到k后面 void add(int k, int x) { e[idx] = x; ne[idx] = ne[k]; ne[k] = idx; idx ++; } //将下标点是k的点后面的点删掉 void remove(int k) { ne[k] = ne[ne[k]] } int main() { int m; cin \u0026gt;\u0026gt; m; init(); while (m -- ) { int k; char op; cin \u0026gt;\u0026gt; op; if (op == \u0026#39;H\u0026#39;) { cin \u0026gt;\u0026gt; x; add_to_head(x); } else if (op == \u0026#39;D\u0026#39;) { cin \u0026gt;\u0026gt; k; if (!k) head = ne[head]; remove(k - 1); } else { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add(k - 1, x); } } for (int i = head; i != -1; i = ne[i]) cout \u0026lt;\u0026lt; e[i] \u0026lt;\u0026lt;\u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; } 数组模拟双链表 实现一个双链表，双链表初始为空，支持 5 种操作：\n在最左侧插入一个数； 在最右侧插入一个数； 将第 k 个插入的数删除； 在第 k 个插入的数左侧插入一个数； 在第 k 个插入的数右侧插入一个数 现在要对该链表进行 M 次操作，进行完所有操作后，从左到右输出整个链表。\n注意:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。\n输入格式\n第一行包含整数 M，表示操作次数。\n接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：\nL x，表示在链表的最左端插入数 x。 R x，表示在链表的最右端插入数 x。 D k，表示将第 k 个插入的数删除。 IL k x，表示在第 k 个插入的数左侧插入一个数。 IR k x，表示在第 k 个插入的数右侧插入一个数。 输出格式\n共一行，将整个链表从左到右输出。\n数据范围\n1≤M≤100000 所有操作保证合法。\n输入样例：\n1 2 3 4 5 6 7 8 9 10 11 10 R 7 D 1 L 3 IL 2 10 D 3 IL 2 7 L 8 R 9 IL 4 7 IR 2 2 输出样例：\n1 8 7 7 3 2 9 代码样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; const int N = 100010; int e[N], l[N], r[N], idx; int m; void init() { l[1] = 0, r[0] = 1; idx = 2; } void add(int k, int x) { e[idx] = x; r[idx] = r[k]; l[idx] = k; l[r[k]] = idx; r[k] = idx; idx ++; } void remove(int k) { r[l[k]] = r[k]; l[r[k]] = l[k]; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; m; init(); while(m -- ) { int k, x; string op; cin \u0026gt;\u0026gt; op; if (op == \u0026#34;L\u0026#34;) { cin \u0026gt;\u0026gt; x; add(0, x); } else if (op == \u0026#34;R\u0026#34;) { cin \u0026gt;\u0026gt; x; add(l[1], x); } else if (op == \u0026#34;D\u0026#34;) { cin \u0026gt;\u0026gt; k; remove(k + 1); } else if(op == \u0026#34;IL\u0026#34;) { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add(l[k + 1], x); } else { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add(k + 1, x); } } for(int i = r[0]; i != 1; i = r[i]) cout \u0026lt;\u0026lt; e[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return 0; } Q : 为什么是 k + 1 ?\nA : （ANSWER）\n栈与队列 栈：先进后出 队列：先进先出 例题（模拟栈） 实现一个栈，栈初始为空，支持四种操作：\npush x – 向栈顶插入一个数 x； pop – 从栈顶弹出一个数； empty – 判断栈是否为空； query – 查询栈顶元素。 现在要对栈进行 M 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。\n输入格式\n第一行包含整数 M，表示操作次数。\n接下来 M 行，每行包含一个操作命令，操作命令为 push x，pop，empty，query 中的一种。\n输出格式\n对于每个 empty 和 query 操作都要输出一个查询结果，每个结果占一行。\n其中，empty 操作的查询结果为 YES 或 NO，query 操作的查询结果为一个整数，表示栈顶元素的值。\n数据范围\n1≤M≤100000,\n1≤x≤109\n所有操作保证合法，即不会在栈为空的情况下进行 pop 或 query 操作。\n输入样例：\n1 2 3 4 5 6 7 8 9 10 11 10 push 5 query push 6 pop query pop empty push 4 query empty 输出样例：\n1 2 3 4 5 5 5 YES 4 NO 代码样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; const int N = 100010; int str[N], tt; void init() { tt = 0; } int main() { int m; cin \u0026gt;\u0026gt; m; init(); while(m -- ) { string op; cin \u0026gt;\u0026gt; op; int x; if (op == \u0026#34;push\u0026#34;) { cin \u0026gt;\u0026gt; x; str[++ tt] = x; } else if(op == \u0026#34;pop\u0026#34;) { tt --; } else if(op == \u0026#34;empty\u0026#34;) { if(tt == 0) cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; str[tt] \u0026lt;\u0026lt; endl; } } return 0; } 模拟队列 实现一个队列，队列初始为空，支持四种操作：\npush x – 向队尾插入一个数 x； pop – 从队头弹出一个数； empty – 判断队列是否为空； query – 查询队头元素。 现在要对队列进行 M 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。\n输入格式\n第一行包含整数 M，表示操作次数。\n接下来 M 行，每行包含一个操作命令，操作命令为 push x，pop，empty，query 中的一种。\n输出格式\n对于每个 empty 和 query 操作都要输出一个查询结果，每个结果占一行。\n其中，empty 操作的查询结果为 YES 或 NO，query 操作的查询结果为一个整数，表示队头元素的值。\n数据范围\n1≤M≤100000,\n1≤x≤109,\n所有操作保证合法，即不会在队列为空的情况下进行 pop 或 query 操作。\n输入样例：\n1 2 3 4 5 6 7 8 9 10 11 10 push 6 empty query pop empty push 3 push 4 pop query push 6 输出样例：\n1 2 3 4 NO 6 YES 4 代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; const int N = 100010; int str[N], hh, tt; void init() { tt = -1; hh = 0; } int main() { int m; cin \u0026gt;\u0026gt; m; init(); while(m -- ) { string op; cin \u0026gt;\u0026gt; op; int x; if (op == \u0026#34;push\u0026#34;) { cin \u0026gt;\u0026gt; x; str[++ tt] = x; } else if (op == \u0026#34;pop\u0026#34;) { hh ++; } else if (op == \u0026#34;empty\u0026#34;) { if (hh \u0026lt;= tt) cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; } else if (op == \u0026#34;query\u0026#34;) { cout \u0026lt;\u0026lt; str[hh] \u0026lt;\u0026lt; endl; } } return 0; } 单调栈 给定一个长度为N的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出-1。\n输入格式\n第一行包含整数N，表示数列长度。\n第二行包含N个整数，表示整数数列。\n输出格式\n共一行，包含N个整数，其中第i个数表示第i个数的左边第一个比它小的数，如果不存在则输出-1。\n数据范围\nI ≤ N ≤ 105\n1≤ 数列中元素 ≤109\n输入样例：\n1 2 5 3 4 2 7 5 输出样例：\n1 -1 3 -1 2 2 代码样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int stk[N], tt = 0; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i ++ ) { int x; cin \u0026gt;\u0026gt; x; while (tt \u0026amp;\u0026amp; stk[tt] \u0026gt;= x) tt --; if (tt) cout \u0026lt;\u0026lt; stk[tt] \u0026lt;\u0026lt;\u0026#34; \u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34; \u0026lt;\u0026lt;\u0026#34; \u0026#34;; stk[++ tt] = x; } return 0; } 本道题思考过程： 例如，存在 a3 \u0026lt;= a5 ，那么a3 就永远不会输出，因为 a5 总是更好的选择。实际上，只要逆序的元素删去，整个栈就变成单调的了，再找起来时间复杂度就低多了\n思想\n与双指针算法类似，先写暴力做法，再在其中找出一些性质（比如这道题就可以思考一下哪些数是永远不会被找到的）以减小时间复杂度\n滑动窗口 （单调队列的入门题目）\n给定一个大小为n ≤ 106的数组。\n有一个大小为k的滑动窗口，它从数组的最左边移动到最右边。\n您只能在窗口中看到k个数字。\n每次滑动窗口向右移动一个位置。\n以下是一个例子：\n该数组为[1 3 -1 -3 5 3 6 7 ］，k为3。\n窗口位置 最小值 最大值 [1 3 -1] -3 5 3 6 7 -1 -3 1 [3 -1 -3] 5 3 6 7 -3 3 1 3 [-1 -3 5] 3 6 7 -3 5 1 3 -1 [-3 5 3] 6 7 -3 5 1 3 -1 -3 [5 3 6] 7 3 6 1 3 -1 -3 5 [3 6 7] 3 7 您的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。\n输入格式\n输入包含两行。\n第一行包含两个整数n和k，分别代表数组长度和滑动窗口的长度。\n第二行有n个整数，代表数组的具体数值。\n同行数据之间用空格隔开。\n输出格式\n输出包含两个。\n第一行输出，从左至右，每个位置滑动窗口中的最小值。\n第二行输出，从左至右，每个位置滑动窗口中的最大值。\n输入样例：\n8 3\n1 3-1 -3 5 3 6 7\n输出样例：\n-1 -3 -3 -3 3 3\n3 3 5 5 6 7\n代码样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010; int n, k; int a[N], q[N]; int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for (int i =0; i \u0026lt; n; i++ ) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); int hh = 0, tt = -1; for ( int i = 0; i \u0026lt; n; i ++ ) { //判断队头是否已经滑出窗口 if (hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh]) hh ++ ; while (hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026gt;= a[i]) tt -- ; q[ ++ tt] = i; if (i \u0026gt;= k - 1) printf(\u0026#34;%d \u0026#34;, a[q[hh]]); } puts(\u0026#34;\u0026#34;); hh = 0, tt = -1; for ( int i = 0; i \u0026lt; n; i ++ ) { //判断队头是否已经滑出窗口 if (hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh]) h ++ ; while (hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026lt;= a[i]) tt -- ; q[ ++ tt] = i; if (i \u0026gt;= k - 1) printf(\u0026#34;%d \u0026#34;, a[q[hh]]); } puts(\u0026#34;\u0026#34;); return 0; } 思想：\n先思考用普通队列该怎么做 将队列中的没有用的元素删掉 \u0026mdash;-\u0026gt; 具有了单调性 可以用 O(1) 时间从队头/队尾取出最值 题目中提到了滑动窗口，我们先以示例为例看下什么是滑动窗口？在示例中，我们从数组中第一个元素开始遍历，由于窗口的大小是3，因此当遍历到第三个元素时，窗口就形成了。\n之后，继续遍历元素时，为了保持窗口的大小为3，左侧元素就需要从窗口中剔除。这样使得窗口一直在向右移动，直到考察到最后一个元素结束，这就是所谓的滑动窗口。\n解题思路（以最大值为例）：\n由于我们需要求出的是滑动窗口的最大值。\n如果当前的滑动窗口中有两个下标 i 和 j ，其中 i 在 j 的左侧（i \u0026lt; j），并且 i 对应的元素不大于 j 对应的元素（nums [ i ] ≤ num s [ j ] ），则：\n当滑动窗口向右移动时，只要 i 还在窗口中，那么 j 一定也还在窗口中。这是由于 i 在 j 的左侧所保证的。\n因此，由于 nums [ j ] 的存在，nums [ i ] 一定不会是滑动窗口中的最大值了，我们可以将nums [ i ] 永久地移除。\n因此我们可以使用一个队列存储所有还没有被移除的下标。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组nums中对应的值是严格单调递减的。\n当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。\n为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果新元素大于等于队尾元素，那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。\n由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。\n窗口向右移动的时候。因此我们还需要不断从队首弹出元素保证队列中的所有元素都是窗口中的，因此当队头元素在窗口的左边的时候，弹出队头。\nKMP KMP 用于字符串匹配问题中\n字符串匹配问题中，给出两个字符串 text 和 pattern (本题中 text 为 S, pattern 为 P)，需要判断 pattern 是否是 text 的子串。一般把 text 称为文本串，pattern 称为模式串。暴力的解法为： 枚举文本串 text 的起始位置 i ，然后从该位开始逐位与模式串 pattern 进行匹配。如果匹配过程中每一位都相同，则匹配成功；否则，只要出现某位不同，就让文本串 text 的起始位置变为 i + 1，并从头开始模式串 pattern 的匹配。假设 m 为文本串的长度，n 为模式串的长度。时间复杂度为 O(n m)。显然，当 n 和 m 都达到 105 级别时无法承受。\n偶遇 next\n面对 KMP 这种复杂的算法，我们必须要将其拆解，逐个击破。假设有一个字符串 s (下标从 0 开始)，那么它以 i 号位作为结尾的子串就是 s[0…i]。对该子串来说，长度为 k + 1 的前缀与后缀分别是 s[0…k] 与 s[i-k…i]。我们构造一个 int 型数组（叫啥无所谓，就叫它 next吧）。其中，next[i] 表示使字串 s[0…i] 中前缀 s[0…k] 等于后缀 s[i-k…i] 的最大的 k。（注意相等的前缀、后缀在原字串中不能是 s[0…i] 本身。这点很重要，在后面感性分析时会用到）；如果找不到相等的前后缀，就令 next[i] = -1。显然，next[i] 就是所求最长相等前后缀中前缀的最后一位的下标。\n接下来通过一个例子，给出 next 数组的变化过程。s = “abababc”。对每个 next[i] 的计算都给出两种阅读方式。建议先看一下第一种并搞清楚第二种。\n第一种方法直接画线画出子串 s[0…i] 的最长相等前后缀：\n第二种方法在上部给出后缀，下部给出前缀，再将相等的最长前后缀框起来。\n这里再次强调一下：next[i] 存储的就是使子串 s[0…i] 有最长相等前后缀的前缀的最后一位的下标。 这句话初读会有些绕，但请务必搞清楚，我们将其命名为至尊概念，是解题的关键。\n与 next 一决胜负\n那么怎么求解 next 呢？暴力做法是可行的，但需要遍历太多次了。下面用 “递推” 的方式来高效求解 next 数组，也就是说我们假设已经求出了 next[0] ~ next[i-1]，用它们来推算出 next[i]。\n还是用我们刚刚感性认识的 s = “abababc” 作为例子。假设已经有了 next[0] = -1、next[1] = -1、next[2] = 0、next[3] = 1，现在来求解 next[4]。如下图所示，当已经得到 next[3] = 1 时，最长相等前后缀为 “ab”，之后计算 next[4] 时，由于 s[4] == s[next[3] + 1] (这里的为什么要用 next[3]？想想至尊概念)，因此可以把最长相等前后缀 “ab” 扩展为 “aba”，因此 next[4] = next[3] + 1，并令 j 指向 next[4]。\n接着在此基础上求解 next[5]。如下图所示，当已经得到 next[4] = 2 时，最长相等前后缀为 “aba”，之后计算 next[5] 时，由于 s[5] != s[next[4] + 1]，因此不能扩展当前相等前后缀，即不能直接通过 next[4] + 1 的方法得到 next[5]。既然相等前后缀没办法达到那么长，那不妨缩短一点！此时希望找到找到一个 j，使得 s[5] == s[j + 1] 成立，同时使得图中的波浪线 ~，也就是 s[0…j] 是 s[0…2] = “aba” 的后缀，而 s[0…j] 是 s[0…2] 的前缀是显然的。同时为了找到相等前后缀尽可能长，找到这个 j 应尽可能大。\n实际上我们上图要求解的 ~ 部分，即 s[0…j] 既是 s[0…2] = “aba” 的前缀，又是 s[0…2] = “aba” 的后缀，同时又希望其长度尽可能长，那么 s[0…j] 就是 s[0…2] 的最长相等前后缀。也就是说，只需要令 j = next[2]，然后再判断 s[5] == s[j + 1] 是否成立：如果成立，说明 s[0…j + 1] 是 s[0…5] 的最长相等前后缀，令 next[5] = j + 1 即可；如果不成立，就不断让 j = next[j]，直到 j 回到了 -1，或是途中 s[5] == s[j + 1] 成立。\n如上图所示，j 从 2 回退到 next[2] = 0，发现 s[5] == s[j + 1] 不成立，就继续让 j 从 0 回退到 next[0] = -1；由于 j 已经回退到了 -1，因此不再继续回退。这时发现 s[i] == s[j + 1] 成立，说明 s[0…j + 1] 是 s[0…5] 的最长相等前后缀，于是令 next[5] = j + 1 = -1 + 1 = 0，并令 j 指向 next[5]。\n下面总结 next 数组的求解过程，并给出代码：\n初始化 next 数组，令 j = next[0] = -1。 让 i 在 1 ~ len - 1范围内遍历，对每个 i ，执行 3、4，以求解 next[i]。 直到 j 回退为 -1，或是 s[i] == s[j + 1] 成立，否则不断令 j = next[j]。 如果 s[i] == s[j + 1]，则 next[i] = j + 1；否则 next[i] = j。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 next[0] = -1; for (int i = 1, j = -1; i \u0026lt; len; i ++) { while (j != -1 \u0026amp;\u0026amp; s[i] != s[j + 1]) // 前后缀匹配不成功 { // 反复令 j 回退到 -1，或是 s[i] == s[j + 1] j = next[j]; } if (s[i] == s[j + 1]) // 匹配成功 { j ++; // 最长相等前后缀变长 } next[i] = j; // 令 next[i] = j } 还请搞清楚：我们刚刚只是对一个字符串进行的 next 数组处理！！！\nhello, kmp!\n在此基础上我们进入 kmp，有了上面求 next 数组的基础，kmp 算法就是在照葫芦画瓢，给定一个文本串 text 和一个模式串 pattern，然后判断模式串 pattern 是否是文本串 text 的子串。 以 text = “abababaabc”、pattern = “ababaab” 为例。令 i 指向 text 的当前欲比较位，令 j 指向 pattern 中当前已被匹配的最后位，这样只要 text[i] == pattern[j + 1] 成立，就说明 pattern[j + 1] 也被成功匹配，此时让 i、j 加 1 继续比较，直到 j 达到 m - 1(m 为 pattern 长度) 时说明 pattern 是 text 的子串。在这个例子中，i 指向 text[4]、j 指向 pattern[3]，表明 pattern[0…3] 已经全部匹配成功了，此时发现 text[i] == pattern[j + 1] 成立，这说明 pattern[4] 成功匹配，于是令 i、j 加 1。\n接着继续匹配，此时 i 指向 text[5]、j 指向 pattern[4]，表明 pattern[0…4] 已经全部匹配成功。于是试着判断 text[i] == pattern[j + 1] 是否成立：如果成立，那么就有 pattern[0…5] 被成功匹配，可以令 i、j 加 1 以继续匹配下一位。但此处 text[5] != pattern[4 + 1]，匹配失败。那么我们这里该怎么做？放弃之前 pattern[0…4] 的成功匹配成果，让 j 回退到 -1 开始重新匹配吗？那是暴力解的方法，我们来看一下 kmp 的处理。\n为了不让 j 直接回退到 -1，应寻求回退到一个离当前的 j （此时 j 为 4）最近的 j’，使得 text[i] == pattern[j’ + 1] 能够成立，并且 pattern[0…j’] 仍然与 text 的相应位置处于匹配状态，即 pattern[0…j’] 是 pattern[0…j] 的后缀。这很容易令人想到之前的求 nnext 数组时碰到的类似问题。答案是 pattern[0…j’] 是 pattern[0…j] 的最长相等前后缀。也就是说，只需要不断令 j = next[j]，直到 j 回退到 -1 或者是 text[i] == pattern[j + 1] 成立，然后继续匹配即可。next 数组的含义就是当 j + 1 位失配时，j 应该回退到的位置。对于刚刚的例子，当 text[5] 与 pattern[4 + 1] 失配时，令 j = next[4] = 2，然后我们会发现 text[i] == pattern[j + 1] 能够成立，因此就让它继续匹配，直到 j == 6 也匹配成功，这就意味着 pattern 是 text 的子串。\nkmp 算法的一般思路如下：\n初始化 j = -1，表示 pattern 当前已被匹配的最后位。 让 i 遍历文本串 text，对每个 i，执行 3、4来试图匹配 text[i] 和 pattern[j + 1]。 直到 j 回退到 -1 或者是 text[i] == pattern[j + 1]，否则不断令 j = next[j]。 如果 text[i] == pattern[j + 1]，则令 j ++。如果 j 达到 pattern_len - 1，说明 pattern 是 text 的子串。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 省略求 next 数组的步骤 int j = -1; // 表示当前还没有任意一位被匹配 for (int i = 0; i \u0026lt; text_len; i ++) { while (j != -1 \u0026amp;\u0026amp; text[i] != pattern[j + 1]) { j = next[j]; } // text[i] 与 pattern[j + 1] 匹配成功，令 j + 1 if (text[i] == pattern[j + 1]) { j ++; } if (j == pattern_len - 1) // 是子串，按题目要求处理 } 我们观察上面的分析，能否发现：求解 next 数组的过程其实就是模式串 pattern 进行自我匹配的过程。\n考虑如何统计 pattern 在 text 中出现的起始下标： 当 j = m - 1 时表示 pattern 完全匹配，此时可以输出 i - j (text 的结束位置减去 pattern 的长度就是 pattern 在 text 中出现的下标)。但问题在于：之后应该从 pattern 的哪个位置开始进行下一次匹配？ 由于 pattern 在 text 的多次出现可能是重叠的，因此不能什么都不做就让 i 加 1继续进行比较，而是必须先让 j 回退一段距离。此时 next[j] 代表着整个 pattern 的最长相等前后缀，从这个位置开始让 j 最大，即让已经匹配的部分最长，这样能保证既不漏解，又使下一次匹配省去许多无意义的比较。\nwhy O(n+m)?\n我们看到 for 循环中每一个 i 都有一个 while 循环，这样 j 回退的次数可能不可预计，为什么 KMP 的时间复杂度为 O(n+m) 呢？\n首先，在 kmp 整个 for 循环中 i 是不断加 1 的，所以在整个过程中 i 的变化次数是 O(m) 级别，接下来考虑 j 的变化，我们注意到 j 只会在一行中增加，并且每次只加 1，这样在整个过程中 j 最多增加 m 次；而其它情况 j 都是不断减小的，由于 j 最小不会小于 -1，因此在整个过程中，j 最多只能减少 m 次。也就是说 while 循环对整个过程来说最多只会执行 m 次，因此 j 在整个过程中变化次数是 O(m) 级别的。由于 i 和 j 在整个过程中的变化次数都是 O(m)，因此 for 循环部分的整体复杂度就是 O(m)。考虑到计算 next 数组需要 O(n) 的时间复杂度(分析方法与上同)，因此 kmp 算法总共需要 O(n+m) 的时间复杂度。\nKMP字符串 给定一个模式串S，以及一个模板串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。 模板串P在模式串S中多次作为子串出现。 求出模板串P在模式串S中所有出现的位置的起始下标。\n输入格式 第一行输入整数N，表示字符串P的长度。 第二行输入字符串P。 第三行输入整数M，表示字符串S的长度。 第四行输入字符串M。\n输出格式 共一行，输出所有出现位置的起始下标（下标从0开始计数），整数之间用空格隔开。\n数据范围 1 ≤ N ≤ 104\n1 ≤ M ≤105\n输入样例： 3 aba 5 ababa\n输出样例： 0 2\n代码样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; const int M = 1000010; char s[M], p[N]; int n, m; int ne[N]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i ++ ) cin \u0026gt;\u0026gt; p[i]; cin \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i ++ ) cin \u0026gt;\u0026gt; s[i]; ne[0] = -1; for (int i = 1, j = -1; i \u0026lt; n; i ++) { while (j != -1 \u0026amp;\u0026amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++; ne[i] = j; } for (int i = 0, j = -1; i \u0026lt; m; i ++ ) { while (j != -1 \u0026amp;\u0026amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++; if (j == n - 1) { cout \u0026lt;\u0026lt; i - n + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; j = ne[j]; } } return 0; } Trie树 高效地存储和查找字符串集合的数据结构\n例题(Trie字符串统计) 维护一个字符串集合，支持两种操作：\n\u0026ldquo;l x\u0026rdquo; 向集合中插入一个字符串x； “Q x\u0026quot; 询问一个字符串在集合中出现了多少次。 共有N个操作，输入的字符串总长度不超过 105，字符串仅包含小写英文字母。\n输入格式\n第一行包含整数 N，表示操作数。\n接下来 N 行，每行包含一个操作指令，指令为 I x 或 Q x 中的一种。\n输出格式\n对于每个询问指令 Q x ，都要输出一个整数作结果，表示x在集合中出现的次数。\n每个结果占一行。\n数据范围\n1 ≤ N ≤ 2 * 104\n输入样例：\n5\nI abc\nQ abc\nQ ab\nI ab\nQ ab\n输出样例：\n1\n0\n1\n代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int son[N][26], cnt[N], idx; char str[N]; void insert(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++; } int query(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while (n -- ) { char op[2]; scanf(\u0026#34;%s%s\u0026#34;, op, str); if(*op == \u0026#39;I\u0026#39;) insert(str); else printf(\u0026#34;%d\\n\u0026#34;, query(str)); } return 0; } Trie 树心得：\nTire树 本质上一个多叉树，最多可以分多少叉呢？因为此题存的都是小写字母，所以是26叉；\n这里就解释了 son 这个二维数组的第二维的含义，就是他最多有 26 个孩子，那么他是谁呢，他当然是结点了，那结点之间怎么区分，或者这些孩子的爸爸叫啥，爸爸们用下标来区别，所以第一维就是爸爸们的 id，son[0][1] 含义就是 0 号爸爸有个儿子 b ，那 son[0][1] = 2，就是 0 号爸爸有个儿子 b，儿子的 id 是2； 这些 id 就是由 idx 来赋值的；\nidx 可以理解为计划生育的管理局的给上户口的，生一个孩子，给孩子上身份证，证件上ID 为 ++idx ，而孩子叫啥，其实就是 26 个小写字母中的其中一个了；\n对于每个结点而言，可以知道他有没有这个孩子，有的话叫啥，在哪里；\n对于查询，从根节点一路查下来，就可以找到某个字符串在不在；\n对于插入字符串，也是一路下来，看有没有这个儿子，没有了给你生个儿子，有了继续给下面找，所以只插入该字符串中原来不存在的字符即可； 也就是利用了公共前缀来降低查询时间的开销以达到提高效率的目的;\n“Trie这个名字取自“retrieval”，检索，因为Trie可以只用一个前缀便可以在一部字典中找到想要的单词。” 例题(最大异或对) 在给定的 N 个整数 A1，A2……AN 中选出两个进行 xor（异或）运算，得到的结果最大是多少？\n输入格式 第一行输入一个整数 N。\n第二行输入 N 个整数 A1～AN。\n输出格式 输出一个整数表示答案。\n数据范围 1≤ N ≤105, 0 ≤ Ai \u0026lt; 231\n输入样例： 1 2 3 1 2 3 输出样例： 1 3 思路 ![](https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/截屏2025-03-12 13.43.46.png)\n这道题的启示是：字典树不单单可以高效存储和查找字符串集合,还可以存储二进制数字 思路: 将每个数以二进制方式存入字典树,找的时候从最高位去找有无该位的异.\n代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010, M = 3000000; int son[M][2], idx; int n, a[N]; void insert(int x) { int p = 0; for (int i = 30; i \u0026gt;= 0; i -- ) { int \u0026amp;s = son[p][x \u0026gt;\u0026gt; i \u0026amp; 1]; if (!s) s = ++ idx; p = s; } } int query(int x) { int p = 0, res = 0; for (int i = 30; i \u0026gt;= 0; i -- ) { int s = x \u0026gt;\u0026gt; i \u0026amp; 1; if (son[p][!s]) { res += 1 \u0026lt;\u0026lt; i; p = son[p][!s]; } else p = son[p][s]; } return res; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i ++ ) { cin \u0026gt;\u0026gt; a[i]; insert(a[i]); } int res = 0; for (int i = 0; i \u0026lt; n; i ++) res = max(res, query(a[i])); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } 需要注意的点 \u0026amp;的两种使用方法\n注意：\u0026amp; 是取址符号。但 \u0026amp; 也可以有另一个用法，就是是其它变量的别名，如int \u0026amp;a = b；此时 a 就是 b，b 就是 a，改变 a 的值也就改变了 b 的值。但声明时必须初始化，不能空声明，如：int \u0026amp;a 是错的，int \u0026amp;a = b 则可以\n与常规写法对比\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 //初始化trie树(y总)(\u0026amp;引用) void insert(int x) { int p=0; //从最高位开始遍历,并把相应的高位值在trie树中编号 for(int i=30;i\u0026gt;=0;i--) { //先取出高位的值(0或1) int \u0026amp;s=trie[p][x\u0026gt;\u0026gt;i \u0026amp; 1];//让s等价于trie[p][x\u0026gt;\u0026gt;i \u0026amp; 1] //如果s不存在(这个点在trie树中没有编号),就给一个编号 if(!s) s=++idx; //从s的编号开始下一次遍历 p=s; } } //初始化trie树(指针*) void insert(int x) { int p=0; for(int i=30;i\u0026gt;=0;i--) { int *s=\u0026amp;trie[p][x\u0026gt;\u0026gt;i \u0026amp; 1];//指针也可以让两者等价,使用时要加上解引用符* if(!*s) *s=++idx; p=*s; } } //初始化trie树(常规写法,写着稍繁琐一点,优点就是一目了然) void insert(int x) { int p=0; //从最高位开始遍历,并把相应的高位值在trie树中编号 for(int i=30;i\u0026gt;=0;i--) { //先取出高位的值(0或1) int s=trie[p][x\u0026gt;\u0026gt;i \u0026amp; 1]; //如果s不存在(这个点在trie树中没有编号),就给一个编号 if(!s) trie[p][x\u0026gt;\u0026gt;i \u0026amp; 1]=++idx; //从s的编号开始下一次遍历 p=trie[p][x\u0026gt;\u0026gt;i \u0026amp; 1]; } } 为什么是3100000呢？\n因为m数代表二维数组有多少行，即有多少（idx）个节点。每一个数都是以31位的二进制数存进去的（高位为0也会算31位），所以不算重复一个数需要31个节点去存，一共100010个数，所以一共就有3100000个节点（不算重复节点）\n并查集 并查集的作用\n将两个集合合并 询问两个元素是否在一个集合当中 并查集可以用近乎 O(1) 的时间内完成这两个操作\n并查集的基本原理\n每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，P［x］表示x的父节点\n并查集的基本问题\n问题1：如何判断树根：if（p［x］==x）\n问题2：如何求x的集合编号：while （p［x］！= x） × = p [x]\n问题3：如何合并两个集合：px 是x的集合编号，py是y的集合编号。p[x] = y\n例题（合并集合） 一共有n个数，编号是1~n，最开始每个数各自在一个集合中。\n现在要进行m个操作，操作共有两种：\n1.“M a b”，将编号为a和b的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；\n2.“Q a b”，询问编号为a和b的两个数是否在同一个集合中；\n输入格式\n第一行输入整数 n 和 m\n接下来 m 行，每行包含一个操作指令，指令为“M a b\u0026quot;或\u0026quot;Qab”中的一种。\n输出格式\n对于每个询问指令”Q a b”，都要输出一个结果，如果a和b在同一集合内，则输出“Yes”，否则输出“No”。 每个结果占一行。\n数据范围\n1 ≤ n , m ≤ 105\n输入样例：\n4 5\nM 12\nM 3 4\nQ 1 2\nQ 1 3\nQ 3 4\n输出样例：\nYes\nNo\nYes\n代码样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int n, m; int p[N]; int find(int x)//返回x的祖宗结点 + 路径压缩 { if(p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i\u0026lt;= n; i ++ ) p[i] = i; while (m -- ) { char op[2];//scanf有一个缺点：会读入空格和回车，而数组则不会，所以一般使用数组 int a, b; scanf(\u0026#34;%s%d%d\u0026#34;, op, \u0026amp;a, \u0026amp;b); if (op[0] == \u0026#39;M\u0026#39;) p[find(a)] = find(b); else { if (find(a) == find(b)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; } 连通块中点的数量 给定一个包含 n 个点（ 编号为1~n ）的无向图，初始时图中没有边。\n现在要进行 m 个操作，操作共有三种：\n1.\u0026ldquo;C a b”，在点a和点b之间连一条边，a和b可能相等；\n2.“Q1 a b”，询问点a和点b是否在同一个连通块中，a和b可能相等；\n3.\u0026ldquo;Q2 a\u0026rdquo;，询问点a所在连通块中点的数量；\n输入格式\n第一行输入整数n和m。\n接下来m行，每行包含一个操作指令，指令为“Cab”，“Q1 ab”或\u0026quot;Q2a\u0026quot;中的一种。\n输出格式\n对于每个询问指令\u0026quot;Q1 a b”，如果a和b在同一个连通块中，则输出“Yes”，否则输出\u0026quot;No”。\n对于每个询问指令“Q2 a”，输出一个整数表示点a所在连通块中点的数量每个结果占一行。\n数据范围\n1 ≤ n , m ≤ 105\n堆 基本操作 插入一个数 heap[++ size] = x; up(size) 求集合中最小值 heap[1] 删除最小值 heap[1] = heap[size]; size \u0026ndash; ; down(1) 删除任意元素 heap[k] = heap[size]; size \u0026ndash; ; down[k]; up[k] 修改任意元素 heap[k] = x; down[k]; up[k] 堆是一棵完全二叉树\n存储方式 堆使用一个一维数组存储\nx 的左儿子：2x x 的右儿子：2x + 1 注意⚠️：下标从 1 开始，因为 0 的二倍是 0 ，就冲突了\n哈希表 概念：假如有一组数，范围是 -109 到 109，映射到从 0 到 105 中，就是哈希表的基本思想\n哈希函数 哈希函数 h ( x )，输入 x 的值，返回映射后的值，这就是哈希函数\n基本问题\n哈希函数怎么实现？\n直接取模即可\n遇到冲突怎么解决？\ndsds\n和离散化有什么区别？\n其实离散化是一种极其特殊的哈希方式，因为离散化要求是保序的\n实现方法\n拉链法\n顾名思义，拉链法就是开一个一维数组，每一位可以用链表连上多个值，就像拉链一样（一般只有添加，查找两个操作）\n开放寻址法\n只需开一个一维数组，无需链表，数组长度开到题目要求的 2 ～ 3 倍\n注意事项\n哈希表在算法题中一般只有添加，查找两个操作，没有删除操作，即使有，也是开一个 bool 变量来表示删除 数组的长度一般设为质数，并且要离二的整次幂尽可能远，这样冲突的数最少 质数的定义：只能被 1 和本身整除 找指数的方法：可以直接一个一个除，只需要除到平方根就可以了 字符串前缀哈希法 例：\nStr = “Manunitd”\nh[1] = \u0026ldquo;M\u0026rdquo; 的 hash 值\nh[2] = \u0026ldquo;a\u0026rdquo; 的 hash 值\n\u0026hellip; \u0026hellip;\n方法\n把字符串看成一个 P 进制的数 把这个 P 进制的数化为十进制 最后 mod 上一个 Q 这样就可以把一个字符串映射到 0 ～ Q - 1 中\n注意⚠️\n不能映射成 0\nRp 足够好，不存在冲突（不用考虑冲突）\nP = 131 或 13331 时，把 Q 设为 264\n用 unsigned long long 存储，就可以不用 mod 上 Q 了\nh[R] - h[L] * PR - L + 1\n很多用 KMP 很难的题，都可以用字符串哈希（快速判断两个字符串相等）\nKMP 可以求循环节，字符串哈希不可以\n核心思想：使用 P 进制，把字符串看成一段数字\nSTL 1. vector（动态数组） 头文件：#include \u0026lt;vector\u0026gt;\n1 2 3 4 vector\u0026lt;int\u0026gt; v; // 创建空vector vector\u0026lt;int\u0026gt; v(5); // 创建5个0 vector\u0026lt;int\u0026gt; v(5, 1); // 创建5个1 vector\u0026lt;int\u0026gt; v2(v); // 拷贝构造 常用操作：\nv.push_back(x) // 末尾插入 v.pop_back() // 删除末尾元素 v.size() // 元素个数 v.empty() // 判空 v.clear() // 清空 v.front()/v.back() // 首尾元素 v.begin()/v.end() // 迭代器 注意\n系统为某一程序分配空间时，所需时间与空间大小无关，与申请次数有关\n所以，每次长度不够时，就把长度乘以 2\n2. stack（栈） 头文件：#include \u0026lt;stack\u0026gt;\ncpp\n复制\n1 stack\u0026lt;int\u0026gt; s; 操作：\ns.push(x) // 入栈 s.pop() // 出栈（无返回值） s.top() // 栈顶元素 s.size() s.empty() 3. queue（队列） 头文件：#include \u0026lt;queue\u0026gt;\ncpp\n复制\n1 queue\u0026lt;int\u0026gt; q; 操作：\nq.push(x) // 入队 q.pop() // 出队（无返回值） q.front() // 队首元素 q.back() // 队尾元素 q.size() q.empty() 4. priority_queue（优先队列） 1 2 priority_queue\u0026lt;int\u0026gt; pq; // 大根堆 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // 小根堆 操作：\npq.push(x) pq.pop() pq.top() // 堆顶元素 5. string（字符串） 头文件：#include \u0026lt;string\u0026gt;\n1 string s = \u0026#34;abc\u0026#34;; 常用操作：\ns.substr(pos, len) // 取子串 s.find(str) // 查找 s += str // 字符串拼接 s.size()/length() stoi(s) // 字符串转int（C++11） 6. map（有序键值对） 头文件：#include \u0026lt;map\u0026gt;\n1 map\u0026lt;string, int\u0026gt; mp; 操作：\nmp[key] = value // 插入/修改 mp.find(key) // 返回迭代器 mp.count(key) // 是否存在 mp.size() mp.erase(key) 7. set（有序集合） 头文件：#include \u0026lt;set\u0026gt;\n1 set\u0026lt;int\u0026gt; s; 操作：\ns.insert(x) s.erase(x) s.find(x) s.count(x) s.lower_bound(x) // 返回\u0026gt;=x的最小元素迭代器 8. unordered_map/unordered_set 头文件：#include \u0026lt;unordered_map\u0026gt; / #include \u0026lt;unordered_set\u0026gt;\n哈希实现，查询 O(1) 无lower_bound/upper_bound 9. pair（二元组） 头文件：#include \u0026lt;utility\u0026gt;\n1 2 pair\u0026lt;int, string\u0026gt; p = make_pair(1, \u0026#34;a\u0026#34;); auto p = make_pair(1, \u0026#34;a\u0026#34;); // C++11 访问：p.first, p.second\n10. tuple（多元组）C++11 头文件：#include \u0026lt;tuple\u0026gt;\n1 2 tuple\u0026lt;int, string, double\u0026gt; t(1, \u0026#34;a\u0026#34;, 3.14); auto t = make_tuple(1, \u0026#34;a\u0026#34;, 3.14); 访问：get\u0026lt;0\u0026gt;(t), get\u0026lt;1\u0026gt;(t)\n11. bitset（位集） 头文件：#include \u0026lt;bitset\u0026gt;\n1 bitset\u0026lt;8\u0026gt; bs(5); // 00000101 操作：\nbs.count() // 1的个数 bs.test(pos) // 检查某位 bs.set(pos) // 位置1 bs.reset(pos) // 位置0 bs.flip() // 按位取反 搜索与图论 DFS 与 BFS 类型 数据结构 空间 性质 DFS stack O(h) 不具有最短性 BFS queue O(2h) 最短路径 例题(排列数字) 给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。\n现在，请你按照字典序将所有的排列方法输出。\n输入格式 共一行，包含一个整数 n。\n输出格式 按字典序输出所有排列方案，每个方案占一行。\n数据范围 1 ≤ n ≤ 7\n输入样例： 1 3 输出样例： 1 2 3 4 5 6 1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 思路 如何用 dfs 解决全排列问题？\ndfs 最重要的是搜索顺序。用什么顺序遍历所有方案。\n对于全排列问题，以 n = 3 为例，可以这样进行搜索：\n假设有 3 个空位，从前往后填数字，每次填一个位置，填的数字不能和前面一样。\n最开始的时候，三个空位都是空的： __\n首先填写第一个空位，第一个空位可以填 1，填写后为：1\n填好第一个空位，填第二个空位，第二个空位可以填 2，填写后为：1 2 __\n填好第二个空位，填第三个空位，第三个空位可以填 3，填写后为： 1 2 3\n这时候，空位填完，无法继续填数，所以这是一种方案，输出。\n然后往后退一步，退到了状态：1 2 __ 。剩余第三个空位没有填数。第三个空位上除了填过的 3 ，没有其他数字可以填。\n因此再往后退一步，退到了状态：1 。第二个空位上除了填过的 2，还可以填 3。第二个空位上填写 3，填写后为：1 3 __\n填好第二个空位，填第三个空位，第三个空位可以填 2，填写后为： 1 3 2\n这时候，空位填完，无法继续填数，所以这是一种方案，输出。\n然后往后退一步，退到了状态：1 3 __ 。剩余第三个空位没有填数。第三个空位上除了填过的 2，没有其他数字可以填。\n因此再往后退一步，退到了状态：1 。第二个空位上除了填过的 2，3，没有其他数字可以填。\n因此再往后退一步，退到了状态： 。第一个空位上除了填过的 1，还可以填 2。第一个空位上填写 2，填写后为：2 __\n填好第一个空位，填第二个空位，第二个空位可以填 1，填写后为：2 1 __\n填好第二个空位，填第三个空位，第三个空位可以填 3，填写后为：2 1 3\n这时候，空位填完，无法继续填数，所以这是一种方案，输出。\n然后往后退一步，退到了状态：2 1 __ 。剩余第三个空位没有填数。第三个空位上除了填过的 3，没有其他数字可以填。\n因此再往后退一步，退到了状态：2 。第二个空位上除了填过的 1，还可以填 3。第二个空位上填写 3，填写后为：2 3 __\n填好第二个空位，填第三个空位，第三个空位可以填 1，填写后为：2 3 1\n这时候，空位填完，无法继续填数，所以这是一种方案，输出。\n然后往后退一步，退到了状态：2 3 __ 。剩余第三个空位没有填数。第三个空位上除了填过的 1，没有其他数字可以填。\n因此再往后退一步，退到了状态：2 。第二个空位上除了填过的 1，3，没有其他数字可以填。\n因此再往后退一步，退到了状态： 。第一个空位上除了填过的 1，2，还可以填 3。第一个空位上填写 3，填写后为：3 __\n填好第一个空位，填第二个空位，第二个空位可以填 1，填写后为：3 1 __\n填好第二个空位，填第三个空位，第三个空位可以填 2，填写后为：3 1 2\n这时候，空位填完，无法继续填数，所以这是一种方案，输出。\n然后往后退一步，退到了状态：3 1 __ 。剩余第三个空位没有填数。第三个空位上除了填过的 2，没有其他数字可以填。\n因此再往后退一步，退到了状态：3 。第二个空位上除了填过的 1，还可以填 2。第二个空位上填写 2，填写后为：3 2 __\n填好第二个空位，填第三个空位，第三个空位可以填 1，填写后为：3 2 1\n这时候，空位填完，无法继续填数，所以这是一种方案，输出。\n然后往后退一步，退到了状态：3 2 __ 。剩余第三个空位没有填数。第三个空位上除了填过的 1，2，没有其他数字可以填。\n因此再往后退一步，退到了状态：3 。第二个空位上除了填过的 1，2，没有其他数字可以填。\n因此再往后退一步，退到了状态： __。第一个空位上除了填过的 1，2，3，没有其他数字可以填。\n此时深度优先搜索结束，输出了所有的方案。\n算法\n用 path 数组保存排列，当排列的长度为 n 时，是一种方案，输出。 用 state 数组表示数字是否用过。当 state [ i ] 为 1 时：i 已经被用过，state [ i ] 为 0 时，i 没有被用过。 dfs ( i ) 表示的含义是：在 path [ i ] 处填写数字，然后递归的在下一个位置填写数字。 回溯：第 i 个位置填写某个数字的所有情况都遍历后， 第 i 个位置填写下一个数字。 代码示例(位运算方式) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 10; int n; int path[N]; void dfs(int u, int state) { if (u == n) { for (int i = 0; i \u0026lt; n; i ++ ) printf(\u0026#34;%d \u0026#34;, path[i]); puts(\u0026#34;\u0026#34;); return; } for (int i = 0; i \u0026lt; n; i ++ ) if (!(state \u0026gt;\u0026gt; i \u0026amp; 1)) { path[u] = i + 1; dfs(u + 1, state + (1 \u0026lt;\u0026lt; i)); } } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); dfs(0, 0); return 0; } 关键解释\n状态压缩 (state): • state 是一个整数，其二进制每一位表示对应数字是否被使用。\n• 例如，state = 5（二进制 101）表示数字1和3已被使用。\n位运算操作: • state \u0026raquo; i \u0026amp; 1: 右移 i 位后与1按位与，检查第 i 位是否为1。\n• 若结果为 0，表示数字 i +1未被使用。\n• state + ( 1 \u0026laquo; i ): 将第 i 位设为1，标记数字 i +1为已使用。\n递归逻辑: • 每一层递归生成排列的一个位置（u 从 0 到 n - 1）。\n• 遍历所有数字（1到 n ），通过位运算剪枝已使用的数字。\n• 递归到下一层时，传递更新后的state状态。\n注意⚠️： 因为 state 是按值传递的，所以 state 自动回复到之前的状态，体现了回溯的特点。\n代码示例(无位运算方式) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 10; int n; int path[N]; bool str[N]; void dfs(int u) { if (u == n) { for (int i = 0; i \u0026lt; n; i ++ ) cout \u0026lt;\u0026lt; path[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return ; } for (int i = 1; i \u0026lt;= n; i ++) { if (!str[i]) { path[u] = i; str[i] = true; dfs(u + 1); str[i] = false; } } } int main() { cin \u0026gt;\u0026gt; n; dfs(0); return 0; } 核心逻辑：\n终止条件：当u == n时，说明已经生成了一个完整的排列，输出path数组。\n遍历数字：从1到n，依次尝试每个数字。\n剪枝：通过str[i]判断数字i是否已被使用，避免重复。\n递归与回溯：\n递归前：将数字i加入路径，并标记为已使用。 递归后：撤销对i的标记（回溯），以便其他分支可以复用该数字。 例题(n - 皇后问题) n−皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。\n现在给定整数 n，请你输出所有的满足条件的棋子摆法。\n输入格式 共一行，包含整数 n。\n输出格式 每个解决方案占 n 行，每行输出一个长度为 n 的字符串，用来表示完整的棋盘状态。\n其中 . 表示某一个位置的方格状态为空，Q 表示某一个位置的方格上摆着皇后。\n每个方案输出完成后，输出一个空行。\n注意：行末不能有多余空格。\n输出方案的顺序任意，只要不重复且没有遗漏即可。\n数据范围 1≤n≤9\n输入样例： 1 4 输出样例： 1 2 3 4 5 6 7 8 9 .Q.. ...Q Q... ..Q. ..Q. Q... ...Q .Q.. 思路(全排列方法) 深度优先遍历dfs。\n每一行必定有一个皇后，对行进行深度遍历。\n对于第 r 行的第 i 个位置，判断每个点是否可以放皇后，如果可以，则放皇后，然后处理 r + 1 行。\n直到 r = n，程序指行完毕。\n核心思路：深度优先遍历\n函数名：void dfs ( int r ): 深度优先遍历函数。参数 u：从第 u 行开始放棋子，处理第 u 行。\n递归结束判定：见代码，当 r == n的时候，说明应该处理第 n 行了，也代表第 0 ~ n - 1 行放好棋子，也就是整个棋盘放好了棋子，也就是得到了一种解，也就是递归结束。\n第 r 行，第 i 列能不能放棋子：用数组 dg udg col 分别表示：点对应的两个斜线以及列上是否有皇后。 dg[i + r] 表示 r 行 i 列处，所在的对角线上有没有棋子，udg[n - i + r] 表示 r 行 i 列处，所在的反对角线上有没有棋子，cor[i] 表示第 i 列上有没有棋子。如果 r 行 i 列的对角线，反对角线上都没有棋子，即 !cor[i] \u0026amp;\u0026amp; !dg[i + r] \u0026amp;\u0026amp; !udg[n - i + r]为真，则代表 r 行 i 列处可以放棋子。\n代码示例(全排列方式) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 20; char q[N][N]; int n; bool col[N], dg[N * 2], udg[N * 2]; void dfs(int u) { if (u == n) { for (int i = 0; i \u0026lt; n; i ++ ) { for (int j = 0; j \u0026lt; n; j ++) cout \u0026lt;\u0026lt; q[i][j]; cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; return; } for (int i = 0; i \u0026lt; n; i ++ ) { if (!col[i] \u0026amp;\u0026amp; !dg[u + i] \u0026amp;\u0026amp; !udg[n - u + i]) { q[u][i] = \u0026#39;Q\u0026#39;; col[i] = dg[u + i] = udg[n - u + i] = true; dfs(u + 1); col[i] = dg[u + i] = udg[n - u + i] = false; q[u][i] = \u0026#39;.\u0026#39;; } } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i ++ ) for (int j = 0; j \u0026lt; n; j ++) q[i][j] = \u0026#39;.\u0026#39;; dfs(0); return 0; } 代码示例(第二种方法) 更原始的一种方法，因为第一种方法是已经分析出每一行只能放一个皇后，在这样的基础下进行的，而下面这种方法是一种更原始的方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 10; int n; bool row[N], col[N], dg[N * 2], udg[N * 2]; char g[N][N]; void dfs(int x, int y, int s) { if (s \u0026gt; n) return; if (y == n) y = 0, x ++ ; if (x == n) { if (s == n) { for (int i = 0; i \u0026lt; n; i ++ ) puts(g[i]); puts(\u0026#34;\u0026#34;); } return; } g[x][y] = \u0026#39;.\u0026#39;; dfs(x, y + 1, s); if (!row[x] \u0026amp;\u0026amp; !col[y] \u0026amp;\u0026amp; !dg[x + y] \u0026amp;\u0026amp; !udg[x - y + n]) { row[x] = col[y] = dg[x + y] = udg[x - y + n] = true; g[x][y] = \u0026#39;Q\u0026#39;; dfs(x, y + 1, s + 1); g[x][y] = \u0026#39;.\u0026#39;; row[x] = col[y] = dg[x + y] = udg[x - y + n] = false; } } int main() { cin \u0026gt;\u0026gt; n; dfs(0, 0, 0); return 0; } 例题(走迷宫) 给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。\n最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。\n请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。\n数据保证 (1,1) 处和 (n,m) 处的数字为 0，且一定至少存在一条通路。\n输入格式 第一行包含两个整数 n 和 m。\n接下来 n 行，每行包含 m 个整数（0 或 1），表示完整的二维数组迷宫。\n输出格式 输出一个整数，表示从左上角移动至右下角的最少移动次数。\n数据范围 1 ≤ n, m ≤ 100\n输入样例： 1 2 3 4 5 6 5 5 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0 输出样例： 1 8 思路 思路：从起点开始，往前走第一步，记录下所有第一步能走到的点，然后从所第一步能走到的点开始，往前走第二步，记录下所有第二步能走到的点，重复下去，直到走到终点。输出步数即可。\n这就是广度优先遍历的思路。\n实现方式：广度优先遍历\n用 g 存储地图，f存储起点到其他各个点的距离。 从起点开始广度优先遍历地图。 当地图遍历完，就求出了起点到各个点的距离，输出f [n] [m]即可。 void bfs (int a, int b): 广度优遍历函数。输入的是起点坐标。 queue\u0026lt;PII\u0026gt; q;:用来存储每一步走到的点。 while(!q.empty())循环：循环依次取出同一步数能走到的点，再往前走一步。 int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0}; :一个点往下一步走得时候，可以往上下左右四方向走。 代码示例(使用库函数队列) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 110; int n, m; int g[N][N], d[N][N]; int bfs() { queue\u0026lt;PII\u0026gt; q; memset(d, -1, sizeof d); d[0][0] = 0; q.push({0, 0}); int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; while (q.size()) { auto t = q.front(); q.pop(); for (int i = 0; i \u0026lt; 4; i ++ ) { int x = t.first + dx[i], y = t.second + dy[i]; if (x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; n \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; m \u0026amp;\u0026amp; g[x][y] == 0 \u0026amp;\u0026amp; d[x][y] == -1) { d[x][y] = d[t.first][t.second] + 1; q.push({x, y}); } } } return d[n - 1][m - 1]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i ++ ) for (int j = 0; j \u0026lt; m; j ++ ) cin \u0026gt;\u0026gt; g[i][j]; cout \u0026lt;\u0026lt; bfs() \u0026lt;\u0026lt; endl; return 0; } 代码示例(自己模拟队列) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 110; typedef pair\u0026lt;int, int\u0026gt; PII; int n, m; int g[N][N]; int d[N][N]; PII q[N * N]; int bfs() { int hh = 0, tt = 0; q[0] = {0, 0}; memset(d, -1, sizeof d ); d[0][0] = 0; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; while (hh \u0026lt;= tt) { auto t = q[hh ++]; for (int i = 0; i \u0026lt; 4; i ++ ) { int x = t.first + dx[i], y = t.second + dy[i]; if (x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; n \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; m \u0026amp;\u0026amp; g[x][y] == 0 \u0026amp;\u0026amp; d[x][y] == -1) { d[x][y] = d[t.first][t.second] + 1; q[++ tt] = {x, y}; } } } return d[n - 1][m - 1]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i ++ ) for (int j = 0; j \u0026lt; m; j ++ ) cin \u0026gt;\u0026gt; g[i][j]; cout \u0026lt;\u0026lt; bfs() \u0026lt;\u0026lt; endl; return 0; } 例题(八数码) 在一个 3×3 的网格中，1∼8 这 8 个数字和一个 x 恰好不重不漏地分布在这 3×3 的网格中。\n例如：\n1 2 3 1 2 3 x 4 6 7 5 8 在游戏过程中，可以把 x 与其上、下、左、右四个方向之一的数字交换（如果存在）。\n我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：\n1 2 3 1 2 3 4 5 6 7 8 x 例如，示例中图形就可以通过让 x 先后与右、下、右三个方向的数字交换成功得到正确排列。\n交换过程如下：\n1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 x 4 6 4 x 6 4 5 6 4 5 6 7 5 8 7 5 8 7 x 8 7 8 x 现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。\n输入格式 输入占一行，将 3×3 的初始网格描绘出来。\n例如，如果初始网格如下所示：\n1 2 3 1 2 3 x 4 6 7 5 8 则输入为：1 2 3 x 4 6 7 5 8\n输出格式 输出占一行，包含一个整数，表示最少交换次数。\n如果不存在解决方案，则输出 −1。\n输入样例： 1 2 3 4 1 5 x 7 6 8 输出样例 1 19 算法思路 用一个队列保存当前获得的序列 用一个哈希表保存各个序列与对应额交换次数。 从队列中取出队头这个序列，计算出这个序列通过交换能得到的序列。如果能到得的序列是个新序列（哈希表中没有这个序列），就把这个新序列放入队尾，哈希表中记录新序列对应的交换次数。 如果在上述过程中得到了结果序列，则输出交换次数，结束。 如果最终没有得到结果序列。输出-1。 代码示例 树与图的存储 因为树是一种无环连通图，所以只需要知道图如何存储就可以了 树与图的深度优先遍历 给定一颗树，树中包含 n 个结点（编号 1∼n）和 n−1 条无向边。\n请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。\n重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。\n输入格式 第一行包含整数 n，表示树的结点数。\n接下来 n−1 行，每行包含两个整数 a 和 b，表示点 a 和点 b 之间存在一条边。\n输出格式 输出一个整数 m，表示将重心删除后，剩余各个连通块中点数的最大值。\n数据范围 1≤n≤105\n输入样例 1 2 3 4 5 6 7 8 9 9 1 2 1 7 1 4 2 8 2 5 4 3 3 9 4 6 输出样例： 1 4 树与图的宽度优先遍历 拓扑排序 只有有向图是有拓扑序列的，无向图没有 什么是拓扑排序?\n一个有向图，如果图中有入度为 0 的点，就把这个点删掉，同时也删掉这个点所连的边。\n一直进行上面出处理，如果所有点都能被删掉，则这个图可以进行拓扑排序。\n举例子\n开始时，图是这样的状态，发现A的入度为 0，所以删除A和A上所连的边，结果如下图：\n这时发现 B 的入度为 0，C 的入度为 0，所以删除 B 和 B 上所连的边、C 和 C上所连的边，结果如下图：\n这时发现发现D的入度为 0，所以删除D和D上所连的边(如果有就删)，结果如下图：\n这时整个图被删除干净，所有能进行拓扑排序。\n解题思路\n首先记录各个点的入度\n然后将入度为 0 的点放入队列\n将队列里的点依次出队列，然后找出所有出队列这个点发出的边，删除边，同事边的另一侧的点的入度 -1。\n如果所有点都进过队列，则可以拓扑排序，输出所有顶点。否则输出 -1，代表不可以进行拓扑排序。\n有向图的拓扑序列 给定一个 n 个点 m 条边的有向图，点的编号是 1 到 n，图中可能存在重边和自环。\n请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 −1。\n若一个由图中所有点构成的序列 A 满足：对于图中的每条边 (x,y)，x 在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。\n输入格式 第一行包含两个整数 n 和 m。\n接下来 m 行，每行包含两个整数 x 和 y，表示存在一条从点 x 到点 y 的有向边 (x,y)。\n输出格式 共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。\n否则输出 −1。\n数据范围 1≤n,m≤105\n输入样例： 1 2 3 4 3 3 1 2 2 3 1 3 输出样例： 1 1 2 3 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 100010; int n, m; int h[N], e[N], ne[N], idx; int q[N], d[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++; } int topsort() { int hh = 0, tt = -1; for (int i = 1; i \u0026lt;= n; i ++) { if (d[i] == 0) q[++ tt] = i; } while(hh \u0026lt;= tt) { int t = q[hh ++]; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; d[j] --; if (d[j] == 0) q[++ tt] = j; } } return tt == n - 1; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(h, -1, sizeof h); for (int i = 1; i \u0026lt;= m; i ++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; add(a, b); d[b] ++; } if (topsort()) { for (int i = 0; i \u0026lt; n; i ++ ) cout \u0026lt;\u0026lt; q[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } else cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 最短路径问题 算法分类\n![](https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/截屏2025-03-14 12.00.52.png)\n注意：\n只需要考虑有向图就可以，因为无向图是一种特殊的有向图，只需存两条边即可 稠密图用邻接矩阵存，稀疏图用邻接表存 朴素 Dijkstra 算法 给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为正值。\n请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。\n输入格式 第一行包含整数 n 和 m。\n接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。\n输出格式 输出一个整数，表示 1 号点到 n 号点的最短距离。\n如果路径不存在，则输出 −1。\n数据范围 1 ≤ n ≤ 500, 1 ≤ m ≤ 105, 图中涉及边长均不超过10000。\n输入样例： 1 2 3 4 3 3 1 2 2 2 3 1 1 3 4 输出样例： 1 3 算法思路 迪杰斯特拉算法采用的是一种贪心的策略。\n求源点到其余各点的最短距离步骤如下：\n用一个 dist 数组保存源点到其余各个节点的距离，dist[i] 表示源点到节点 i 的距离。初始时，dist 数组的各个元素为无穷大。 用一个状态数组 state 记录是否找到了源点到该节点的最短距离，state[i] 如果为真，则表示找到了源点到节点 i 的最短距离，state[i] 如果为假，则表示源点到节点 i 的最短距离还没有找到。初始时，state 各个元素为假。\n源点到源点的距离为 0。即dist[1] = 0。\n遍历 dist 数组，找到一个节点，这个节点是：没有确定最短路径的节点中距离源点最近的点。假设该节点编号为 i。此时就找到了源点到该节点的最短距离，state[i] 置为 1。\n遍历 i 所有可以到达的节点 j，如果 dist[j] 大于 dist[i] 加上 i -\u0026gt; j 的距离，即 dist[j] \u0026gt; dist[i] + w[i][j]（w[i][j] 为 i -\u0026gt; j 的距离） ，则更新 dist[j] = dist[i] + w [i] [j]。\n重复 3 4 步骤，直到所有节点的状态都被置为 1。\n此时 dist 数组中，就保存了源点到其余各个节点的最短距离。\n伪代码\n1 2 3 4 5 6 7 8 int dist[n],state[n]; dist[1] = 0, state[1] = 1; for(i:1 ~ n) { t \u0026lt;- 没有确定最短路径的节点中距离源点最近的点; state[t] = 1; 更新 dist; } 代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include\u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 510, M = 100010; int h[N], e[M], ne[M], w[M], idx;//邻接表存储图 int state[N];//state 记录是否找到了源点到该节点的最短距离 int dist[N];//dist 数组保存源点到其余各个节点的距离 int n, m;//图的节点个数和边数 void add(int a, int b, int c)//插入边 { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } void Dijkstra() { memset(dist, 0x3f, sizeof(dist));//dist 数组的各个元素为无穷大 dist[1] = 0;//源点到源点的距离为置为 0 for (int i = 0; i \u0026lt; n; i++) { int t = -1; for (int j = 1; j \u0026lt;= n; j++)//遍历 dist 数组，找到没有确定最短路径的节点中距离源点最近的点t { if (!state[j] \u0026amp;\u0026amp; (t == -1 || dist[j] \u0026lt; dist[t])) t = j; } state[t] = 1;//state[i] 置为 1。 for (int j = h[t]; j != -1; j = ne[j])//遍历 t 所有可以到达的节点 i { int i = e[j]; dist[i] = min(dist[i], dist[t] + w[j]);//更新 dist[j] } } } int main() { memset(h, -1, sizeof(h));//邻接表初始化 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; while (m--)//读入 m 条边 { int a, b, w; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; w; add(a, b, w); } Dijkstra(); if (dist[n] != 0x3f3f3f3f)//如果dist[n]被更新了，则存在路径 cout \u0026lt;\u0026lt; dist[n]; else cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34;; } 优化\n看一下算法的时间复杂度：\n1 2 3 4 5 6 for(i:1 ~ n)//n次 { t \u0026lt;- 没有确定最短路径的节点中距离源点最近的点;//每次遍一遍历dist数组，n次的复杂度是O(n^2) state[t] = 1; 更新 dist;//每次遍历一个节点的出边，n次遍历了所有节点的边，复杂度为O(e) } 算法的主要耗时的步骤是从dist 数组中选出：没有确定最短路径的节点中距离源点最近的点 t。只是找个最小值而已，没有必要每次遍历一遍dist数组。\n在一组数中每次能很快的找到最小值，很容易想到使用小根堆。可以使用库中的小根堆（推荐）或者自己编写。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt;//堆的头文件 using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII;//堆里存储距离和节点编号 const int N = 1e6 + 10; int n, m;//节点数量和边数 int h[N], w[N], e[N], ne[N], idx;//邻接表存储图 int dist[N];//存储距离 bool st[N];//存储状态 void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } int dijkstra() { memset(dist, 0x3f, sizeof dist);//距离初始化为无穷大 dist[1] = 0; priority_queue\u0026lt;PII, vector\u0026lt;PII\u0026gt;, greater\u0026lt;PII\u0026gt;\u0026gt; heap;//小根堆 heap.push({0, 1});//插入距离和节点编号 while (heap.size()) { auto t = heap.top();//取距离源点最近的点 heap.pop(); int ver = t.second, distance = t.first;//ver:节点编号，distance:源点距离ver 的距离 if (st[ver]) continue;//如果距离已经确定，则跳过该点 st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i])//更新ver所指向的节点距离 { int j = e[i]; if (dist[j] \u0026gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j});//距离变小，则入堆 } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); memset(h, -1, sizeof h); while (m -- ) { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); add(a, b, c); } cout \u0026lt;\u0026lt; dijkstra() \u0026lt;\u0026lt; endl; return 0; } 使用小根堆后，找到 t 的耗时从 O(n^2) 将为了 O(1)。每次更新 dist 后，需要向堆中插入更新的信息。所以更新dist的时间复杂度有 O(e) 变为了 O(elogn)。总时间复杂度有 O(n^2) 变为了 O(n + elongn)。适用于稀疏图。\n总结\n迪杰斯特拉算法适用于求正权有向图中，源点到其余各个节点的最短路径。注意：图中可以有环，但不能有负权边。\n例如：如下图就不能使用迪杰斯特拉算法求节点 1 到其余各个节点的最短距离。\n代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 510; int n, m; int dist[N]; int g[N][N]; bool st[N]; int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i \u0026lt; n; i ++ ) { int t = -1; for (int j = 1; j \u0026lt;= n; j ++ ) { if (!st[j] \u0026amp;\u0026amp; (t == -1 || dist[t] \u0026gt; dist[j])) t = j; } st[t] = true; for (int j = 1; j \u0026lt;= n; j ++ ) dist[j] = min(dist[j], dist[t] + g[t][j]); } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(g, 0x3f, sizeof g); while(m --) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; g[a][b] = min(g[a][b], c); } cout \u0026lt;\u0026lt; dijkstra() \u0026lt;\u0026lt; endl; return 0; } 为什么前面初始化的是3f，后面变成检查3f3f33f3f了？\nmemset 是按字节更改内存，memset(a, 0x3f, sizeof a): a 的每一个字节都是 0x3f, int 取4个字节，所以是 0x3f3f3f3f，他的值是0x3f3f3f3f\nbellman_ford算法 给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。\n请你求出从 1 号点到 n 号点的最多经过 k 条边的最短距离，如果无法从 1 号点走到 n 号点，输出 impossible。\n注意：图中可能 存在负权回路 。\n输入格式 第一行包含三个整数 n, m, k。\n接下来 m 行，每行包含三个整数 x, y, z，表示存在一条从点 x 到点 y 的有向边，边长为 z。\n点的编号为 1∼n。\n输出格式 输出一个整数，表示从 1 号点到 n 号点的最多经过 k 条边的最短距离。\n如果不存在满足条件的路径，则输出 impossible。\n数据范围 1 ≤ n, k ≤ 500, 1 ≤ m ≤ 10000, 1 ≤ x, y ≤ n， 任意边长的绝对值不超过 10000。\n输入样例： 1 2 3 4 3 3 1 1 2 1 2 3 1 1 3 3 输出样例： 1 3 算法思路 所用的数据结构\ndist [N] 表示从起点到当前点的当前最短距离\nbackup [ j ] 表示每次进入第 2 重循环的 dist 数组的备份\n算法步骤\n0.初始化 dist 数组为正无穷，dist [1] = 0;\n1.（外重循环）循环 i 从 1 到 n，遍历 n 次指的是：是不经过 i 条边到达终点的最短距离\n经过 n 次操作 n 个点的最短距离也就确定了；\n2.（内重循环）循环 j 从 1 到 m，遍历 m 条边，把所有边都进行松弛操作；\n每次取出两点以及他们连接的边的权重（a, b, w 表示 a—\u0026gt;b 的一条边）；\n用从起点到 a 的当前最短距离 + 权重来更新从起点到 b 的当前最短距离； dist [b] = min (dist [b], dist [a] + w);\n3.返回答案；\n为什么跑完算法就能算出最短距离呢\n因为第二重循环遍历了m条边，每条都被遍历了n次；\n所以这n个点的所有他的前驱后继相对应的边权一定都被遍历到了\n又因为他是有松弛操作的，所以只要上一个点（前驱）的当前最短路求出来了\n这个点就可以用他的前驱来更新他的最短距离，从而他的后继又可以用它来更新最短距离了\nbackup干啥使的\nbackup[j] 表示每次进入第2重循环的 dist 数组的备份。 如果不加这个备份的话有可能会发生节点最短距离的串连； 比如说：\n现在从 3 号结点走到 4 号节点要想进行松弛操作就必须先得到 dist[3]，要想得到 dist[3] 就得知道 dist[2]； dist[2] = 2，现在 dist[3] 是正无穷，用 2 号结点来更新 3 号结点，dist[3]=2+3=5;\n现在要更新dist[4]了，此时dist[4]=正无穷\n出现问题了，dist[4]是用dist[3]是用正无穷来更新还是5呢\n用dist[3]=5来更新那是下一次i迭代的事情； 这道题说是不经过k条边，说不定下一次就到k条边了，所以还是得用正无穷来更新的\n第3步的细节\n怎么返回呢还是这样吗？\n1 2 if(dist[n]==0x3f3f3f3f)return -1; else return dist[n]; 为什么是dist[n]\u0026gt;0x3f3f3f3f/2， 而不是dist[n]\u0026gt;0x3f3f3f3f\n5号节点距离起点的距离是无穷大，利用5号节点更新n号节点距离起点的距离，将得到109−2, 虽然小于109, 但并不存在最短路，(在边数限制在k条的条件下)。\n所以就直接这样写\n1 2 if(dist[n]\u0026gt;=0x3f3f3f3f/2)return -1; else return dist[n]; 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 510, M = 10010; int n, m, k; int dict[N]; int backup[N]; struct edge{ int a; int b; int w; }Edge[M]; int bellman_ford() { memset(dict, 0x3f, sizeof dict); dict[1] = 0; for (int i = 0; i \u0026lt; k; i ++ ) { memcpy(backup, dict, sizeof dict); for (int j = 0; j \u0026lt; m; j ++ ) { int a = Edge[j].a, b = Edge[j].b, w = Edge[j].w; dict[b] = min(dict[b], backup[a] + w); } } return dict[n]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 0; i \u0026lt; m; i ++ ) { int a, b, w; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; w; Edge[i].a = a, Edge[i].b = b, Edge[i].w = w; } int t = bellman_ford(); if (t \u0026gt; 0x3f3f3f3f / 2) cout \u0026lt;\u0026lt; \u0026#34;impossible\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; return 0; } spfa算法 给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。\n请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 impossible。\n数据保证不存在负权回路。\n输入格式 第一行包含整数 n 和 m。\n接下来 m 行每行包含三个整数 x, y, z，表示存在一条从点 x 到点 y 的有向边，边长为 z。\n输出格式 输出一个整数，表示 1 号点到 n 号点的最短距离。\n如果路径不存在，则输出 impossible。\n数据范围 1 ≤ n, m ≤105, 图中涉及边长绝对值均不超过 10000。\n输入样例： 1 2 3 4 3 3 1 2 5 2 3 -3 1 3 4 输出样例： 1 2 算法思想 明确一下松弛的概念\n考虑节点 u 以及它的邻居 v，从起点跑到 v 有好多跑法，有的跑法经过 u，有的不经过。 经过 u 的跑法的距离就是 distu + u 到 v 的距离。 所谓松弛操作，就是看一看 distv 和 distu + u 到 v 的距离哪个大一点 如果前者大一点，就说明当前的不是最短路，就要赋值为后者，这就叫做松弛。 spfa算法文字说明：\n建立一个队列，初始时队列里只有起始点。 再建立一个数组记录起始点到所有点的最短路径（该表格的初始值要赋为极大值，该点到他本身的路径赋为0）。 再建立一个数组，标记点是否在队列中。 队头不断出队，计算始点起点经过队头到其他点的距离是否变短，如果变短且被点不在队列中，则把该点加入到队尾。 重复执行直到队列为空。 在保存最短路径的数组中，就得到了最短路径。 spfa 图解：\n给定一个有向图，如下，求A~E的最短路。\n源点A首先入队，然后A出队，计算出到BC的距离会变短，更新距离数组，BC没在队列中，BC入队\nB出队，计算出到D的距离变短，更新距离数组，D没在队列中，D入队。然后C出队，无点可更新。\nD出队，计算出到E的距离变短，更新距离数组，E没在队列中，E入队。\nE出队，此时队列为空，源点到所有点的最短路已被找到，A-\u0026gt;E的最短路即为8\n代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 100010; int n, m; int dist[N]; bool st[N]; int h[N], e[N], w[N], ne[N], idx; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++; } int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue\u0026lt;int\u0026gt; q; q.push(1); st[1] = true; while(q.size()) { int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) { q.push(j); st[j] = true; } } } } return dist[n]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(h, -1, sizeof h); while(m --) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; add(a, b, c); } int t = spfa(); if (t == 0x3f3f3f3f) cout \u0026lt;\u0026lt; \u0026#34;impossible\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; return 0; } spfa算法判断负环 给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。\n请你判断图中是否存在负权回路。\n输入格式 第一行包含整数 n 和 m。\n接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。\n输出格式 如果图中存在负权回路，则输出 Yes，否则输出 No。\n数据范围 1 ≤ n ≤ 2000, 1 ≤ m ≤ 10000, 图中涉及边长绝对值均不超过 10000。\n输入样例： 1 2 3 4 3 3 1 2 -1 2 3 4 3 1 -4 输出样例： 1 Yes 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int N = 2010, M = 10010; int n, m; int h[N], w[M], e[M], ne[M], idx; int dist[N], cnt[N]; bool st[N]; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } bool spfa() { queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n; i ++ ) { st[i] = true; q.push(i); } while (q.size()) { int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if (cnt[j] \u0026gt;= n) return true; if (!st[j]) { q.push(j); st[j] = true; } } } } return false; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); memset(h, -1, sizeof h); while (m -- ) { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); add(a, b, c); } if (spfa()) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); return 0; } Floyd 算法 多源汇最短路问题-具有多个源点\n快速复习 Dijkstra-朴素O(n^2)\n初始化距离数组, dist[1] = 0, dist[i] = inf; for n次循环 每次循环确定一个min加入S集合中，n次之后就得出所有的最短距离 将不在S中dist_min的点-\u0026gt;t t-\u0026gt;S加入最短路集合 用t更新到其他点的距离 Dijkstra-堆优化O(mlogm)\n利用邻接表，优先队列 在priority_queue[HTML_REMOVED], greater[HTML_REMOVED] \u0026gt; heap;中将返回堆顶 利用堆顶来更新其他点，并加入堆中类似宽搜 Bellman_fordO(nm)\n注意连锁想象需要备份, struct Edge{inta,b,c} Edge[M]; 初始化dist, 松弛dist[x.b] = min(dist[x.b], backup[x.a]+x.w); 松弛k次，每次访问m条边 Spfa O(n)~O(nm)\n利用队列优化仅加入修改过的地方 for k次 for 所有边利用宽搜模型去优化bellman_ford算法 更新队列中当前点的所有出边 Floyd O(n^3)\n初始化d k, i, j 去更新d 最小生成树 ![](https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/截屏2025-03-16 18.08.40.png)\nPrim 算法 给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环，边权可能为负数。\n求最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。\n给定一张边带权的无向图 G=(V,E)，其中 V 表示图中点的集合，E 表示图中边的集合，n=|V|，m=|E|。\n由 V 中的全部 n 个顶点和 E 中 n−1 条边构成的无向连通子图被称为 G 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 G 的最小生成树。\n输入格式 第一行包含两个整数 n 和 m。\n接下来 m 行，每行包含三个整数 u,v,w，表示点 u 和点 v 之间存在一条权值为 w 的边。\n输出格式 共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。\n数据范围 1 ≤ n ≤ 500, 1 ≤ m ≤ 105, 图中涉及边的边权的绝对值均不超过 10000。\n输入样例： 1 2 3 4 5 6 4 5 1 2 1 1 3 2 1 4 3 2 3 2 3 4 4 输出样例： 1 6 算法思想 prim 算法干的事情是：给定一个无向图，在图中选择若干条边把图的所有节点连起来。要求边长之和最小。在图论中，叫做求最小生成树。\nprim 算法采用的是一种贪心的策略。\n每次将离连通部分的最近的点和点对应的边加入的连通部分，连通部分逐渐扩大，最后将整个图连通起来，并且边长之和最小。\n我们将图中各个节点用数字 1 ~ n 编号。\n要将所有景点连通起来，并且边长之和最小，步骤如下：\n用一个 state 数组表示节点是否已经连通。state[i] 为真，表示已经连通，state[i] 为假，表示还没有连通。初始时，state 各个元素为假。即所有点还没有连通。 用一个 dist 数组保存各个点到连通部分的最短距离，dist[i] 表示 i 节点到连通部分的最短距离。初始时，dist 数组的各个元素为无穷大。 用一个 pre 数组保存节点的是和谁连通的。pre[i] = k 表示节点 i 和节点 k 之间需要有一条边。初始时，pre 的各个元素置为 -1。\n从 1 号节点开始扩充连通的部分，所以 1 号节点与连通部分的最短距离为 0，即disti[1] 置为 0。\n遍历 dist 数组，找到一个还没有连通起来，但是距离连通部分最近的点，假设该节点的编号是 i。i节点就是下一个应该加入连通部分的节点，stata[i] 置为 1。 用青色点表示还没有连通起来的点，红色点表示连通起来的点。 这里青色点中距离最小的是 dist[1]，因此 state[1] 置为 1。\n遍历所有与 i 相连但没有加入到连通部分的点 j，如果 j 距离连通部分的距离大于 i j 之间的距离，即 dist[j] \u0026gt; w[i][j]（w[i][j] 为 i j 节点之间的距离），则更新 dist[j] 为 w[i][j]。这时候表示，j 到连通部分的最短方式是和 i 相连，因此，更新pre[j] = i。 与节点 1 相连的有 2， 3， 4 号节点。1-\u0026gt;2 的距离为 100，小于 dist[2]，dist[2] 更新为 100，pre[2] 更新为1。1-\u0026gt;4 的距离为 140，小于 dist[4]，dist[4] 更新为 140，pre[2] 更新为1。1-\u0026gt;3 的距离为 150，小于 dist[3]，dist[3] 更新为 150，pre[3] 更新为1。\n重复 3 4步骤，直到所有节点的状态都被置为 1. 这里青色点中距离最小的是 dist[2]，因此 state[2] 置为 1。\n与节点 2 相连的有 5， 4号节点。2-\u0026gt;5 的距离为 80，小于 dist[5]，dist[5] 更新为 80，pre[5] 更新为 2。2-\u0026gt;4 的距离为 80，小于 dist[4]，dist[4] 更新为 80，pre[4] 更新为2。\n选dist[4]，更新dist[3]，dist[5]，pre[3]，pre[5]。\n选dist[5]，没有可更新的。\n选dist[5]，没有可更新的。\n选dist[3]，没有可更新的。\n此时 dist 数组中保存了各个节点需要修的路长，加起来就是。pre 数组中保存了需要选择的边。\n代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 510, INF = 0x3f3f3f3f; int n, m; int g[N][N]; int dist[N]; bool st[N]; int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i \u0026lt; n; i ++ ) { int t = -1; for (int j = 1; j \u0026lt;= n; j ++ ) { if (!st[j] \u0026amp;\u0026amp; (t == -1 || dist[t] \u0026gt; dist[j])) t = j; } if (i \u0026amp;\u0026amp; dist[t] == INF) return INF; if (i) res += dist[t]; st[t] = true; for (int j = 1; j \u0026lt;= n; j ++ ) { dist[j] = min(dist[j], g[t][j]); } } return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(g, 0x3f, sizeof g); while(m --) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; g[a][b] = g[b][a] = min(g[a][b], c); } int t = prim(); if (t == INF) cout \u0026lt;\u0026lt; \u0026#34;impossible\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; return 0; } kruskal 算法 给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环，边权可能为负数。\n求最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。\n给定一张边带权的无向图 G=(V,E)，其中 V 表示图中点的集合，E 表示图中边的集合，n=|V|，m=|E|。\n由 V 中的全部 n 个顶点和 E 中 n−1 条边构成的无向连通子图被称为 G 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 G 的最小生成树。\n输入格式 第一行包含两个整数 n 和 m。\n接下来 m 行，每行包含三个整数 u,v,w，表示点 u 和点 v 之间存在一条权值为 w 的边。\n输出格式 共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。\n数据范围 1 ≤ n ≤ 105, 1 ≤ m ≤ 2∗105, 图中涉及边的边权的绝对值均不超过 1000。\n输入样例： 1 2 3 4 5 6 4 5 1 2 1 1 3 2 1 4 3 2 3 2 3 4 4 输出样例： 1 6 算法思想 将所有边按照权值的大小进行升序排序，然后从小到大一一判断。\n如果这个边与之前选择的所有边不会组成回路，就选择这条边分；反之，舍去。\n直到具有 n 个顶点的连通网筛选出来 n-1 条边为止。\n筛选出来的边和所有的顶点构成此连通网的最小生成树。\n判断是否会产生回路的方法为：使用并查集。\n在初始状态下给各个个顶点在不同的集合中。、\n遍历过程的每条边，判断这两个顶点的是否在一个集合中。\n如果边上的这两个顶点在一个集合中，说明两个顶点已经连通，这条边不要。如果不在一个集合中，则要这条边。\n举个例子，下图一个连通网，克鲁斯卡尔算法查找图 1 对应的最小生成树，需要经历以下几个步骤：\n将连通网中的所有边按照权值大小做升序排序：\n从 B-D 边开始挑选，由于尚未选择任何边组成最小生成树，且 B-D 自身不会构成环路，所以 B-D 边可以组成最小生成树。\nD-T 边不会和已选 B-D 边构成环路，可以组成最小生成树：\nA-C 边不会和已选 B-D、D-T 边构成环路，可以组成最小生成树：\nC-D 边不会和已选 A-C、B-D、D-T 边构成环路，可以组成最小生成树：\nC-B 边会和已选 C-D、B-D 边构成环路，因此不能组成最小生成树：\nB-T 、A-B、S-A 三条边都会和已选 A-C、C-D、B-D、D-T 构成环路，都不能组成最小生成树。而 S-A 不会和已选边构成环路，可以组成最小生成树。\n如图下图 所示，对于一个包含 6 个顶点的连通网，我们已经选择了 5 条边，这些边组成的生成树就是最小生成树。\n代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 200010; int n, m; int p[N]; struct Edge{ int a; int b; int w; }edge[N]; bool cmp(struct Edge A, struct Edge B) { return A.w \u0026lt; B.w; } int find(int x) { if (p[x] != x) return p[x] = find(p[x]); return x; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i ++ ) p[i] = i; for (int i = 0; i \u0026lt; m; i ++ ) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; edge[i].a = a, edge[i].b = b, edge[i].w = c; } sort(edge, edge + m, cmp); int res = 0, cnt = 0; for (int i = 0; i \u0026lt; m; i ++ ) { int a = edge[i].a, b = edge[i].b, c = edge[i].w; a = find(a), b = find(b); if (a != b) { p[a] = b; res += c; cnt ++; } } if (cnt == n - 1) cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;impossible\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 二分图 给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环。\n请你判断这个图是否是二分图。\n输入格式 第一行包含两个整数 n 和 m。\n接下来 m 行，每行包含两个整数 u 和 v，表示点 u 和点 v 之间存在一条边。\n输出格式 如果给定图是二分图，则输出 Yes，否则输出 No。\n数据范围 1≤n,m≤105\n输入样例： 1 2 3 4 5 4 4 1 3 1 4 2 3 2 4 输出样例： 1 Yes 算法思想 什么叫二分图\n有两顶点集且图中每条边的的两个顶点分别位于两个顶点集中，每个顶点集中没有边直接相连接！\n说人话的定义：图中点通过移动能分成左右两部分，左侧的点只和右侧的点相连，右侧的点只和左侧的点相连。\n下图就是个二分图：\n下图不是个二分图\n如果判断一个图是不是二分图？\n开始对任意一未染色的顶点染色。\n判断其相邻的顶点中，若未染色则将其染上和相邻顶点不同的颜色。\n若已经染色且颜色和相邻顶点的颜色相同则说明不是二分图，若颜色不同则继续判断。\nbfs 和 dfs 可以搞定！\n代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 100010; int n, m; int h[N], e[N * 2], ne[N * 2], idx; int color[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++; } bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int t = e[i]; if (!color[t]) { if (!dfs(t, 3 - c)) return false; } else if (color[t] \u0026amp;\u0026amp; color[t] != 3 - c) return false; } return true; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(h, -1, sizeof h); for (int i = 1; i \u0026lt;= m; i ++ ) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; add(a, b), add(b, a); } for (int i = 1; i \u0026lt;= n; i ++ ) { if (!color[i]) { if (!dfs(i, 1)) { cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return 0; } } } cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 棋盘覆盖 关押罪犯 匈牙利算法 匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。\n数学知识 数论 质数 定义\n在（严格）大于1的整数中，如果只包含1和本身这两个约数，就被成为质数，或者叫素数。\n质数的判定 \u0026mdash;- 试除法 (O(sqrt(n)))\n1 2 3 4 5 6 7 8 bool is_prime(int n) { if (n \u0026lt; 2) return false; for (int i = 2; i \u0026lt;= n / i; i ++ ) if (n % i == 0) return false; return true; } 分解质因数 \u0026mdash;- 试除法 (O(sqrt(n)))\n思路\n从小到大尝试 n 的所有因数 1 2 3 4 5 6 7 8 9 10 11 12 for (int i = 2; i \u0026lt;= n; i ++ ) if (n % i == 0) { int s = 0; while (n % i == 0) { n /= i; s ++; } cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } 根据算术基本定理，不考虑排列顺序的情况下，每个正整数都能够以唯一的方式表示成它的质因数的乘积。 n=p1^a1 * p2^a2 *p3^a3\u0026hellip;..pn^an 比如一个数16 在分解时先找到2这个质因子，然后由于16/2后还可以/2，所以会在2这个质因子上产生次方 不优化版本：从2~n 找到能整除的因子然后算次方 这里有个性质：n中最多只含有一个大于sqrt(n)的因子。证明通过反证法：如果有两个大于sqrt(n)的因子，那么相乘会大于n，矛盾。证毕 于是我们发现最多只有一个大于sqrt(n)的因子，对其进行优化。先考虑比sqrt(n)小的，代码和质数的判定类似 最后如果n还是\u0026gt;1，说明这就是大于sqrt(n)的唯一质因子，输出即可。\ni 一定是一个质数\n假如 i 是一个合数，那么它一定可以分解成多个质因子相乘的形式，这多个质因子同时也是 a 的质因子且比 i 要小，而比 i 小的数在之前的循环过程中一定是被条件除完了的，所以 i 不可能是合数，只可能是质数\n求证：除了1之外，一个数的最小因数一定是质数\n证明：设任意整数N\u0026gt;0， 若N为质数，则N只有因数1和N，所以除了1之外，N的最小因数是质数N。 若N为合数，除了1之外，设N有最小因数n， 若n为质数，则除了1之外，N的最小因数是质数n。 若n为合数，则除了1和n之外，n必有其它因数，设m为n的因数， 则m也为N的因数，且m\u0026lt;n，所以n为合数时，不可能为N的最小因数。 综上可知，除了1之外，一个数的最小因数一定是质数。\n筛质数\n最普通的筛法 O(nlogn) 1 2 3 4 5 6 7 8 9 10 11 void get_prime() { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++] = i; for (int j = i; j \u0026lt;= n; j += i) { st[j] = true; } } } 埃氏筛法 O(nloglogn) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void get_prime() { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) { primes[cnt ++ ] = i; for (int j = i + i; j \u0026lt;= n; j += i) { st[j] = true; } } } } 线性筛法 O(n) 假设 i 是合数 t 的最大因数，t显然可能不唯一（例如 30 和 45 最大因数都是 15）。但是仔细想一想，必然有 t = i * p(p为小于 i 的质数) 。\np为什么比 i 小？ 因为 i 是 t 的最大因数。 为什么 p 一定是质数？ 因为如果 p 是合数，那么 i 就一定不是 t 的最大因数，因为 p可以再拆成若干素数相乘，这些素数再与 i 相乘会使因数更大。\n既然如此，我们只需要把所有小于 i 的质数 p 都挨个乘一次好了。可是，真相真的是这样的嘛？\n其实不是的，一不小心就忘记了最初的条件。我们要满足 i 是 t 的最大因数。如果 p 大于 i 的最小质因数，那 i 还是 t 的最大因数嘛？显然不是，任何一个合数都能唯一分解为有限个质数的乘积，除去这其中最小的质因数，其他的都乘起来就是最大因数 i 。所以我们不能让 p 大于 i 的最小质因数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 void is_prime() { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } 约数 试除法求约数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int n; vector \u0026lt;int\u0026gt; get_divisors(int n) { vector \u0026lt;int\u0026gt; res; for (int i = 1; i \u0026lt;= n / i; i ++ ) { if (n % i == 0) { res.push_back(i); if (i != n / i) res.push_back(n / i); } } sort(res.begin(), res.end()); return res; } int main() { cin \u0026gt;\u0026gt; n; while(n --) { int x; cin \u0026gt;\u0026gt; x; auto res = get_divisors(x); for (auto t : res) cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; } return 0; } 约数个数\n一个数的约数是由这个数的几个质因子相乘得到的。\n例如：12 的质因子有 2，3。12的约数有：1，2，3，4，6，12。\n约数1 是由 0 个 2， 0 个3相乘得到的。 约数2 是由 1 个 2， 0 个3相乘得到的。 约数3 是由 0 个 2， 1 个3相乘得到的。 约数4 是由 2 个 2， 0 个3相乘得到的。 约数6 是由 1 个 2， 1 个3相乘得到的。 约数12 是由 2 个 2， 1 个3相乘得到的。 12 可以分解为：2^2*3^1。所以2可以取 0 ~ 2个，3种取法。3可以取 0~1 个，2种取法。12的约数一共：2 * 3 = 6个。\n也就是：把一个数N 写成：N = (p1^x1^)(p^x2)(p3^x3)…(pk^xk)，其中pi为质数。则N的约数个数为：(x1+1)(x2+1)(x3+1)…(xk+1)\n约数的个数计算公式基于质因数分解的唯一性定理。若一个数的质因数分解为：\n​ N = p1e1 * p2e2 \u0026hellip; \u0026hellip; pkek\n则其约数个数为：\n​ ( e1 + 1 ) * ( e2 + 1 ) \u0026hellip; \u0026hellip; ( ek + 1 )\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long LL; const int mod = 1e9 + 7; int n; int main() { cin \u0026gt;\u0026gt; n; unordered_map \u0026lt;int, int\u0026gt; h; while(n --) { int x; cin \u0026gt;\u0026gt; x; for (int i = 2; i \u0026lt;= x / i; i ++ ) { while (x % i == 0) { h[i] ++; x /= i; } } if (x \u0026gt; 1) h[x] ++; } LL res = 1; for (auto t : h) res = res * (t.second + 1) % mod; cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } 约数之和\n设正整数 n 的质因数分解为 n = p1e1 p2e2 ⋯ pkek ，其中 p1,p2,…,pk 是不同的质数，且 e1,e2,…,ek 是正整数。\n思路\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; typedef long long LL; const int mod = 1e9 + 7; int main() { int n; cin \u0026gt;\u0026gt; n; unordered_map \u0026lt;int, int\u0026gt; h; LL res = 1; while(n --) { int x; cin \u0026gt;\u0026gt; x; for (int i = 2; i \u0026lt;= x / i; i ++ ) { while (x % i == 0) { x /= i; h[i] ++; } } if (x \u0026gt; 1) h[x] ++; } for (auto p : h) { LL a = p.first, b = p.second; LL t = 1; while(b --) t = (t * a + 1) % mod; res = res * t % mod; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } 欧几里得算法 (辗转相除法 ) 什么是最大公约数\n最大公约数（Greatest Common Divisor）指两个或多个整数共有约数中最大的一个。也称最大公因数、最大公因子，a， b的最大公约数记为（a，b），同样的，a，b，c的最大 公约数记为（a，b，c），多个 整数的最大公约数也有同样的记号。求最大公约数有多种 方法，常见的有 质因数分解法、 短除法、 辗转相除法、 更相减损法。\n辗转相减法求最大公约数\n用(a，b)表示a和b的最大公因数：有结论(a，b)=(a，ka+b)，其中a、b、k都为自然数。\n也就是说，两个数的最大公约数，将其中一个数加到另一个数上，得到的新数，其公约数不变，比如(4，6)=(4+6，6)=(4，6+2×4)=2.\n要证明这个原理很容易：如果p是a和ka+b的公约数，p整除a，也能整除ka+b.那么就必定要整除b，所以p又是a和b的公约数，从而证明他们的最大公约数也是相等的.\n基于上面的原理，就能实现我们的迭代相减法：(78，14)=(64，14)=(50，14)=(36，14)=(22，14)=(8，14)=(8，6)=(2，6)=(2，4)=(2，2)=(0，2)=2\n基本上思路就是大数减去小数，一直减到能算出来为止，在作为练习的时候，往往进行到某一步就已经可以看出得值.\n辗转相减到辗转相除\n迭代相减法简单，不过步数比较多，实际上我们可以看到，在上面的过程中，由(78，14)到(8，14)完全可以一步到位，因为(78，14)=(14×5+8，14)=(8，14)，由此就诞生出我们的辗转相除法.\n即：(a， b) = (a % b， b) = （b, a %b）\n相当于每一步都把数字进行缩小，等式右边就是每一步对应的缩小结果。\n对（a， b）连续使用辗转相除，直到小括号内右边数字为0，小括号内左边的数就是两数最大公约数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n; int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } int main() { cin \u0026gt;\u0026gt; n; while(n --) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; gcd(a, b) \u0026lt;\u0026lt; endl; } return 0; } 欧拉函数 例题(欧拉函数) 给定 n 个正整数 ai，请你求出每个数的欧拉函数。\n欧拉函数的定义\n1∼N 中与 N 互质的数的个数被称为欧拉函数，记为 ϕ(N)。 若在算数基本定理中，N=pa11pa22…pamm，则： ϕ(N) = N×p1−1p1×p2−1p2×…×pm−1pm\n输入格式 第一行包含整数 n。\n接下来 n 行，每行包含一个正整数 ai。\n输出格式 输出共 n 行，每行输出一个正整数 ai 的欧拉函数。\n数据范围 1≤n≤100, 1≤ai≤2×109\n输入样例： 1 2 3 4 3 3 6 8 输出样例： 1 2 3 2 2 4 算法思想 思想\n代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int T; cin \u0026gt;\u0026gt; T; while(T--) { int n; cin \u0026gt;\u0026gt; n; // 公式最前面的n int res = n; //求质因子 for(int i = 2; i \u0026lt;= n / i; i++) { if(n % i == 0)//找到质因子 { // (p - 1) / p // 先除后乘 res = res / i * (i - 1) ; // 对 n 进行约分 while(n % i == 0) n = n / i; } } // 如果有剩余，则剩余是个质因子 if( n \u0026gt; 1) res = res /n * (n - 1) ; cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; } return 0; } 例题(筛法求欧拉函数) 给定一个正整数 n，求 1∼n 中每个数的欧拉函数之和。\n输入格式 共一行，包含一个整数 n。\n输出格式 共一行，包含一个整数，表示 1∼n 中每个数的欧拉函数之和。\n数据范围 1 ≤ n ≤ 106\n输入样例： 1 6 输出样例： 1 12 算法思想 质数i的欧拉函数即为phi[i] = i - 1：1 ~ i−1均与i互质，共i−1个。\nphi[primes[j] * i]分为两种情况：\n① i % primes[j] == 0时：primes[j]是i的最小质因子，也是primes[j] * i的最小质因子，因此1 - 1 / primes[j]这一项在phi[i]中计算过了，只需将基数N修正为primes[j]倍，最终结果为phi[i] * primes[j]。\n② i % primes[j] != 0：primes[j]不是i的质因子，只是primes[j] * i的最小质因子，因此不仅需要将基数N修正为primes[j]倍，还需要补上1 - 1 / primes[j]这一项，因此最终结果phi[i] * (primes[j] - 1)。\n代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long LL; const int N = 1000010; int n; bool st[N]; int primes[N], cnt; int phi[N]; void get_eulers(int n) { phi[1] = 1; for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) { primes[cnt ++] = i; phi[i] = i - 1; } for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) { phi[primes[j] * i] = phi[i] * primes[j]; break; } phi[primes[j] * i] = phi[i] * (primes[j] - 1); } } } int main() { cin \u0026gt;\u0026gt; n; get_eulers(n); LL res = 0; for (int i = 1; i \u0026lt;= n; i ++ ) res += phi[i]; cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } 欧拉定理和费马定理\n快速幂 快速幂:快速求 ab % p 的问题,时间复杂度 : O(logb),若对于n组数据,那么时间复杂度为O(n∗logb)\n一、暴力解法 O(n∗b) 会TLE\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt;n; while(n--) { int a,b,p; long long res=1; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;p; while(b--) res = res * a %p; cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } } 二、快速幂解法 O(n∗logb)\n基本思路:\n预处理出 a20,a21,a22,…,a2logb 这 b 个数\n将 ab 用 a20,a21,a22,…,a2logb 这 b 种数来组合,即组合成 ab = a2x1,a2x2,a2x3,…,a2xt=a2x1+ 2x2+\u0026hellip;+2xt 即用二进制表示\n为什么 ab 可用 a20,a21,a22,…,a2logb 这 b 个数来表示?\n∵ 二进制可以表示所有数,且用单一用二进制表示时, b 单一表示最大可表示为二进制形式的 2logb\n注意:\nb \u0026amp; 1 就是判断 b 的二进制表示中第 0 位上的数是否为 1,若为 1, b \u0026amp; 1 = true ,反之 b \u0026amp; 1 = false 还不理解?进传送门\nb \u0026amp; 1也可以用来判断奇数和偶数, b \u0026amp; 1 = true 时为奇数,反之 b \u0026amp; 1 = false 时为偶数\n快速幂之迭代版 O(n∗logb)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;iostream\u0026gt; using namespace std; long long qmi(long long a,int b,int p) { long long res=1; while(b)//对b进行二进制化,从低位到高位 { //如果b的二进制表示的第0位为1,则乘上当前的a if(b\u0026amp;1) res = res *a %p; //b右移一位 b\u0026gt;\u0026gt;=1; //更新a,a依次为a^{2^0},a^{2^1},a^{2^2},....,a^{2^logb} a=a*a%p; } return res; } int main() { int n; cin\u0026gt;\u0026gt;n; while(n--) { cin.tie(0); ios::sync_with_stdio(false); int a,b,p; long long res=1; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;p; res = qmi(a,b,p); cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } return 0; } 快速幂之递归版 O(n∗logb)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;iostream\u0026gt; using namespace std; #define ull unsigned long long ull quick_pow(ull a,ull b,ull p) { if(b==0) return 1; a%=p; ull res=quick_pow(a,b\u0026gt;\u0026gt;1,p); if(b\u0026amp;1) return res*res%p*a%p; return res*res%p; } int main() { int n; cin\u0026gt;\u0026gt;n; while(n--) { int a,b,p; cin.tie(0); ios::sync_with_stdio(false); cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;p; cout\u0026lt;\u0026lt;quick_pow(a,b,p)\u0026lt;\u0026lt;endl; } return 0; } 快速幂求逆元 给定 n 组 ai,pi，其中 pi 是质数，求 ai 模 pi 的乘法逆元，若逆元不存在则输出 impossible。\n注意：请返回在 0∼p−1 之间的逆元。\n乘法逆元的定义 若整数 b，m 互质，并且对于任意的整数 a，如果满足 b|a，则存在一个整数 x，使得 ab≡a×x(modm)，则称 x 为 b 的模 m 乘法逆元，记为 b−1(modm)。\nb 存在乘法逆元的充要条件是 b 与模数 m 互质。当模数 m 为质数时，bm−2 即为 b 的乘法逆元。\n输入格式 第一行包含整数 n。\n接下来 n 行，每行包含一个数组 ai,pi，数据保证 pi 是质数。\n输出格式 输出共 n 行，每组数据输出一个结果，每个结果占一行。\n若 ai 模 pi 的乘法逆元存在，则输出一个整数，表示逆元，否则输出 impossible。\n数据范围 1≤n≤105, 1≤ai,pi≤2∗109\n输入样例： 1 2 3 4 3 4 3 8 5 6 3 输出样例： 1 2 3 1 2 impossible 算法思想 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long LL; LL qmi(int a, int k, int p) { LL res = 1 % p; while(k) { if (k \u0026amp; 1) res = (LL) res * a % p; k \u0026gt;\u0026gt;= 1; a = (LL) a * a % p; } return res; } int main() { int n; cin \u0026gt;\u0026gt; n; while(n --) { int a, k; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; k; LL res = qmi(a, k - 2, k); if (a % k != 0) cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;impossible\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 扩展欧几里得算法 裴蜀定理(Bezout 定理) 存在任意数 a 和 b ，一定存在一组数 x，y ，使 ax + by = (a, b)\n给定 n 对正整数 ai,bi，对于每对数，求出一组 xi,yi，使其满足 ai×xi+bi×yi=gcd(ai,bi)。\n输入格式 第一行包含整数 n。\n接下来 n 行，每行包含两个整数 ai,bi。\n输出格式 输出共 n 行，对于每组 ai,bi，求出一组满足条件的 xi,yi，每组结果占一行。\n本题答案不唯一，输出任意满足条件的 xi,yi 均可。\n数据范围 1≤n≤105, 1≤ai,bi≤2×109\n输入样例： 1 2 3 2 4 6 8 18 输出样例： 1 2 -1 1 -2 1 算法思想 扩展欧几里得 用于求解方程 ax + by = gcd(a,b) 的解\n当 b = 0 时 ax + by = a 故而 x = 1,y = 0\n当 b ≠ 0 时\n因为 gcd(a, b) = gcd(b,a % b)\n而 bx′ + (a % b)y′ = gcd(b,a%b)\nbx′+(a−⌊a/b⌋∗b)y′=gcd(b,a%b)\nay′+b(x′−⌊a/b⌋∗y′)=gcd(b,a%b)=gcd(a,b)\n故而\nx=y′,y=x′−⌊a / b⌋∗y′\n因此可以采取递归算法 先求出下一层的x′和y′ 再利用上述公式回代即可\n对于求解更一般的方程 ax+by=c 设 d = gcd(a, b) 则其有解当且仅当 d|c\n求解方法如下:\n用扩展欧几里得求出 ax0 + by0 = d 的解\n则 a (x0 * c / d) + b(y0 ∗ c / d) = c\n故而特解为 x′ = x0\\ * c/d,y′ = y0*c/d\n而通解 = 特解 + 齐次解\n而齐次解即为方程 ax+by=0的解\n故而通解为 x=x′+k*b/d,y=y′−k*a/dk∈𝕫 若令 t=b/d, 则对于 x 的最小非负整数解为 (x′%t+t)%t\n应用: 求解一次同余方程 ax≡b(modm) 则等价于求\nax=m*(−y)+b\nax+my=b\n有解条件为 gcd(a,m)|b,然后用扩展欧几里得求解即可\n特别的 当 b=1 且 a与m互质时 则所求的x即为a的逆元\n代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y) { if (!b) { x = 1, y = 0; return a; } else { int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; } } int main() { int n; cin \u0026gt;\u0026gt; n; while(n --) { int a, b, x, y; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; exgcd(a, b, x, y); cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } return 0; } 线性同余方程 给定 n 组数据 ai , bi , mi，对于每组数求出一个 xi，使其满足 ai × xi ≡ bi (mod mi)，如果无解则输出 impossible。\n输入格式 第一行包含整数 n。\n接下来 n 行，每行包含一组数据 ai,bi,mi。\n输出格式 输出共 n 行，每组数据输出一个整数表示一个满足条件的 xi，如果无解则输出 impossible。\n每组数据结果占一行，结果可能不唯一，输出任意一个满足条件的结果均可。\n输出答案必须在 int 范围之内。\n数据范围 1 ≤ n ≤ 105, 1 ≤ ai, bi, mi ≤ 2 ×109\n输入样例： 1 2 3 2 2 3 6 4 3 5 输出样例： 1 2 impossible -3 算法思想 因为 a ∗ x ≡ b ( mod m ) 等价于 a ∗ x − b 是 m 的倍数，因此线性同余方程等价为 a∗x+m∗y=b 根据 Bezout 定理，上述等式有解当且仅当 gcd (a, m) | b 因此先用扩展欧几里得算法求出一组整数 x0, y0, 使得 a ∗ x0 + m ∗ y0 = gcd(a,m)。 然后 x = x0 ∗ b / gcd(a,m) % m 即是所求。 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long LL; int exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y) { if (!b) { x = 1, y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; } int main() { int n; cin \u0026gt;\u0026gt; n; while(n --) { int a, b, m, x, y; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; m; int d = exgcd(a, m, x, y); if (b % d == 0) cout \u0026lt;\u0026lt; (LL)x * b / d % m \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;impossible\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 中国剩余定理 详细解释\n表达整数的奇怪方式 给定 2n 个整数 a1, a2, … , an 和 m1, m2, … , mn，求一个最小的非负整数 x，满足 ∀i ∈ [1,n], x ≡ mi(mod ai)。\n输入格式 第 1 行包含整数 n。\n第 2…n+1 行：第 i+1 行包含两个整数 ai 和 mi，数之间用空格隔开。\n输出格式 输出最小非负整数 x，如果 x 不存在，则输出 −1。\n数据范围 1≤ai≤231−1, 0≤mi\u0026lt;ai 1≤n≤25 所有 mi 的最小公倍数在 64 位有符号整数范围内。\n输入样例： 1 2 3 2 8 7 11 9 输出样例： 1 31 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long LL; LL exgcd(LL a, LL b, LL \u0026amp;x, LL \u0026amp;y) { if (!b) { x = 1, y = 0; return a; } LL d = exgcd(b, a % b, y, x); y -= a / b * x; return d; } int main() { int n; cin \u0026gt;\u0026gt; n; LL a1, m1, x; cin \u0026gt;\u0026gt; a1 \u0026gt;\u0026gt; m1; for (int i = 0; i \u0026lt; n - 1; i ++ ) { LL a2, m2; cin \u0026gt;\u0026gt; a2 \u0026gt;\u0026gt; m2; LL k1, k2; LL d = exgcd(a1, a2, k1, k2); if ((m2 - m1) % d) { x = -1; break; } k1 *= (m2 - m1) / d; LL t = a2 / d; k1 = (k1 % t + t) % t; m1 = a1 * k1 + m1; a1 = abs(a1 * a2 / d); } if (x != -1) x = (m1 % a1 + a1) % a1; cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; return 0; } 高斯消元 通过初等行变换 把 增广矩阵 化为 阶梯型矩阵 并回代 得到方程的解\n适用于求解 包含n 个方程，n 个未知数的多元线性方程组\n例题(高斯消元解线性方程组) 输入一个包含 n 个方程 n 个未知数的线性方程组。\n方程组中的系数为实数。\n求解这个方程组。\n下图为一个包含 m 个方程 n 个未知数的线性方程组示例：\n输入格式 第一行包含整数 n。\n接下来 n 行，每行包含 n+1 个实数，表示一个方程的 n 个系数以及等号右侧的常数。\n输出格式 如果给定线性方程组存在唯一解，则输出共 n 行，其中第 i 行输出第 i 个未知数的解，结果保留两位小数。\n注意：本题有 SPJ，当输出结果为 0.00 时，输出 -0.00 也会判对。在数学中，一般没有正零或负零的概念，所以严格来说应当输出 0.00，但是考虑到本题作为一道模板题，考察点并不在于此，在此处卡住大多同学的代码没有太大意义，故增加 SPJ，对输出 -0.00 的代码也予以判对。\n如果给定线性方程组存在无数解，则输出 Infinite group solutions。\n如果给定线性方程组无解，则输出 No solution。\n数据范围 1 ≤ n ≤ 100, 所有输入系数以及常数均保留两位小数，绝对值均不超过 100。\n输入样例： 1 2 3 4 3 1.00 2.00 -1.00 -6.00 2.00 1.00 -3.00 -9.00 -1.00 -1.00 2.00 7.00 输出样例： 1 2 3 1.00 -2.00 3.00 算法步骤 枚举每一列c，\n找到当前列绝对值最大的一行 用初等行变换(2) 把这一行换到最上面（未确定阶梯型的行，并不是第一行） 用初等行变换(1) 将该行的第一个数变成 1 （其余所有的数字依次跟着变化） 用初等行变换(3) 将下面所有行的当且列的值变成 0\n代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; const int N = 110; const double esp = 1e-6; int n; double a[N][N]; int gauss() { int r, c; for (r = 0, c = 0; c \u0026lt; n; c ++ ) { int t = c; for (int i = r; i \u0026lt; n; i ++ ) { if (fabs(a[i][c]) \u0026gt; fabs(a[t][c])) t = i; } if (fabs(a[t][c]) \u0026lt; esp) continue; for (int i = c; i \u0026lt; n + 1; i ++ ) swap(a[t][i], a[r][i]); for (int i = n; i \u0026gt;= c; i -- ) a[r][i] /= a[r][c]; for (int i = r + 1; i \u0026lt; n; i ++ ) { if (fabs(a[i][c]) \u0026gt; esp) { for (int j = n; j \u0026gt;= c; j --) { a[i][j] -= a[r][j] * a[i][c]; } } } r ++; } if (r \u0026lt; n) { for(int i = r; i \u0026lt; n; i ++ ) { if (fabs(a[i][n]) \u0026gt; esp) return 2; } return 1; } for (int i = n - 1; i \u0026gt;= 0; i -- ) for (int j = i + 1; j \u0026lt; n; j ++ ) a[i][n] -= a[j][n] * a[i][j]; return 0; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i ++ ) for (int j = 0; j \u0026lt; n + 1; j ++ ) cin \u0026gt;\u0026gt; a[i][j]; int t = gauss(); if (t == 0) { for (int i = 0; i \u0026lt; n; i ++) cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2) \u0026lt;\u0026lt; a[i][n] \u0026lt;\u0026lt; endl; } else if (t == 1) cout \u0026lt;\u0026lt; \u0026#34;Infinite group solutions\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;No solution\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 求组合数 I 给定 n 组询问，每组询问给定两个整数 a，b，请你输出 Cba mod ( 109 + 7 ) 的值。\n输入格式 第一行包含整数 n。\n接下来 n 行，每行包含一组 a 和 b。\n输出格式 共 n 行，每行输出一个询问的解。\n数据范围 1 ≤ n ≤ 10000, 1 ≤ b ≤ a ≤ 2000\n输入样例： 1 2 3 4 3 3 1 5 3 2 2 输出样例： 1 2 3 3 10 1 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 2010, mod = 1e9 + 7; int c[N][N]; void init() { for (int i = 0; i \u0026lt; N; i ++ ) for (int j = 0; j \u0026lt;= i; j ++ ) { if (!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod; } } int main() { int n; cin \u0026gt;\u0026gt; n; init(); while(n --) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; c[a][b] \u0026lt;\u0026lt; endl; } return 0; } 求组合数 II 给定 n 组询问，每组询问给定两个整数 a，b，请你输出 Cba mod ( 109 + 7 ) 的值。\n输入格式 第一行包含整数 n。\n接下来 n 行，每行包含一组 a 和 b。\n输出格式 共 n 行，每行输出一个询问的解。\n数据范围 1 ≤ n ≤ 10000, 1 ≤ b ≤ a ≤ 105\n输入样例： 1 2 3 4 3 3 1 5 3 2 2 输出样例： 1 2 3 3 10 1 代码示例 求组合数 III 给定 n 组询问，每组询问给定三个整数 a, b, p，其中 p 是质数，请你输出 Cba mod p 的值。\n输入格式 第一行包含整数 n\n接下来 n 行，每行包含一组 a, b, p。\n输出格式 共 n 行，每行输出一个询问的解。\n数据范围 1 ≤ n ≤ 20, 1 ≤ b ≤ a ≤ 1018, 1 ≤ p ≤ 105,\n输入样例： 1 2 3 4 3 5 3 7 3 1 5 6 4 13 输出样例： 1 2 3 3 3 2 代码示例 求组合数 IV 输入 a, b，求 Cba 的值。\n注意结果可能很大，需要使用高精度计算。\n输入格式 共一行，包含两个整数 a 和 b。\n输出格式 共一行，输出 Cba 的值。\n数据范围 1 ≤ b ≤ a ≤ 5000\n输入样例： 1 5 3 输出样例： 1 10 动态规划 贪心算法 时空复杂度分析 课外知识 由数据范围反推算法复杂度以及算法内容 一般ACM或者笔试题的时间限制是1秒或2秒。 在这种情况下，C++代码中的操作次数控制在 107∼108 为最佳。\n下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：\nn≤30, 指数级别, dfs+剪枝，状态压缩dp n≤100 =\u0026gt; O(n3)，floyd，dp，高斯消元 n≤1000 =\u0026gt; O(n2)，O(n2logn)，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford n≤10000 =\u0026gt; O(n∗n‾√)，块状链表、分块、莫队 n≤100000 =\u0026gt; O(nlogn) =\u0026gt; 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树 n≤1000000 =\u0026gt; O(n), 以及常数较小的 O(nlogn) 算法 =\u0026gt; 单调队列、 hash、双指针扫描、BFS、并查集，kmp、AC自动机，常数比较小的 O(nlogn) 的做法：sort、树状数组、heap、dijkstra、spfa n≤10000000 =\u0026gt; O(n)，双指针扫描、kmp、AC自动机、线性筛素数 n≤109 =\u0026gt; O(n‾√)，判断质数 n≤1018 =\u0026gt; O(logn)，最大公约数，快速幂，数位DP n≤101000 =\u0026gt; O((logn)2)，高精度加减乘除 n≤10100000 =\u0026gt; O(logk×loglogk)，k表示位数，高精度加减、FFT/NTT\n原链接：由数据范围反推算法复杂度以及算法内容\nputs() 用法 puts() 是 C 标准库中的一个输出函数，在 C++ 中也可通过 \u0026lt;cstdio\u0026gt; 头文件使用。以下是其详细用法：\n函数原型\n1 int puts(const char *str); • 功能：将字符串 str 输出到标准输出（屏幕），并自动追加换行符。\n• 参数：C 风格字符串（以 \\0 结尾的字符数组）。\n• 返回值：\n◦ 成功时返回非负值。\n◦ 失败时返回 EOF（通常无需检查）。\n迭代器（Iterator）的使用方法 在C++中，迭代器（Iterator）是一种访问容器元素的方式，它能够遍历容器（如vector、list、map等）中的元素，而不需要知道容器的内部实现。下面是一些常见的迭代器使用方法：\n1. 基本用法 C++ STL中的容器一般都支持迭代器操作，可以通过begin()和end()成员函数获取容器的迭代器。\n示例：使用vector的迭代器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; // 创建迭代器 std::vector\u0026lt;int\u0026gt;::iterator it; // 通过迭代器访问容器元素 for (it = vec.begin(); it != vec.end(); ++it) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 解引用迭代器 } return 0; } 2. auto关键字简化迭代器类型 C++11之后，使用auto可以自动推断迭代器类型，使代码更加简洁：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; // 使用auto简化迭代器声明 for (auto it = vec.begin(); it != vec.end(); ++it) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 3. 反向迭代器 如果要反向遍历容器，可以使用rbegin()和rend()获取反向迭代器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; // 反向遍历 for (auto it = vec.rbegin(); it != vec.rend(); ++it) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 4. 常量迭代器 如果不想修改容器中的元素，可以使用常量迭代器（const_iterator），它保证了元素不可修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; // 使用const_iterator for (std::vector\u0026lt;int\u0026gt;::const_iterator it = vec.begin(); it != vec.end(); ++it) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 5. 使用范围for遍历（C++11及以上） C++11提供了范围for循环，这样可以更简洁地遍历容器，而无需显式使用迭代器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; // 范围for循环 for (auto val : vec) { std::cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 这种方式是最简洁的，但它并不是基于迭代器的，而是通过范围自动推断类型。\n总结\n​\t1.\tbegin()和end()分别返回容器的起始和结束迭代器。\n​\t2.\tauto可以简化迭代器类型声明。\n​\t3.\t使用rbegin()和rend()进行反向遍历。\n​\t4.\tconst_iterator保证容器元素不可修改。\n​\t5.\tC++11引入的范围for提供了更简洁的遍历方式。\n","date":"2024-11-12T20:43:19+08:00","permalink":"http://localhost:1313/p/acwing--basic/","title":"Acwing--basic"},{"content":"HTML基础知识 C/S架构与B/S架构 C/S架构，特点：需要安装、偶尔更新、不跨平台、开发更具针对性。 B/S架构，特点：无需安装、无需更新、可跨平台、开发更具通用性。 一点解释：名词解释：C=\u0026gt;client（客户端）、B=\u0026gt; browser（浏览器）、S=\u0026gt;server（服务器）。 服务器：为软件提供数据的设备（在背后默默的付出）。\nHTML简介 全称：HyperText Markup Language（超文本标记语言）。 超文本：暂且简单理解为“超级的文本”，和普通文本比，内容更丰富。 标 记：文本要变成超文本，就需要用到各种标记符号。 语言：每一个标记的写法、读音、使用规则，组成了一个标记语言。 相关国际组织（了解） 1. IETF 全称：Internet Engineering Task Force（国际互联网工程任务组），成立于1985年底，是一个权威的互联网技术标准化组织，主要负责互联网相关技术规范的研发和制定，当前绝大多数国际互联网技术标准均出自IETF。官网：https://www.ietf.org\n2. W3C 全称：World Wide Web Consortium（万维网联盟），创建于1994年，是目前Web技术领域，最具影响力的技术标准机构。共计发布了200多项技术标准和实施指南，对互联网技术的发展和应用起到了基础性和根本性的支撑作用，官网：https://www.w3.org\n3. WHATWF 全称：Web Hypertext Application Technology Working Group（网页超文本应用技术工作小组）成立于2004年，是一个以推动网络HTML 5标准为目的而成立的组织。由Opera、Mozilla基金会、苹果，等这些浏览器厂商组成。官网：https://whatwg.org/\nHTML发展历史（了解） 从HTML 1.0开始发展，期间经历了很多版本，目前HTML的最新标准是：HMTL 5，具体发展史如图（了解即可）。\nHTML入门 HTML标签 标签 又称 元素，是HTML的基本组成单位。 标签分为：双标签 与 单标签（绝大多数都是双标签）。 标签名不区分大小写，但推荐小写，因为小写更规范。 双标签(格式)：\u0026lt;标签名\u0026gt;标签体\u0026lt;标签名\u0026gt; 单标签(格式)：\u0026lt;标签名/\u0026gt;(/可省略) 标签之间的关系：并列关系、嵌套关系，可以使用 tab 键进行缩进： HTML标签属性 用于给标签提供 附加信息。\n可以写在：起始标签 或 单标签中，形式如下：\n例如：\n1 2 \u0026lt;marquee 10op=\u0026#34;1\u0026#34; bgcolor=\u0026#34;orange\u0026#34;\u0026gt;曼联必胜！！！\u0026lt;/marquee\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34;\u0026gt; 有些特殊的属性，没有属性名，只有属性值，例如： 1 \u0026lt;input disabled\u0026gt; 注意点\n1.不同的标签，有不同的属性；也有一些通用属性（在任何标签内都能写，后面会详细总结）。\n2．属性名、属性值不能乱写，都是W3C规定好的。\n3．属性名、属性值，都不区分大小写，但推荐小写。\n4． 双引号，也可以写成单引号，甚至不写都行，但还是推荐写双引号。\n5． 标签中不要出现同名属性，否则后写的会失效.\nHTML基本结构 1．在网页中，如何查看某段结构的具体代码？——点击鼠标右键，选择“检查”。 2． 【检查】和【查看网页源代码】的区别：\n【查看网页源代码】看到的是：程序员编写的源代码。 【检查】看到的是：经过浏览器“处理”后的源代码。 备注：日常开发中，【检查】用的最多。 3． 网页的 基本结构 如下：\n想要呈现在网页中的内容写在 body 标签中。 head 标签中的内容不会出现在网页中。 head 标签中的 title 标签可以指定网页的标题。 HTML 注释 1.特点：注释的内容会被浏览器所忽略，不会呈现到页面中，但源代码中依然可见。 2．作用：对代码进行解释和说明。 3．写法：\n1 2 3 \u0026lt;！-- 下面的文字只能滚动一次--\u0026gt; \u0026lt;marquee 100p=\u0026#34;1\u0026#34;\u0026gt;尚硅谷\u0026lt;/marquee\u0026gt; \u0026lt;！-- 下面的文字可以无限滚动 --\u0026gt;\u0026lt;marquee\u0026gt;尚硅谷123\u0026lt;/marquee\u0026gt; 注释不可以嵌套，以下这么写是错的（反例）。 1 2 3 4 ＜！-- 我是一段注释 \u0026lt;！-- 我是一段注释 --\u0026gt; --\u0026gt; HTML 文档声明 1． 作用：告诉浏览器当前网页的版本。 2．写法：\n旧写法：要依网页所用的HTML版本而定，写法有很多。\n具体有哪些写法请参考：W3C官网-文档声明（了解即可) 新写法：一切都变得简单了！W3C推荐使用HTML5的写法。\n1 2 3 4 5 \u0026lt; !DOCTYPE html\u0026gt; 或 \u0026lt;! DOCTYPE HTML\u0026gt; 或 \u0026lt;!doctype html\u0026gt; 注意：文档声明，必须在网页的第一行，且在 html 标签的外侧。 HTML 字符编码 1． 计算机对数据的操作：\n存储时，对数据进行：编码。 读取时，对数据进行：解码。 编码、解码，会遵循一定的规范——字符集。 字符集有很多中，常见的有（了解）： ASCII：大写字母、小写字母、数字、一些符号，共计128个。 ISO 8859-1：在ASCII基础上，扩充了一些希腊字符等，共计是256个。 GB2312：继续扩充，收录了 6763个常用汉字、682个字符。 GBK：收录了的汉字和符号达到20000+，支持繁体中文。 UTF-8 ：包含世界上所有语言的：所有文字与符号。——很常用。 使用原则 原则1：存储时，务必采用合适的字符编码。 否则：无法存储，数据会丢失！ 原则2：存储时采用哪种方式编码，读取时就采用哪种方式解码。 否则：数据错乱（乱码）！ 总结： 平时编写代码时，统一采用 UTF-8 编码（最稳妥）。 为了让浏览器在渲染 html 文件时，不犯错误，可以通过 meta 标签配合 charset 属性指定字符编码。 HTML 设置语言 主要作用： 了 让浏览器显示对应的翻译提示。 了 有利于搜索引擎优化。 具体写法： 扩展知识：lang 属性的编写规则（作一个课外扩展知识，了解即可）。 第一种写法（语言-国家/地区），例如： zh-CN ：中文-中国大陆（简体中文） zh-TW ：中文-中国台湾（繁体中文） zh：中文 en-US：英语-美国 en-GB：英语-英国 第二种写法（语言一具体种类）已不推荐使用，例如： zh-Hans：中文一简体 zh-Hant：中文—繁体 W3School上的说明：《语言代码参考手册》、《国家/地区代码参考手册》\\ W3C官网上的说明：《Language tags in HTML》 HTML标准结构 HTML标准结构如下：\n1 2 3 4 5 6 7 8 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;我是一个标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; ‹body\u0026gt; \u0026lt;/ body\u0026gt; \u0026lt;/html\u0026gt; 输入！，随后回车即可快速生成标准结构。\n配置 VScode 的内置插件 emmet，可以对生成结构的属性进行定制。\n在存放代码的文件夹中，存放一个 favicon.ico 图片，可配置网站图标。\nHTML4基础 开发者文档 W3CEXX: www.w3c.org W3School: www.w3school.com.cn MDN: developer .mozilla.org -—平时用的最多。 排版标签 标签名 标签含义 单/双标签 h1~h6 标题 双 p 段落 双 div 没有任何含义，用于整体布局 双 h1 最好写一个，h2~h6 能适当多写。 h1~h6 不能互相嵌套，例如：h1 标签中最好不要写 h2 标签了。 p标签很特殊！它里面不能有：h1~h6、p、div 标签（暂时先这样记，后面会说规律）。 语义化标签 概念：用特定的标签，去表达特定的含义。 原则：标签的默认效果不重要（后期可以通过cSS随便控制效果），语义最重要！ 举例：对于h1 标签，效果是文字很大（不重要），语义是网页主要内容（很重要）。 优势： 代码结构清晰可读性强。 有利于 SEO（搜索引擎优化）。 方便设备解析（如屏幕阅读器、盲人阅读器等）。 块级元素与行内元素 块级元素：独占一行（排版标签都是块级元素）。 行内元素：不独占一行（目前只学了：input，稍后会学习更多）。 使用原则： 块级元素中能写行内元素和块级元素（简单记：块级元素中几乎什么都能写） 行内元素中能写行内元素，但不能写块级元素。 一些特殊的规则： h1~h6 不能互相嵌套。 p中不要写块级元素。 文本标签_常用的 用于包裹：词汇、短语等。 通常写在排版标签里面。 排版标签更宏观（大段的文字），文本标签更微观（词汇、短语）。 文本标签通常都是行内元素。 标签名 标签语义 单/双标签 em 要着重阅读的内容 双 strong 十分重要的内容（语气比em要强） 双 span 没有语义，用于包裹短语的通用容器 双 生活中的例子：div 是大包装袋，span 是小包装袋。 文本标签_不常用的 标签名 标签语义 单/双标签 cite 作品标题（书籍、歌曲、电影、电视节目、绘画、雕塑） 双 dfn 特殊术语，或专属名词 双 del和ins 删除的文本【与】插入的文本 双 sub与sup 下标文字【与】上标文字 双 code 一段代码 双 samp 从正常的上下文中，将某些内容提取出来，例如：标识设备输出 双 kbd 键盘文本，表示文本是通过键盘输入的，经常用在与计算机相关的手册中 双 abbr 缩写，最好配合上 title 属性 双 bdo 更改文本方向，要配合dir 属性，可选值：ltr(默认值)、rtl 双 var 标记变量，可以与 code 标签一起使用 双 small 附属细则，例如：包括版权、法律文本。\u0026ndash;很少使用 双 b 摘要中的关键字、评论中的产品名称。\u0026ndash;很少使用 双 i 本意是：人物的思想活动、所说的话等等。现在多用于：呈现字体图标（后面要讲的内容）。 双 u 与正常内容有反差文本，例如：错的单词、不合适的描述等。\u0026ndash;很少使用 双 q 短引用\u0026ndash;很少使用 双 blockquote 长引用\u0026ndash;很少使用 双 address 地址信息 双 备注：\n这些不常用的文本标签，编码时不用过于纠结（酌情而定，不用也没毛病）。 blockquote 与 address 是块级元素，其他的文本标签，都是行内元素。 有些语义感不强的标签，我们很少使用，例如：small、b、 u、 q、 blockquote HTML标签太多了！记住那些：重要的、语义感强的标签即可；截止目前，有这些：h1~h6, p. div, em, strong, span 图片标签 基本使用 标签名 标签语义 常用属性 单/双标签 img 图片 src：图片路径（又称：图片地址）——图片的具体位置alt：图片描述width：图片宽度，单位是像素，例如：200px 或 200height：图片高度，单位是像素，例如：200px 或200 总结：\n像素（px）是一种单位，学到css时，我们会详细讲解。\n尽量不同时修改图片的宽和高，可能会造成比例失调。\n暂且认为 img 是行内元素（学到css 时，会认识一个新的元素分类，目前咱们只知道： （块、行内）。\nalt 属性的作用：\n搜索引擎通过 alt 属性，得知图片的内容。一一最主要的作用。 当图片无法展示时候，有些浏览器会呈现 alt 属性的值。 盲人阅读器会朗读 alt 属性的值。 路径的分类 相对路径 以当前位置作为参考点，去建立路径。\n符号 含义 ./ 同级 / 下一级 ../ 上一级 注意点：\n相对路径中的./可以省略不写。 相对路径依赖的是当前位置，后期若调整了文件位置，那么文件中的路径也要修改。 绝对路径 以根位置作为参考点，去建立路径。\n本地绝对路径：E:/a/b/c/奥特曼.jpg。（很少使用） 网络绝对路径：http://www.atguigu.com/images/index_new/1ogo.png。 注意点：\n使用本地绝对路径，一旦更换设备，路径处理起来比较麻烦，所以很少使用。 使用网络绝对路径，确实方便，但要注意：若服务器开启了防盗链，会造成图片引入失败。 常见图片格式 jpg 格式 概述：扩展名为.jpg 或.jpeg，是一种有损的压缩格式（把肉眼不容易观察出来的细节丟弃了）。 主要特点：支持的颜色丰富、占用空间较小、不支持透明背景、不支持动态图。 使用场景：对图片细节没有极高要求的场景，例如：网站的产品宣传图等。\u0026mdash;-该格式网页中很常见。 png格式 概述：扩展名为.png，是一种无损的压缩格式，能够更高质量的保存图片。 主要特点：支持的颜色丰富、占用空间略大、支持透明背景、不支持动态图。 使用场景：①想让图片有透明背景；②想更高质量的呈现图片；例如：公司logo图、重要配图等。 bmp格式 概述：扩展名为.bmp，不进行压缩的一种格式，在最大程度上保留图片更多的细节。 主要特点：支持的颜色丰富、保留的细节更多、占用空间极大、不支持透明背景、不支持动态图。 使用场景：对图片细节要求极高的场景，例如：一些大型游戏中的图片。（网页中很少使用） gif格式 概述：扩展名为 ．gif，仅支持256种颜色，色彩呈现不是很完整。 主要特点：支持的颜色较少、支持简单透明背景、支持动态图。 使用场景：网页中的动态图片。 webp格式 概述：扩展名为．webp，谷歌推出的一种格式，专门用来在网页中呈现图片。 主要特点：具备上述几种格式的优点，但兼容性不太好，一旦使用务必要解决兼容性问题。 使用场景：网页中的各种图片。 base64格式 本质：一串特殊的文本，要通过浏览器打开，传统看图应用通常无法打开。 原理：把图片进行 base64 编码，形成一串文本。 如何生成：靠一些工具或网站。 如何使用：直接作为 img 标签的 src 属性的值即可，并且不受文件位置的影响。 使用场景：一些较小的图片，或者需要和网页一起加载的图片。 超链接 主要作用：从当前页面进行跳转。 可以实现： ①跳转到指定页面 ②跳转到指定文件（也可触发下载） ③跳转到锚点位置 ④唤起指定应用。 标签名 标签语义 常用属性 单/双标签 a 超链接 href ：指定要跳转到的具体目标。target ：控制跳转时如何打开页面，常用值如下：_self：在本窗口打开。_blank：在新窗口打开。id ：元素的唯一标识，可用于设置锚点。name：元素的名字，写在a 标签中，也能设置锚点。 双 跳转到页面\n1 2 3 4 \u0026lt;！--跳转其他网页--＞ \u0026lt;a href=\u0026#34;https://www.jd.com/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;去京东\u0026lt;/a\u0026gt; \u0026lt;！--跳转本地网页--＞ \u0026lt;a href=\u0026#34;./10_HTML排版标签.html\u0026#34;target=\u0026#34;_self\u0026#34;\u0026gt;去看排版标签\u0026lt;/a\u0026gt; 注意点：\n代码中的多个空格、多个回车，都会被浏览器解析成一个空格！\n虽然a是行内元素，但a 元素可以包裹除它自身外的任何元素！ 想展示多个回车或空格，怎么办呢？——后面会讲。\n跳转到文件\n1 2 3 4 5 6 7 8 9 \u0026lt;！-- 浏览器能直接打开的文件 --\u0026gt; \u0026lt;a href=\u0026#34; ./resource/自拍.jpg\u0026#34;\u0026gt;看自拍\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34; ./resource/小电影.mp4\u0026#34;\u0026gt;看小电影\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34; ./resource/小姐姐.gif\u0026#34;\u0026gt;看小姐姐\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34; ./resource/如何一夜暴富.pdf\u0026#34;\u0026gt;点我一夜暴富\u0026lt;/a\u0026gt; \u0026lt;！-- 浏览器不能打开的文件，会自动触发下载 --\u0026gt; \u0026lt;a href=\u0026#34; ./resource/内部资源.zip\u0026#34;\u0026gt;内部资源\u0026lt;/a\u0026gt; \u0026lt;！-- 强制触发下载--\u0026gt; \u0026lt;a href=\u0026#34; ./resource/小电影.mp4\u0026#34; download=\u0026#34;电影片段.mp4\u0026#34;\u0026gt;下载电影\u0026lt;/a\u0026gt; 注意1：若浏览器无法打开文件，则会引导用户下载。 注意2：若想强制触发下载，请使用 download 属性，属性值即为下载文件的名称。\n跳转到锚点\n什么是锚点？——网页中的一个标记点。 具体使用方式：\n设置锚点\n1 2 3 4 \u0026lt;！-- 第一种方式：a标签配合name属性--\u0026gt; \u0026lt;a name=\u0026#34;test1\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;！-- 第二种方式：其他标签配合id属性--\u0026gt; \u0026lt;h2 id=\u0026#34;test2\u0026#34;\u0026gt;我是一个位置\u0026lt;/h2\u0026gt; 注意点：\n具有 href 属性的 a 标签是超链接，具有 name 属性的 a 标签是锚点。 name 和 id 都是区分大小写的，且 id 最好别是数字开头。 跳转锚点\n1 2 3 4 5 6 7 8 9 \u0026lt;！-- 跳转到test1锚点--\u0026gt; \u0026lt;a href=\u0026#34;#test1\u0026#34;\u0026gt;去test1锚点\u0026lt;/a\u0026gt; \u0026lt;！-- 跳到本页面顶部 --\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;回到顶部\u0026lt;/a\u0026gt; \u0026lt;！-- 跳转到其他页面锚点 --\u0026gt; \u0026lt;a href=\u0026#34;demo.html#test1\u0026#34;\u0026gt;去demo.htm1页面的test1锚点\u0026lt;/a\u0026gt; \u0026lt;！-- 刷新本页面 --\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;刷新本页面\u0026lt;/a\u0026gt; \u0026lt;！--执行一段js，如果还不知道执行什么，可以留空，javascript：；--\u0026gt;\u0026lt;a href=\u0026#34;javascript:alert（1）；\u0026#34;\u0026gt;点我弹窗\u0026lt;/a\u0026gt; 唤起指定应用\n通过a标签，可以唤起设备应用程序。\n1 2 3 4 \u0026lt;！-- 唤起设备拨号 --＞ \u0026lt;a href=\u0026#34;tel:10010\u0026#34;\u0026gt;电话联系\u0026lt;/a\u0026gt;\u0026lt;！-- 唤起设备发送邮件 --\u0026gt; \u0026lt;a href=\u0026#34;mailto:10010@qq.com\u0026#34;\u0026gt;邮件联系\u0026lt;/a\u0026gt;\u0026lt;！-- 唤起设备发送短信 --\u0026gt; \u0026lt;a href=\u0026#34; sms:10086\u0026#34;\u0026gt;短信联系\u0026lt;/a\u0026gt; 列表 有序列表\n概念：有顺序或侧重顺序的列表。\n1 2 3 4 5 6 \u0026lt;h2\u0026gt;要把大象放冰箱总共分几步\u0026lt;/h2\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;把冰箱门打开\u0026lt;/1i\u0026gt; \u0026lt;1i\u0026gt;把大象放进去\u0026lt;/1i\u0026gt; \u0026lt;li\u0026gt;把冰箱门关上\u0026lt;/1i\u0026gt; \u0026lt;/ol\u0026gt; 无序列表\n概念：无顺序或不侧重顺序的列表。\n1 2 3 4 5 6 7 \u0026lt;h2\u0026gt;我想去的几个城市\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;1i\u0026gt;成都\u0026lt;/1i\u0026gt; \u0026lt;li\u0026gt;上海\u0026lt;/li\u0026gt; \u0026lt;1i\u0026gt;西安\u0026lt;/1i\u0026gt; \u0026lt;li\u0026gt;武汉\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 列表嵌套\n概念：列表中的某项内容，又包含一个列表（注意：嵌套时，请务必把解构写完整）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;h2\u0026gt;Famous Player\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Manchester City\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;span\u0026gt;Manchester United\u0026lt;/span\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Bruno Fernandes\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Amd Diallo\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Andre Onana\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Liverpool\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Tottenham Hotspur\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 注意：li 标签最好写在 ul 或 ol 中，不要单独使用。\n自定义列表\n概念：所谓自定义列表，就是一个包含术语名称以及术语描述的列表。 一个 dl 就是一个自定义列表，一个 dt 就是一个术语名称，一个 dd 就是术语描述（可以有多个）。 1 2 3 4 5 6 7 8 9 10 \u0026lt;h2\u0026gt;如何高效的学习？\u0026lt;/h2\u0026gt; \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;做好笔记\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;笔记是我们以后复习的一个抓手\u0026lt;/dd\u0026gt; \u0026lt;dd\u0026gt;笔记可以是电子版，也可以是纸质版\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;多加练习\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;只有敲出来的代码，才是自己的\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;别怕出错\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;错很正常，改正后并记住，就是经验\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; 表格 基本结构\n一个完整的表格由：表格标题、表格头部、表格主体、表格脚注，四部分组成。\n表格涉及到的标签：\ntable：表格 caption ：表格标题 thead ：表格头部 tbody：表格主体 tfoot：表格注脚 tr：每一行 th、td：每一个单元格（备注：表格头部中用 th，表格主体、表格脚注中用：td） ![](https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/截屏2025-01-21 00.36.54.png)\n具体编码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 \u0026lt;table border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;!-- 表格标题--\u0026gt; \u0026lt;caption\u0026gt;学生信息\u0026lt;/caption\u0026gt; \u0026lt;!-- 表格头部--\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;性别\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;年龄\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;民族\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;政治面貌\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;!-- 表格主体--\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;张三\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;男\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;18\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;汉族\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;团员\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;李四\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;女\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;20\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;满族\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;群众\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;王五\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;男\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;20\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;回族\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;党员\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;赵六\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;女\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;21\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;壮族\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;团员\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;!-- 表格脚注--\u0026gt; \u0026lt;tfoot\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;共计：4人\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tfoot\u0026gt; \u0026lt;/table\u0026gt; 常用属性\n标签名 标签语义 常用属性 单/双标签 table 表格 width：设置表格宽度。height：设置表格最小高度，表格最终高度可能比设置的值大。border：设置表格边框宽度。cellspacing：设置单元格之间的间距。 双 thead 表格头部 height：设置表格头部高度。align：设置单元格的水平对齐方式，可选值如下：1. left：左对齐2. center ：中间对齐3. right ：右对齐valign：设置单元格的垂直对齐方式，可选值如下：1. top：顶部对齐2. middle：中间对齐3. bottom：底部对齐 双 tbody 表格主体 常用属性与 thead 相同。 双 tr 行 常用属性与 thead 相同。 双 tfoot 表格脚注 常用属性与 thead 相同。 双 td 普通单元格 width：设置单元格的宽度，同列所有单元格全都受影响。heigth：设置单元格的高度，同行所有单元格全都受影响。align：设置单元格的水平对齐方式。valign：设置单元格的垂直对齐方式。rowspan：指定要跨的行数。colspan：指定要跨的列数。 双 th 表头单元格 常用属性与 td 相同。 双 跨行跨列\nrowspan：指定要跨的行数。 colspan：指定要跨的列数。 课程表效果：\n编写思路：\n常用标签补充\n标签名 标签含义 单/双标签 br 换行 单 hr 分隔 单 pre 按原文显示（一般用于在页面中嵌入大段代码） 双 注意点：\n不要用 br 来增加文本之间的行间隔，应使用 p 元素，或后面即将学到的 css中的margin 属性。 hr 的语义是分隔，如果不想要语义，只是想画一条水平线，那么应当使用css完成。 表单 概念：一个包含交互的区域，用于收集用户提供的数据。\n基本结构 简单梳理：\n标签名 标签语义 常用属性 单/双标签 form 表单 action：用于指定表单的提交地址（需要与后端人员沟通后确定）。target：用于控制表单提交后，如何打开页面，常用值如下：* -self：在本窗口打开。* _blank：在新窗口打开。method：用于控制表单的提交方式，暂时只需了解，在后面Ajax的课程中，会详细讲解。 双 input 输入框 type：设置输入框的类型，目前用到的值是 text，表示普通文本。定）。name ：用于指定提交数据的名字，（需要与后端人员沟通后确任） 单 button 按钮 本小节暂不涉及 双 示例代码：\n1 2 3 4 \u0026lt;form action=\u0026#34;https://www.baidu.com/s\u0026#34; target=\u0026#34;_blank\u0026#34; method=\u0026#34;get\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;wd\u0026#34;\u0026gt; \u0026lt;button\u0026gt;去百度搜索\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; 常见表单控件 文本输入框 1 \u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt; 常用属性如下：\n* name 属性：数据的名称。 * value 属性：输入框的默认输入值。 * maxlength 属性：输入框最大可输入长度。 密码输入框\n1 \u0026lt;input type=\u0026#34;password\u0026#34;\u0026gt; 常用属性如下：\nname 属性：数据的名称。\nvalue 属性：输入框的默认输入值（一般不用，无意义）。\nmaxlength 属性：输入框最大可输入长度。\n单选框\n1 2 \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;female\u0026#34;\u0026gt;女 \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;male\u0026#34;\u0026gt;男 常用属性如下：\nname 属性：数据的名称，注意：想要单选效果，多个radio 的 name 属性值要保持一致。 value 属性：提交的数据值。 checked属性：让该单选按钮默认选中。 复选框\n1 2 3 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;smoke\u0026#34;\u0026gt;B费 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;drink\u0026#34;\u0026gt;利马 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;perm\u0026#34;\u0026gt;马兹拉维 常用属性如下：：\nname 属性：数据的名称。 value 属性：提交的数据值。 checked 属性：让该复选框默认选中。 隐藏域\n1 \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;tag\u0026#34; value=\u0026#34;100\u0026#34;\u0026gt; 用户不可见的一个输入区域，作用是：提交表单的时候，携带一些固定的数据。\nname 属性：指定数据的名称。 value 属性：指定的是真正提交的数据。 提交按钮\n1 \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;点我提交表单“\u0026gt;\u0026lt;button\u0026gt;点我提交表单\u0026lt;/button\u0026gt; 注意：\nbutton 标签 type 属性的默认值是submit。 button 不要指定 name 属性 input 标签编写的按钮，使用 value 属性指定按钮文字。 重制按钮\n1 2 \u0026lt;input type=\u0026#34;reset\u0026#34;value=\u0026#34;点我重置“\u0026gt; \u0026lt;button type=\u0026#34;reset\u0026#34;\u0026gt;点我重置\u0026lt;/button\u0026gt; 注意点：\nbutton 不要指定 name 属性 input 标签编写的按钮，使用 value 属性指定按钮文字。 普通按钮\n1 2 \u0026lt;input type=\u0026#34;button\u0026#34;value=\u0026#34;普通按钮\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34;\u0026gt;普通按钮\u0026lt;/button\u0026gt; 注意点：\n普通按钮的 type 值为 button，若不写 type 值是 submit 会引起表单的提交。 文本域\n1 \u0026lt;textarea name=\u0026#34;msg\u0026#34;rows=\u0026#34;22\u0026#34; cols=\u0026#34;3\u0026#34;\u0026gt;我是文本域\u0026lt;/textarea\u0026gt; 常用属性如下：\nrows 属性：指定默认显示的行数，会影响文本域的高度。 cols 属性：指定默认显示的列数，会影响文本域的宽度。 不能编写 type 属性，其他属性，与普通文本输入框一致。 下拉框\n1 2 3 4 5 6 \u0026lt;select name=\u0026#34;from\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;黑\u0026#34;\u0026gt;黑龙江\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;辽\u0026#34;\u0026gt;辽宁\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;吉\u0026#34;\u0026gt;吉林\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;粵\u0026#34;selected\u0026gt;广东\u0026lt;/option\u0026gt; \u0026lt;/ select\u0026gt; 常用属性及注意事项：\nname 属性：指定数据的名称。 option 标签设置 value 属性，如果沒有 value 属性，提交的数据是 option 中间的文字；如果设置了 value 属性，提交的数据就是 value 的值（建议设置 value 属性） option标签设置了 selected 属性，表示默认选中。 禁用表单控件\n给表单控件的标签设置 disabled 既可禁用表单控件。\ninput,textarea,button,select,option都可以设置 disabled 属性\nlabel标签\nlabel 标签可与表单控件相关联，关联之后点击文字，与之对应的表单控件就会获取焦点。 两种与 label 关联方式如下： 让 label 标签的 for 属性的值等于表单控件的id 把表单控件套在 label 标签的里面。 fieldset 与legend 的使用（了解）\nfieldset 可以为表单控件分组、legend 标签是分组的标题。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;fieldset\u0026gt; \u0026lt;legend\u0026gt;主要信息\u0026lt;/legend\u0026gt; \u0026lt;label for=\u0026#34;zhanghu\u0026#34;\u0026gt;账户：\u0026lt;/label\u0026gt; \u0026lt;input id=\u0026#34;zhanghu\u0026#34; type=\u0026#34;text\u0026#34; name=\u0026#34;account\u0026#34; maxlength=\u0026#34;10\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;label\u0026gt; 密码： \u0026lt;input id=\u0026#34;mima\u0026#34; type=\u0026#34;password\u0026#34; name=\u0026#34;pwd\u0026#34; maxlength=\u0026#34;6\u0026#34;\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;br\u0026gt; 性别： \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;male\u0026#34; id=\u0026#34;nan\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;nan\u0026#34;\u0026gt;H\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;female\u0026#34; id=\u0026#34;nv\u0026#34;\u0026gt;k \u0026lt;/label\u0026gt; \u0026lt;/fieldset\u0026gt; 表单总结\n标签名 标签语义 常用属性 form 表单 action 属性：表单要提交的地址。target 属性：要跳转的新地址打开位置；值：_self、_blankmethod 属性：请求方式，值：get、 post input 多种形式的表单控件 type 属性：指定表单控件的类型。值：text、password、radio、checkbox、hidden、submit、 resbutton 等。name 属性：指定数据名称value 属性：对于输入框：指定默认输入的值；对于单选和复选框：实际提交的数据；对于按钮：显示按钮文字。disabled 属性：设置表单控件不可用。maxlength 属性：用于输入框，设置最大可输入长度。checked 属性：用于单选按钮和复选框，默认选中 textarea 文本域 name 属性：指定数据名称roWS属性：指定默认显示的行数，影响文本域的高度。cols 属性：指定默认显示的列数，影响文本域的宽度。disabled 属性：设置表单控件不可用。 select 下拉框 name 属性：指定数据名称disabled 属性：设置整个下拉框不可用。 option 下拉框的选项 disabled 属性：设置拉下选项不可用。value 属性：该选项事件提交的数据（不指定value，会把标签中的内容作为提交数据）selected 属性：默认选中。 button 按钮 disabled 属性：设置按钮不可用。type 属性：设置按钮的类型，值：submit（默认）reset, button label 与表单控件做关联 for 属性：值与要关联的表单控件的ID值相同。 fieldset 表单边框 框架标签 标签名 功能和语义 属性 单/双标签 iframe 框架（在网页中嵌入其他文件） name：框架名字，可以与 target 属性配合。width：框架的宽。height：框架的高度。frameborder：是否显示边框，值：0或者1。 双 iframe 标签的实际应用：\n在网页中嵌入广告。\n与超链接或表单的 target 配合，展示不同的内容。\nHTML实体 在 HTML 中我们可以用一种特殊的形式的内容，来表示某个符号，这种特殊形式的内容，就是 HTML 实体。比如小于号**\u0026lt;**用于定义 HTML标签的开始。如果我们希望浏览器正确地显示这些字符，我们必须在 HTML 源码中插入字符实体。\n字符实体由三部分组成：一个\u0026amp; 和一个实体名称（或者一个 ＃ 和一个实体编号），最后加上一个分号；。\n常见字符实体总结：\n描述 实体名称 实体编号 空格 \u0026amp;nbsp; \u0026amp;#160 \u0026lt; 小于号 \u0026amp;lt; \u0026gt; 大于号 \u0026amp;gt; \u0026amp; 和号 \u0026amp;amp; ¥ 元 \u0026amp;yen; © 版权（copyright） \u0026amp;cppy; × 乘号 \u0026amp;times ÷ 除号 \u0026amp;divide; 完整实体列表，请参考：HTML Standard （whatwg.org）\nHTML全局属性 常用的全局属性：\n属性名 含义 id 给标签指定唯一标识，注意：id 是不能重复的。作用：可以让 label 标签与表单控件相关联；也可以与CSS、JavaScript 配合使用，。 class 给标签指定类名，随后通过 csS 就可以给标签设置样式。 style 给标签设置 CSS 样式。 dir 内容的方向，值：ltr、rtl title 给标签设置一个文字提示，一般超链接和图片用得比较多。 lang 给标签指定语言，具体规范和可选值请参考【10.HTML设置语言】。 完整的全局属性，请参考：全局属性 -HTML（超文本标记语言）|MDN （mozilla.org）\nmeta元信息 配置字符编码\n1 \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; 针对 IE 浏览器的兼容性配置\n1 \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; 针对移动端的配置(移动端课程中会详细讲解)\n1 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; 配置网页关键字\n1 \u0026lt;meta name=\u0026#34;keywords\u0026#34; content=\u0026#34;8-12个以英文逗号隔开的单词/词语\u0026#34;\u0026gt; 配置网页描述信息\n1 \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;80字以内的一段话，与网站内容相关\u0026#34;\u0026gt; 针对搜索引擎爬虫配置：\n1 \u0026lt;meta name=\u0026#34;robots\u0026#34;content=\u0026#34;此处可选值见下表\u0026#34;\u0026gt; 值 描述 index 允许搜索爬虫索引此页面。 noindex 要求搜索爬虫不索引此页面。 follow 允许搜索爬虫跟随此页面上的链接。 nofollow 要求搜索爬虫不跟随此页面上的链接。 all 与 index，follow 等价 none 与 noindex，nofollow 等价 noarchive 要求搜索引擎不缓存页面内容。 nocache noarchive 的替代名称。 配置网页作者：\n1 \u0026lt;meta name=\u0026#34;author\u0026#34; content=\u0026#34;tony\u0026#34;\u0026gt; 配置网页生成工具\n1 \u0026lt;meta name=\u0026#34;generator\u0026#34; content=\u0026#34;Visual Studio Code\u0026#34;\u0026gt; 配置定义网页版权信息：\n1 \u0026lt;meta name=\u0026#34;copyright\u0026#34; content=\u0026#34;2023-2027©版权所有\u0026#34;\u0026gt; 配置网页自动刷新\n1 \u0026lt;meta http-equiv=\u0026#34;refresh\u0026#34; content=\u0026#34;10;url=http://www.baidu.com\u0026#34;\u0026gt; 完整的网页元信息，请参考：文档级元数据元素|MDN\nHTML总结 CSS2基础 CSS基础 CSS简介 css的全称为：层叠样式表（Cascading Style Sheets ）。\ncss也是一种标记语言，用于给 HTML结构设置样式，例如：文字大小、颜色、元素宽高等等。\n简单理解：CSS 可以美化 HTML，让 HTML 更漂亮。\n核心思想：HTML 搭建结构，CSS 添加样式，实现了：结构与样式的分离。\nCSS的编写位置 行内样式 写在标签的style属性中（又称：内联样式）\n语法：\n1 \u0026lt;h1 style=\u0026#34;color:red;font-size:60px；\u0026#34;\u0026gt;欢迎来到尚硅谷学习\u0026lt;/h1\u0026gt; 注意点：\nstyle 属性的值不能随便写，写要符合CSS语法规范，是 名：值； 的形式。 行内样式表，只能控制当前标签的样式，对其他标签无效。 存在的问题：\n书写繁琐、样式不能复用、并且没有体现出：结构与样式分离 的思想，不推荐大量使用，只有对当前元素添加简单样式时，才偶尔使用。\n内部样式 写在 html 页面内部，将所有的 CSS 代码提取出来，单独放在 \u0026lt;style\u0026gt; 标签中。\n语法：\n1 2 3 4 5 6 \u0026lt;style\u0026gt; h1 { color: red; font-size: 40px; } \u0026lt;/style\u0026gt; 注意点：\n\u0026lt;style\u0026gt; 标签理论上可以放在 HTML 文档的任何地方，但一般都放在 \u0026lt;head\u0026gt; 标签中。 此种写法：样式可以复用、代码结构清晰。 存在的问题：\n并没有实现：结构与样式完全分离。\n多个 HTML 页面无法复用样式。\n外部样式 写在单独的 .css 文件中，随后在 HTML 文件中引入使用。\n语法：\n新建一个扩展名为 .css 的样式文件，把所有 CSS 代码都放入此文件中。\n1 2 3 4 h1 { color: red; font-size: 40px; } 在 HTML 文件中引入 .css 文件。\n1 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./xxx.css\u0026#34;\u0026gt; 注意点：\n\u0026lt;link＞标签要写在 \u0026lt;head\u0026gt; 标签中。\n\u0026lt;link\u0026gt; 标签属性说明：\nhref ：引入的文档来自于哪里。 rel:（relation：关系）说明引入的文档与当前文档之间的关系。 外部样式的优势：样式可以复用、结构清晰、可触发浏览器的缓存机制，提高访问速度，实现了结构与样式的完全分离。\n实际开发中，几乎都使用外部样式，这是最推荐的使用方式！\n样式表的优先级 优先级规则：行内样式\u0026gt;内部样式=外部样式 内部样式、外部样式，这二者的优先级相同，且：后面的 会覆盖前面的（简记：“后来者居上”）。 同一个样式表中，优先级也和编写顺序有关，且：后面的会覆盖前面的（简记：“后来者居上”）。 分类 优点 缺点 使用频率 作用范围 行内样式 优先级最高 1.结构与样式未分离2.代码结构混乱3. 样式不能复用 很低 当前标签 内部样式 1.样式可复用2.代码结构清晰 1.结构与样式未彻底分离2. 样式不能多页面复用 一般 当前页面 外部样式 1.样式可多页面复用2.代码结构清晰3.可触发浏览器的缓存机制4.结构与样式彻底分离 需要引入才能使用 最高 多个页面 CSS语法规范 CSS语法规范由两部分构成：\n选择器：找到要添加样式的元素。 声明块：设置具体的样式（声明块是由一个或多个声明组成的），声明的格式为：属性名：属性值； 备注1：最后一个声明后的分号理论上能省略，但最好还是写上。 备注2：选择器与声明块之间，属性名与属性值之间，均有一个空格，理论上能省略，但最好还是写上。 注释的写法：\n1 2 3 4 5 6 7 /* 给h1元素添加样式 */ h1｛ /* 设置文字颜色为红色 */ color: red; /* 设置文字大小为40px */ font-size: 40px } CSS代码风格 展开风格\u0026ndash;开发时推荐，便于维护和调试。\n1 2 3 4 h1 { color: red; font-size: 40px; } 紧凑风格 —-项目上线时推荐，可减小文件体积。\n备注：\n项目上线时，我们会通过工具将【展开风格】的代码，变成【紧凑风格】，这样可以減小文件体积，节约网络流量，同时也能让用户打开网页时速度更快。\nCSS选择器 CSS基本选择器 通配选择器 元素选择器 类选择器 id选择器 通配选择器 作用：可以选中所有的 HTML 元素。\n语法：\n1 2 3 *｛ 属性名：属性值； ｝ 举例：\n1 2 3 4 5 /* 选中所有元素 */ *｛ color: orange; font-size: 40px; } 备注：目前来看通配选择器貌似有点鸡肋，但后面清除样式时，会对我们有很大帮助，后面会详细讲。\n元素选择器 作用：为页面中 某种元素 统一设置样式。\n语法：\n1 2 3 标签名｛ 属性名：属性值； ｝ 举例：\n1 2 3 4 5 6 7 8 9 10 /* 选中所有h1元素*/ h1｛ color: orange; font-size: 40px; } /* 选中所有p元素 */ p｛ color: blue; font-size: 60px; } 备注：元素选择器无法实现差异化设置，例如上面的代码中，所有的 p 元素效果都一样。\n类选择器 作用：根据元素的 class 值，来选中某些元素。\nclass 翻译过来有：种类、类别的含义，所以 class 值，又称：类名。\n语法：\n1 2 3 .类名｛ 属性名：属性值； ｝ 举例：\n1 2 3 4 5 6 7 8 /* 选中所有class值为speak的元素 */ .speak { color: red; ｝ /* 选中所有class值为answer的元素 */ .answer { color: blue; } 注意点：\n元素的 class 属性值不带．，但 css 的类选择器要带．。 class 值，是我们自定义的，按照标准：不要使用纯数字、不要使用中文、尽量使用英文与数字的组合，若由多个单词组成，使用**-**做连接，例如：left-menu，且命名要有意义，做到“见名知意”。 一个元素不能写多个 class 属性，下面是 错误示例： 1 2 \u0026lt;！-- 该写法错误，元素的属性不能重复，后写的会失效 --\u0026gt; \u0026lt;h1 class=\u0026#34;speak\u0026#34; class=\u0026#34;big\u0026#34;\u0026gt;你好啊\u0026lt;/h1\u0026gt; 一个元素的 class 属性，能写多个值，要用空格隔开，例如： 1 2 \u0026lt;！-- 该写法正确，class属性，能写多个值--\u0026gt; \u0026lt;h1 class=\u0026#34;speak big\u0026#34;\u0026gt;你好啊\u0026lt;/h1\u0026gt; ID选择器 作用：根据元素的 id 属性值，来精准的选中某个元素。\n语法：\n1 2 3 #id值｛ 属性名：属性值； ｝ 举例：\n1 2 3 4 5 /* 选中id值为earthy的那个元素 */ #earthy { color: red; font-size: 60px; } 注意：\nid 属性值：尽量由字母、数字、下划线（_）、短杠（-）组成，最好以字母开头、不要包含空格、区分大小写。 一个元素只能拥有一个 id 属性，多个元素的 id 属性值不能相同。 一个元素可以同时拥有 id 和 class 属性。 基本选择器总结 基本选择器 特点 用法 通配选择器 选中所有标签，一般用于清除样式。 * {color:red} 元素选择器 选中所有同种标签，但是不能差异化选择。 h1 {color:red} 类选择器 选中所有特定类名（class 值）的元素——使用频率很高。 .say {color:red} ID选择器 选中特定 id值的那个元素（唯一的）。 #earthy {color:red} CSS复合选择器 CSS选择器整体分类两大类：\n基本选择器：\n通配选择器 元素选择器 类选择器 ID 选择器 复合选择器\n交集选择器 并集选择器 后代选择器 子元素选择器 \u0026hellip; \u0026hellip;\n复合选择器建立在基本选择器之上，由多个基础选择器，通过不同的方式组合而成。 复合选择器可以在复杂结构中，快速而准确的选中元素。 交集选择器 作用：选中同时符合多个条件的元素。\n交集有并且的含义（通俗理解：即⋯⋯又⋯⋯⋯的意思），例如：年轻且长得帅。\n语法：选择器1选择器2选择器3..选择器n｛｝\n举例：\n1 2 3 4 5 6 7 8 /* 选中：类名为beauty的p元素，为此种写法用的非常多！！！！*/ p. beauty { color: blue; ｝ /* 选中：类名包含rich和beauty的元素 */ .rich.beauty｛ color: green; ｝ 注意：\n有标签名，标签名必须写在前面。\nid 选择器、通配选择器，理论上可以作为交集的条件，但实际应用中几乎不用——因为没有意义。\n交集选择器中 不可能 出现 两个元素选择器，因为一个元素，不可能即是 p 元素又是 span 元素。\n用的最多的交集选择器是：元素选择器配合类名选择器，例如：p.beauty。\n并集选择器 作用：选中多个选择器对应的元素，又称：分组选择器。\n所谓并集就是或者的含义（通俗理解：要么⋯要么.⋯的意思），例如：给我转10万块钱或者我报警。\n语法：选择器1，选择器2，选择器3，⋯选择器n｛｝\n多个选择器通过，连接，此处，的含义就是：或。\n举例：\n1 2 3 4 5 6 7 8 /* 选中id为peiqi，或类名为rich，或类名为beauty的元素 */ #peiqi, .rich, .beauty { font-size: 40px; background-color：skyblue； width: 200px; } 注意：\n并集选择器，我们一般竖着写。 任何形式的选择器，都可以作为并集选择器的一部分。 并集选择器，通常用于集体声明，可以缩小样式表体积。 HTML元素间的关系 分为：①父元素、②子元素、③祖先元素、④后代元素、⑤兄弟元素。\n父元素：直接包裹某个元素的元素，就是该元素的父元素。\n子元素：被父元素直接包含的元素（简记：儿子元素）。\n祖先元素：父亲的父亲一直往外找，都是祖先。\n备注：父元素，也算是祖先元素的一种。 例如：张三的父亲，也算是张三的祖先，但一般还是称呼：父亲。\n后代元素：儿子的儿子……一直往里找，都是后代。\n备注：子元素，也算是后代元素的一种。 例如：张三的儿子，也算是张三的后代，但一般还是称呼：儿子。\n兄弟元素：具有相同父元素的元素，互为兄弟元素。\n后代选择器 作用：选中指定元素中，符合要求的后代元素。\n语法：选择器1 选择器2选择器3..选择器n ｛｝（先写祖先，再写后代）\n选择器之间，用空格隔开，空格可以理解为：“xxx中的\u0026quot;，其实就是后代的意思。 选择器 1234•n，可以是我们之前学的任何一种选择器。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* 选中u1中的所有1i */ ul li { color: red; ｝ /* 选中u1中所有1i中的a*/ ul 1i a { color: orange; } /* 选中类名为subject元素中的所有1i */ .subject li.front-end { color: blue; ｝ /* 选中类名为subject元素中的所有类名为front-end的1i */ .subject li.front-end { color: blue; } 注意：\n后代选择器，最终选择的是后代，不选中祖先。 儿子、孙子、重孙子，都算是后代。 结构一定要符合之前讲的 HTML 嵌套要求，例如：不能 p 中写 h1 ~ h6 。 子代选择器 作用：选中指定元素中，符合要求的子元素（儿子元素）。（先写父，再写子）\n​\t子代选择器又称：子元素选择器、子选择器。\n语法：选择器1\u0026gt;选择器2\u0026gt;选择器3\u0026gt;.选择器n｛｝\n​\t选择器之间，用 \u0026gt; 隔开，\u0026gt; 可以理解为：“xxx 的子代\u0026quot;，其实就是儿子的意思。\n​\t选择器 1234\u0026hellip; \u0026hellip;n ，可以是我们之前学的任何一种选择器。\n注意：\n子代选择器，最终选择的是子代，不是父级。 子、孙子、重孙子、重重孙子… …统称后代！，子就是指儿子。 兄弟选择器 相邻兄弟选择器：\n作用：选中指定元素后，符合条件的相邻兄弟元素。\n所谓相邻，就是紧挨着他的下一个，简记：睡在我下铺的兄弟。\n语法：选择器1+选择器2 ｛｝。\n示例：\n1 2 3 4 /* 选中div后相邻的兄弟p元素 */ div+p｛ color:red; } 通用兄弟选择器：\n作用：选中指定元素后，符合条件的所有兄弟元素。（简记：睡在我下铺的所有兄弟）\n语法：选择器1~选择器2｛｝。\n实例：\n1 2 3 4 /* 选中div后的所有的兄弟P元素 */ div~p｛ color:red; } 注意：两种兄弟选择器，选择的是下面的兄弟。\n属性选择器 作用：选中属性值符合一定要求的元素。\n语法：\n［属性名] 选中 具有 某个属性的元素。 ［属性名=\u0026ldquo;值\u0026rdquo;］选中包含某个属性，且属性值等于指定值的元素。 ［属性名^=\u0026ldquo;值\u0026rdquo;]选中包含某个属性，且属性值以指定的值开头的元素。 ［属性名$=\u0026ldquo;值\u0026rdquo;]选中包含某个属性，且属性值以指定的值结尾的元素。 ［属性名*=”值”]选择包含某个属性，属性值包含指定值的元素。 举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* 选中具有title属性的元素 */ div[title]{color:red;} /* 选中title属性值为atguigu的元素 */ div[title=\u0026#34;atguigu\u0026#34;] {color:red;} /* 选中title属性值以a开头的元素 */ div[title^=\u0026#34;a\u0026#34;]{color:red;} /* 选中title属性值以u结尾的元素 */ div[title$=\u0026#34;u\u0026#34;]{color:red ;} /* 选中title属性值包含g的元素 */ div[title*=\u0026#34;g\u0026#34;]{color:red;} 伪类选择器 作用：选中特殊状态的元素。\n如何理解“伪”？一虚假的，不是真的。 如何理解“伪类”？一像类（class ），但不是类，是元素的一种特殊状态。\n常用的伪类选择器：\n动态伪类：\n：link 超链接未被访问的状态。\n：visited 超链接访问过的状态。\n：hover 鼠标悬停在元素上的状态。\n：active 元素激活的状态。\n什么是激活？——按下鼠标不松开。 注意点：遵循 LVHA 的顺序，即：link、visited、 hover、active。\n: focus 获取焦点的元素。\n表单类元素才能使用：focus 伪类。 当用户：点击元素、触摸元素、或通过键盘的“tab”键等方式，选择元素时，就是获得焦点。\n结构伪类\n常用的\n：first-child 所有兄弟元素中的第一个。 ：last-child 所有兄弟元素中的最后一个。 ：nth-child（n）所有兄弟元素中的第n个。 ：first-of-type 所有同类型兄弟元素中的第一个。 ：last-of-type 所有同类型兄弟元素中的最后一个。 ：nth-of-type（n）所有同类型兄弟元素中的第n个。 关于 n 的值：\n0 或不写：什么都选不中—-几乎不用。 n：选中所有子元素—-几乎不用。 1~正无穷的整数：选中对应序号的子元素。 2n 或 even：选中序号为偶数的子元素。 2n+1 或 odd ：选中序号为奇数的子元素。 -n+3 ：选中的是前3个。 了解即可：\n:nth-last-child（n）所有兄弟元素中的倒数第n个。 :nth-last-of-type（n）所有同类型兄弟元素中的 倒数第n个。 :only-child 选择没有兄弟的元素（独生子女）。 :only-of-type 选择没有同类型兄弟的元素。 :root 根元素。 :empty内容为空元素（空格也算内容）。 否定伪类\n:not（选择器）排除满足括号中条件的元素。 UI伪类\n:checked 被选中的复选框或单选按钮。 :enable 可用的表单元素（沒有 disabled 属性）。 :disabled 不可用的表单元素（有 disabled 属性）。 目标伪类\n:target 选中锚点指向的元素。 语言伪类\n：lang（）根据指定的语言选择元素（本质是看 lang 属性的值）。 伪元素选择器 作用：选中元素中的一些特殊位置。 常用伪元素： ::first-letter 选中元素中的第一个文字。 ::first-line 选中元素中的第一行文字。 ::selection 选中被鼠标选中的内容。 ::placeholder 选中输入框的提示文字。 ::before 在元素最开始的位置，创建一个子元素（必须用 content 属性指定内容）。 ::after 在元素最后的位置，创建一个子元素（必须用 content 属性指定内容）。 选择器的优先级 通过不同的选择器，选中相同的元素，并且为相同的样式名设置不同的值时，就发生了样式的冲突。到底应用哪个样式，此时就需要看优先级了。\n简单描述 ","date":"2024-11-12T20:43:19+08:00","permalink":"http://localhost:1313/p/html%E5%92%8Ccss/","title":"HTML和CSS"},{"content":"MarkDown语法 Markdown 致力于使阅读和创作文档变得容易。\nMarkdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。\nMarkdown的文件通常以.md或.markdown为扩展名\n我们可以创建一个TXT文本文档，然后将其后缀改为.md即可开始编辑此Markdown文档。\n基础语法讲解 首先我们需要一个软件来书写markdown，一般选择Typora，另外，Idea也支持Typora。\n段落和换行 换行效果： 在上一行的末尾连续添加两个空格，然后再换行。 换段效果： 连续换两行。 加粗和斜体 想要使得文本加粗，我们只需要在需要加粗文本两边添加两个星号即可，或是使用两个下划线，效果相同 斜体与加粗类似，我们只需在需要斜体的文本两边添加一个星号即可，同样也可以使用一个下划线代替，效果相同。 如果需要同时使用加粗和斜体，我们可以直接使用连续的三个星号或是下划线。 和c语言一样，如果知识单纯想使用*等符号，可以使用转义字符，也就是在前面加上反斜杠\u0026quot;\u0026quot;。 删除线 实现删除线的效果，我们只需要在需要加删除线的文本两边添加两个~波浪线即可 下划线 在markdown原生语法中是没有下划线的，但可以借助于HTML中的语法，也就是\u0026hellip;..这样的形式。 分割线 单独使用三个星号即可实现，同样，下划线也可以。 标题 可以使用#井号来实现标题，两个井号代表二级标题，以此类推。 还有另外一种方式，可以在一段文字下面打上=等号和-减号分别代表一级标题和二级标题快速创建。 列表 要创建一个无序列表，我们只需要使用星号作为前缀，注意需要空格,可以用+加号和-减号来代替，但是，如果混用会显示为几个不同的列表。 如果想要创建一个带有数字的有序列表，可以用数字加点的形式来实现。 在列表中换行同样需要像普通文本那样，如果只是单纯换行编写，会被认为是一个空格；如果是在末尾添加两个空格再换行，会被认为是在列表项内换行；只有两个连续的换行才能脱离列表，作为新的段落开始编写。 列表可以设置层级嵌套，可以在一级列表下创建二级列表，需要在前面添加两个或四个空格（也可以是一个TAB缩进）。 勾选框 勾选框：需要在列表的形式下添加一个方括号，方括号里加x则代表此勾选框已勾选。 代码块 要创建一个代码块，只需要在本行的最前面添加四个空格即可，注意代码块要与上面的其他文本隔开一行。 还有另一种更加简便的方法，可以用三个连续的`符号将代码块包起来即可。 在三个`后可以添加语言名称，markdown编辑器可以进行识别。 引用 使用\u0026gt;大于符号进行引用 和列表一样，也需要进行两次换行脱离引用块。 引用中，可以进行嵌套，例如列表和代码块，甚至引用本身。 链接 在Markdown文档中插入超链接，只需要使用[]和()组合就能完成，格式为[链接文本](链接地址)。 有些时候可能我们的文档中有很多链接，甚至还有重复，此时一个一个编写相当费时间，而且源代码中满屏的链接显得相当杂乱，我们可以利用变量来优化这种情况，变量可以在文章的末尾再确定值。 图片 语法于链接类似：!图片描述 注意：只能使用本地图片地址或是网络图片地址。 图片和链接一样，都可以使用变量。 脚注 语法：曼联[^1]又赢了✌️。 [^1]: 世界上最好的俱乐部。 鼠标移动上去时也会展示脚注内容。 表格 Eg.| 名称 | 年龄 | 性别 | | \u0026mdash; | \u0026mdash; | \u0026mdash; | 最上一排就是表头，需要在左右使用|表示这是一个表格，同时，下方需要添加分割线，分割线使用-减号表示，写一个或多个都可以，推荐与表的宽度一致，更加美观。这样，就可以顺利展示为一个表格了 :\u0026mdash; 为左对齐 \u0026mdash;: 为右对齐 :\u0026mdash;: 为居中对齐 表格中也可以嵌套使用诸如加粗、斜体、行内代码块这类Markdown语法 HTML标签 markdown中可以支持HTML中的一些语法 内嵌iframe页面，可以实现B站视频播放 其他扩展语法 文本高亮，使用两个=等号包括 文本的上标和下标分别可以使用单个^和~包括来实现 数学公式语法 公式块 需要编写数学公式，我们同样需要在特定的块中编写，公式块使用$美元符表示。多行公式使用连续的两个美元符 行内编写，一行内容只需要使用一个美元符包括即可 特殊数学符号 代码 符号 描述 \\not= ≠ 不等于 \\approx ≈ 约等于 \\times × 乘号 ｜\\div ÷ 除号 \\leq ≤ 小于等于 \\geq ≥ 大于等于 \\pm ± 正负号 \\sum ∑ 求和符号（累加） \\prod ∏ 累乘 \\coprod ∐ 累除 \\overline{a + b + c} 平均值 数学中常见特殊字符: 代码 符号 代码 符号 \\alpha α \\beta β \\gamma γ \\delta δ ｜\\epsilon ϵ \\eta η \\theta θ \\pi π \\omega ω \\rho ρ \\sigma σ \\mu μ 还有我们数学中常见的三角函数相关: 代码 符号 描述 \\sin sin 正弦 \\cos cos 余弦 \\tan tan 正切 \\cot cot 余切 \\sec sec 正割 \\csc csc 余割 \\circ ∘ 度 积分和求导相关: 代码 符号 描述 \\infty ∞ 无穷 \\int ∫ 定积分 \\iint ∬ 双重积分 \\iiint ∭ 三重积分 \\oint ∮ 曲线积分 x\\prime x′ 求导 \\lim lim 极限 集合相关: 代码 符号 描述 \\emptyset ∅ 空集 \\in ∈ 不属于 \\notin ∉ 双重积分 \\supset ⊃ 真包含 \\supseteq ⊇ 包含 \\bigcap ⋂ 交集 \\bigcup ⋃ 并集 对数函数相关： 代码 符号 描述 \\log log 对数函数 \\ln ln 以e为底的对数函数 \\lg lg 以10为底的对数函数 分数 格式：$ \\frac{分子}{分母} $ 开方 格式：$\\sqrt{4}$ 若要修改几次根号：$\\sqrt[3]{8}$ 上下标 在公式块中的上下标与Markdown中的不同，语法也不一样，其中^表示上标， _ 表示下标 如果上标或下标内容多于一个字符，需要使用 {} 括起来，包括后续的其他代码如果出现只有一个字符生效的情况下，考虑使用花括号包括全部内容 积分和极限 积分格式：$ \\int_1^2xdx $ 极限格式：$ \\lim_{n\\rightarrow+\\infty}\\frac{1}{n + 1} $ 其他符号 向量符号：$ \\vec{a} $ 省略号：$ \\cdots $ 居中省略号 $ \\ldots $ 靠底部的省略号 点乘号：$ \\cdot $ 累加：$ \\sum_1^n $ ","date":"2024-11-12T20:43:19+08:00","permalink":"http://localhost:1313/p/mark-down%E8%AF%AD%E6%B3%95/","title":"Mark Down语法"},{"content":"第0章_写在前面 一、MySQL数据库基础篇大纲 MySQL数据库基础篇分为5个篇章：\n1.数据库概述与MySQL安装篇 第01章：数据库概述 第02章：MySQL环境搭建 2.SQL之SELECT使用篇 第03章：基本的SELECT语句 第04章：运算符 第05章：排序与分页 第06章：多表 询 第07章：单行函数 第08章：聚合函数 第09章：子查询 3.SQL之DDL、DML、DCL使用篇 第10章：创建和管理表 第11章：数据处理之增删改 第12章：MySQL数据类型精讲 第13章：约束 4.其它数据库对象篇 第14章：视图 第15章：存储过程与函数 第16章：变量、流程控制与游标 第17章：触发器 5.MySQL8新特性篇 第18章：MySQL8其它新特性 二、MySQL高级特性篇大纲 1.MySQL架构篇 第01章：Linux下MySQL的安装与使用 第02章：MySQL的数据目录 第03章：用户与权限管理 第04章：逻辑架构 第05章：存储引擎 第06章：InnoDB数据页结构 2.索引及调优篇 第07章：索引 第08章：性能分析工具的使用 第09章：索引优化与SQL优化 第10章：数据库的设计规范 第11章：数据库其他调优策略 3.事务篇 第12章：事务基础知识 第13章：MySQL事务日志 第14章：锁 第15章：多版本并发控制（MVCC） 4.日志与备份篇 第16章：其它数据库日志 第17章：主从复制 第18章：数据库备份与恢复 三、MySQL高手是怎样炼成的 mysql服务器的安装配置 SQL编程（自定义函数、存储过程、触发器、定时任务） 数据库索引建立 SQL语句优化 数据库内部结构和原理 数据库的性能监控分析与系统优化 各种参数常量设定数据库建模优化 主从复制 分布式架构搭建、垂直切割和水平切割 MyCat 数据迁移 容灾备份和恢复 对开源数据库进行二次开发 ","date":"2024-11-12T20:43:19+08:00","permalink":"http://localhost:1313/p/mysql/","title":"Mysql"},{"content":"数据结构基本概念 数据 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。 数据元素、数据项 数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。 一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。 数据结构、数据对象： 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。 数据对象是具有相同性质的数据元素的集合，是数据的一个子集。 数据结构的三要素 逻辑结构，物理结构（存储结构），数据的运算。 逻辑结构 集合：各个元素同属一个集合，别无其他关系 线性结构：数据元素之间是一对一的关系。除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继 树形结构：数据元素之间是一对多的关系 图结构：数据元素之间是多对多的关系 物理结构（存储结构） 顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储 单元的邻接关系来体现。 链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。 索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址） 散列存储。根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储 其中，链式存储、索引存储、散列存储也并称为非顺序存储\n以下几点需要注意 若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用 非顺序存储，则各个数据元素在物理上可以是离散的。 数据的存储结构会影响存储空间分配的方便程度 数据的存储结构会影响对数据运算的速度 数据的运算 施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的， 指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。\n数据类型、抽象数据类型 数据类型是一个值的集合和定义在此集合上的一组操作的总称。 1）原子类型。其值不可再分的数据类型。 2）结构类型。其值可以再分解为若干成分（分量）的数据类型。 抽象数据类型（Abstract Data Type，ADT）是抽象数据组织及与之相关的操作。\nADT 用数学化的语言定义数据的逻辑结构、定义运算。与具体的实现无关。 算法的基本概念 什么是算法 程序 = 数据结构（如何用数据正确地描述现实世界的问题，并存入计算机） + 算法（如何高效地处理这些数据，以解决实际问题） 算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令 表示一个或多个操作 算法的特性 有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。用有限步骤解决某个特定的问题 注：算法必须是有穷的，而程序可以是无穷的 确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。 “好”算法的特性 设计算法时尽量遵循的目标\n正确性。算法应能够正确地解决求解问题。 可读性。算法应具有良好的可读性，以帮助人们理解。 健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。 高效率与低存储量需求 算法效率的度量 如何评估算法时间开销 算法时间复杂度： 事前预估算法时间开销T(n)与问题规模 n 的关系（T 表示 “time”） 例子：用算法表白——“爱你n遍” 1 2 3 4 5 6 7 8 void loveyou(int n){ ①int i; ②while(i\u0026lt;=n){ ③i++; ④cout\u0026lt;\u0026lt;\u0026#34;I Love You %d\u0026#34;\u0026lt;\u0026lt;endl; } ⑤cout\u0026lt;\u0026lt;\u0026#34;I Love You More Than %d\u0026#34;\u0026lt;\u0026lt;endl; } 语句频度： ① ——1次 ② ——3001次 ③④ ——3000次 ⑤ ——1次 T(3000) = 1 + 3001 + 2*3000 + 1 时间开销与问题规模 n 的关系： T(n)=3n+3\n结论：1.可以只考虑阶数高的部分\n2.问题规模足够大时，常数项系数也可以忽略 加法规则和乘法规则 a）加法规则 T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n))) b）乘法规则 T(n) = T1(n)×T2(n) = O(f(n))×O(g(n)) = O(f(n)×g(n)) Eg：T3(n)= n3 + n2 log2n = O(n3) + O(n2 log2n) = ？？？\n1.顺序执行的代码只会影响常数项，可以忽略 2.只需挑循环中的一个基本操作分析它的执行次数与 n 的关系即可 3.如果有多层嵌套循环，只需关注最深层循环循环了几次 最坏时间复杂度：最坏情况下算法的时间复杂度 平均时间复杂度：所有输入示例等概率出现的情况下，算法的期望运行时间 最好时间复杂度：最好情况下算法的时间复杂度 程序运行时的内存需求 无论问题规模怎么变，算法运行所需的内存空间都是固定的常量，算法空间复杂度为S(n) = O(1) 注：S 表示 “Space”算法原地工作——算法所需内存空间为常量 O(1) \u0026lt; O(log2n) \u0026lt; O(n) \u0026lt; O(nlog2n) \u0026lt; O(n2) \u0026lt; O(n3) \u0026lt; O(2n) \u0026lt; O(n!) \u0026lt; O(nn) 函数递归带来的内存开销 空间复杂度 = 递归调用的深度\n线性表 线性表定义、基本操作 定义 线性表是具有相同数据类型的n（n≥0）个数据元素的有限 序列，其中n为表长，当n = 0时线 性表是一个空表。若用L命名线性表，则其一般表示为L = (a1, a2, \u0026hellip; , ai, ai+1, \u0026hellip; , an)\n几个概念： ai 是线性表中的“第i个”元素线性表中的位序 a1 是表头元素；an 是表尾元素。 除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继 a1 a2 a3 a4 a5\n有次序 注意：位序从1开始 数组下标从0开始 每个数据元素所占空间一样大\n基本操作 InitList(\u0026amp;L):初始化表。构造一个空的线性表L，分配内存空间。\nDestroyList(\u0026amp;L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。\nListInsert(\u0026amp;L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e。\nListDelete(\u0026amp;L,i,\u0026amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。\nLocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。\nGetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。\n其他常用操作：\nLength(L)：求表长。返回线性表L的长度，即L中数据元素的个数。\nPrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值。\nEmpty(L)：判空操作。若L为空表，则返回true，否则返回false。\nKey：命名要有可读性\nTips： ①对数据的操作（记忆思路） —— 创销、增删改查 ②C语言函数的定义 —— \u0026lt;返回值类型\u0026gt; 函数名 (\u0026lt;参数1类型\u0026gt; 参数1，\u0026lt;参数2类型\u0026gt; 参数2，\u0026hellip;\u0026hellip;) ③实际开发中，可根据实际需求定义其他的基本操作 ④函数名和参数的形式、命名都可改变（Reference：严蔚敏版《数据结构》） ⑤什么时候要传入引用“\u0026amp;” —— 对参数的修改结果需要“带回来”\n顺序表的定义 线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列。\n顺序表——用顺序存储的方式实现线性表顺序存储。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。 顺序表的实现\u0026ndash;静态分配 代码实现： 1 2 3 4 5 #define MaxSize 10 //定义最大长度 typedef struct{ ElemType data[MaxSize]; //用静态的“数组”存放数据元素 int length; //顺序表的当前长度 }SqList; //顺序表的类型定义（静态分配方式） InitList函数（静态分配） 1 2 3 4 5 6 void InitList(SqList \u0026amp;L){ for(int i=0;i\u0026lt;MaxSize;i++){ data[i]=0; } L.length=0; } 注意：如果不进行初始化，内存中会有遗留的“脏数据”，但其实如果正常访问的话（指在进行访问数据的时候，没有赋值的不去访问），也不会有影响，也可以直接把长度设为零即可。\n顺序表的实现\u0026ndash;动态分配 代码实现： 1 2 3 4 5 6 #define InitSize 10 //顺序表的初始长度 typedef struct{ ElemType *data; //指示动态分配数组的指针 int MaxSize; //顺序表的最大容量 int length; //顺序表的当前长度 } SeqList; //顺序表的类型定义（动态分配方式） malloc函数 L.data = (ElemType *) malloc (sizeof(ElemType) * InitSize) 注：需要包含头文件\u0026lt;stdlib.h\u0026gt; InitList函数（动态分配） 1 2 3 4 5 void InitLIst(SqList \u0026amp;L){ L.data=(int *)malloc(InitSize*sizeof(int)); L.length=0; L.Maxsize=InitSize; } IncreaseSize函数（动态分配）（增加数组的长度） 1 2 3 4 5 6 7 8 9 void IncreaseSize(SqList \u0026amp;L,int len){ int *p=L.data; L.data=(int *)malloc((L.MaxSize+len)*sizeof(int)); for(int i=0;i\u0026lt;L.length;i++){ L.data[i]=p[i]; } L.MaxSize+=len; free(p); } 顺序表的特点： ①随机访问，即可以在 O(1) 时间内找到第 i 个元素。 ②存储密度高，每个节点只存储数据元素 ③拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高） ④插入、删除操作不方便，需要移动大量元素 顺序表的插入与删除 顺序表的基本操作\u0026ndash;插入 ListInsert(\u0026amp;L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e。 注：本节代码建立在顺序表的“静态分配”实现方式之上，“动态分配” 也雷同。\n1 2 3 4 5 6 7 8 9 bool ListInsert(SqList \u0026amp;L,int i,int e){ if(i\u0026lt;1||i\u0026gt;L.length+1) return false;//判断i的值是否有效 if(L.length\u0026gt;L.MaxSize) return true;//当前存储空间已满，不能插入 for(int j=L.length;j\u0026gt;=i;j--) L.data[j]=L.data[j-1]; L.data[i-1]=e; L.length++; return true; } 注：好的算法，应该具有“健壮性”。能处理异常情况，并给使用者反馈\n时间复杂度的计算： 最好情况：新元素插入到表尾，不需要移动元素 i = n+1，循环0次；最好时间复杂度 = O(1) 最坏情况：新元素插入到表头，需要将原有的 n 个元素全都向后移动 i = 1，循环 n 次；最坏时间复杂度 = O(n); 平均情况：假设新元素插入到任何一个位置的概率相同，即 i = 1,2,3, \u0026hellip; , length+1 平均时间复杂度 = O(n) 顺序表的基本操作\u0026ndash;删除 ListDelete(\u0026amp;L,i,\u0026amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。\n1 2 3 4 5 6 7 8 9 bool ListDelete(SqList \u0026amp;L,int i,int \u0026amp;e){ if(i\u0026lt;1||i\u0026gt;L.length) return false; e=L.data[i]; for(int j=i;j\u0026lt;L.length;j++){ L.data[j-1]=L.data[j]; } L.length--; return true; } 顺序表的查找 按位查找 GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。\n静态分配 1 2 3 4 5 6 7 8 #define MaxSize 10 //定义最大长度 typedef struct{ ElemType data[MaxSize]; //用静态的“数组”存放数据元素 int length; //顺序表的当前长度 }SqList; ElemType GetElem(SqList L, int i){ return L.data[i-1]; } 动态分配 1 2 3 4 5 6 7 8 9 #define InitSize 10 //顺序表的初始长度 typedef struct{ ElemType *data; //指示动态分配数组的指针 int MaxSize; //顺序表的最大容量 int length; //顺序表的当前长度 } SeqList; //顺序表的类型定义（动态分配方式） ElemType GetElem(SeqList L, int i){ return L.data[i-1]; } 注意，时间复杂度为O(1)\n按值查找 LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。\n静态分配 1 2 3 4 5 6 int LocateElem(SeqList L,ElemType e){ for(int i=0;i\u0026lt;L.length;i++) if(L.data[i]==e) return i+1; //数组下标为i的元素值等于e，返回其位序i+1 return 0; //退出循环，说明查找失败 } 动态分配 1 2 3 4 5 6 int LocateElem(SeqList L,int e){ for(int i=0;i\u0026lt;L.length;i++) if(L.data[i]==e) return i+1; return 0; } 单链表的定义 顺序表与单链表的优缺点 顺序表：优点：可随机存取，存储密度高 缺点：要求大片连续空间，改变容量不方便 单链表：优点：不要求大片连续空间，改变容量方便 缺点：不可随机存取，要耗费一定空间存放指针 单链表的代码实现 1 2 3 4 struct LNode*{ ElemType data; struct LNode* next; }LNode,LinkList; 增加一个新的结点：在内存中申请一个结点所需空间，并用指针 p 指向这个结点 struct LNode * p = (struct LNode *) malloc(sizeof(struct LNode)); typedef 关键字 —— 数据类型重命名 typedef \u0026lt;数据类型\u0026gt; \u0026lt;别名\u0026gt; 强调这是一个单链表 ——使用 LinkList 强调这是一个结点 ——使用 LNode * GetElem函数的代码实现（更好地理解LNode *和LinkList) 1 2 3 4 5 6 7 8 9 10 11 LNode *GetElem(LinkList L,int i){ int j=1; LNode *p=L-\u0026gt;next; if(i==0) return L; if(i\u0026lt;1) return NULL; while(p!=NULL \u0026amp;\u0026amp; j\u0026lt;i){ p=p-\u0026gt;next; j++ } return p; } 头插法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 LinkList List_HeadInsert(LinkList \u0026amp;L){//逆向建立单链表 LNode *s; int x; L=(LinkList)malloc(sizeof(LNode));//创建头结点 L-next=NULL;//初始化为空链表 cin\u0026gt;\u0026gt;x;//输入结点的值 while(x!=9999）{//输入9999表示结束 s=(LNode *)malloc(sizeof(LNode));//创建新结点 s-\u0026gt;data=x; s-\u0026gt;next=L-\u0026gt;next; L-\u0026gt;next=s;//将新结点插入表中，L为头指针 cin\u0026gt;\u0026gt;x; } return L; } 不带头结点的单链表与带头结点的单链表 带头结点，写代码更方便，用过都说好 初始化代码实现\n1 2 3 4 bool InitList(LinkList \u0026amp;L){ L=NULL; return true } 判空代码实现\n1 2 bool Empty(LinkList \u0026amp;L){ return (L==NULL) 不带头结点，写代码更麻烦对第一个数据结点和后续数据结点的处理需要用不同的代码逻辑对空表和非空表的处理需要用不同的代码逻辑 初始化代码实现\n1 2 3 4 5 bool InitList(LinkList \u0026amp;L){ L=(LNode *)malloc(sizeof(LNode));//分配一个头结点 if(L=NULL) return false;//内存不足，分配失败 L-\u0026gt;next=NULL；//头结点暂时还没有结点 return true; 判空代码实现\n1 2 3 bool Empty(LinkList \u0026amp;L){ return (L-\u0026gt;next==NULL) } 单链表的插入与删除 按位序插入（带头结点） ListInsert(\u0026amp;L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 bool ListInsert(LinkList \u0026amp;L,int i,ElemType e){ if(i\u0026lt;1) return false; LNode *p; int j=0; p=L; while(p!=NULL \u0026amp;\u0026amp; j=i-1){ p=p-\u0026gt;next; j++; } if(p==NULL) return false; LNOde *s=(LNode *)malloc(sizeof(LNode)); s-\u0026gt;data=e; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; return true; 按位序插入（不带头结点） 不存在 “第0个”结点，因此 i=1 时需要特殊处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 bool ListInsert(LinkList \u0026amp;L,int i,ElemType e){ if(i\u0026lt;1) return false; if(i==1){ LNode *s=(LNode *)malloc(sizeof(LNode)); s-\u0026gt;data=e; s-\u0026gt;next=L-\u0026gt;next; L=s; return true; } LNode *p; int j=0; p=L; while(p!=NULL \u0026amp;\u0026amp; j=i-1){ p=p-\u0026gt;next; j++; } if(p==NULL) return false; LNOde *s=(LNode *)malloc(sizeof(LNode)); s-\u0026gt;data=e; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; return true; 指定结点的后插操作 1 2 3 4 5 6 7 8 9 10 bool InsertNextNode(LNode *p,ElemType e){ if(p==NULL) return false; LNode *s=(LNode *)malloc(sizeof(LNode)); if(s==NULL) return false;//内存分配失败 s-\u0026gt;data=e; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; return true; 指定结点的前插操作 1 2 3 4 5 6 7 8 9 10 11 12 bool InsertPriorNode(LNode *p,ElemType e){ if(p==NULL) return false; LNode *s=(LNode *)malloc(sizeof(LNode)); if(s==NULL) return false;//内存分配失败 s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; s-\u0026gt;data=p-\u0026gt;data; p-\u0026gt;data=e; return true; } 王道书版本：\n1 2 3 4 5 6 7 8 9 10 bool InsertPriorNode(LNode *p,LNode *s){ if(p==NULL||s==NULL) return false; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; ElemType temp=p-\u0026gt;data; p-\u0026gt;data=s-\u0026gt;data; s-\u0026gt;data=temp; return true; } 按位序删除（带头结点） ListDelete(\u0026amp;L,i,\u0026amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 bool ListDelete(LinkList \u0026amp;L,int i,ElemType \u0026amp;e){ if(i\u0026lt;1) return false; LNode *p; int j=0; p=L; while(p!=NULL \u0026amp;\u0026amp; j\u0026lt;i-1){//循环找到i-1个结点 p=p-\u0026gt;next; j++; } if(p==NULL) return false;//i值不合法 if(p-\u0026gt;next==NULL) return false;//i-1后已无其他结点 LNode *q=p-\u0026gt;next; e=q-\u0026gt;data; p-\u0026gt;next=q-\u0026gt;next; free(q); return true; } 指定结点的删除 ListDelete(LNode *p)：删除指定结点p。\n1 2 3 4 5 6 7 8 9 bool ListDelete(LNode *p){ if(p==NULL) return false; LNode *q=p-\u0026gt;next; p-\u0026gt;data=q-\u0026gt;next-\u0026gt;data; p-next=q-\u0026gt;next; free(q); return true; } 注意：如果p是最后一个结点\u0026hellip;只能从表头开始依次寻找p的前驱，时间复杂度 O(n)\n单链表的查找 按位查找 GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。\n1 2 3 4 5 6 7 8 9 10 11 LNode *GetElem(LinkList L,int i){ if(i\u0026lt;0) return false; LNode *p; int j=0; p=L; while(p!=NULL \u0026amp;\u0026amp; j\u0026lt;i){//循环找到i个结点 p=p-\u0026gt;next; j++; } return p; } 王道书版本：\n1 2 3 4 5 6 7 8 9 10 11 LNode *GetElem(LinkList L,int i){ int j=1; p=L-\u0026gt;next; if(i==0) return L; if(i\u0026lt;1) return NULL; while(p!=NULL \u0026amp;\u0026amp; j\u0026lt;i){ p=p-\u0026gt;next; j++; } return p; } 按值查找 LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。\n1 2 3 4 5 6 7 LNode *LocateElem(LinkList L,ElemType e){ LNode *p=L-\u0026gt;next; while(p!=NULL \u0026amp;\u0026amp; p-\u0026gt;data!=e){ p=p-\u0026gt;next; } return p; } 求表的长度 1 2 3 4 5 6 7 8 9 int length(LinkList L){ int len=0; LNode *p=L; while(p-\u0026gt;next!=NULL){ p=p-\u0026gt;next; len++; } return len; } 单链表的建立 头插法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 LinkList List_HeadInsert(LinkList \u0026amp;L){ //逆向建立单链表 LNode *s; int x; L=(LinkList)malloc(sizeof(LNode)); //创建头结点 L-\u0026gt;next=NULL; //初始为空链表 cin\u0026gt;\u0026gt;x; //输入结点的值 while(x!=9999){ //输入9999表示结束 s=(LNode*)malloc(sizeof(LNode)); //创建新结点 s-\u0026gt;data=x; s-\u0026gt;next=L-\u0026gt;next; L-\u0026gt;next=s; //将新结点插入表中，L为头指针 cin\u0026gt;\u0026gt;x; } return L; } 尾插法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 LinkList List_TailInsert(LinkList \u0026amp;L){//正向建立单链表 int x; L=(LNode *)malloc(sizeof(LNode));//建立头结点（初始化空表） LNode *s,*r;=L;//r为表尾指针 cin\u0026gt;\u0026gt;x;//输入结点的值 while(x!=9999){//输入9999表示结束 s=(LNode *)malloc(sizeof(LNode)); s-\u0026gt;data=x; r-\u0026gt;next=s;//以上三步表示在r结点之后插入x r=s;//r指向新的结点 cin\u0026gt;\u0026gt;x; } r-\u0026gt;next=NULL;//尾指针置空 return L; } 头插法的重要应用：链表的逆置\n1 2 3 4 5 6 7 8 9 10 ListNode* reverseList(ListNode* head) { ListNode* newHead = nullptr;// 新链表头节点，初始为空 while (head) { ListNode* nextNode = head-\u0026gt;next;// 保存原链表的下一个节点 head-\u0026gt;next = newHead;// 当前节点插入到新链表头部 newHead = head;// 更新新链表的头节点 head = nextNode;// 移动到下一个节点 } return newHead; } 双链表 单链表和双链表的区别 单链表：无法逆向检索，有时候不太方便 双链表：可进可退，存储密度更低一丢丢 双链表的初始化（带头结点） 1 2 3 4 5 6 7 8 9 10 11 typedef struct DNode{ ElemType data; struct DNode *prior,*next; }DNode, *DLinkList; bool InitDLinkList(DLinkList \u0026amp;L){ L=(DNode *)malloc(sizeof(DNode));//建立头结点 if(L=NULL) return false; L-\u0026gt;prior=NULL;//prior永远指向NULL L-\u0026gt;next=NULL;//next后暂时还没有结点 return true; } 双链表的插入 1 2 3 4 5 6 7 8 9 10 11 12 bool InsertNextNode(DNode *p,DNode *s){ if(p==NULL||q==NULL){ return false; s-\u0026gt;next=p-\u0026gt;next; if(p-\u0026gt;next!=NULL){ p-\u0026gt;next-\u0026gt;prior=s; } s-\u0026gt;prior=p; p-\u0026gt;next=s; return true; } } 双链表的删除 删除p结点的后续结点 1 2 3 4 5 6 7 8 9 10 11 12 bool DeleteNextDNode(DNode *p){ if(p==NULL) return false; DNode *q=p-\u0026gt;next; if(q==NULL) return false;//p没有后继 p-\u0026gt;next=q-\u0026gt;next; if(q-\u0026gt;next!=NULL)//q结点不是最后一个结点 q-\u0026gt;next-\u0026gt;prior=p; free(q);//释放空间 return true; } 删除整个双链表 1 2 3 4 5 6 void DestroyList(DLinkList \u0026amp;L){ while(L-\u0026gt;next!=NULL) DeleteNextDNode(L);//循环释放各个结点 free(L);//释放头结点 L=NULL;//头指针指向NULL } 双链表的遍历 后向遍历 1 2 3 4 while(p!=NULL){ //对结点p做相应处理，如打印 p = p-\u0026gt;next; } 前向遍历 1 2 3 4 while(p!=NULL){ //对结点p做相应处理，如打印 p = p-\u0026gt;prior; } 前向遍历（不带头结点） 1 2 3 4 while(p-\u0026gt; prior != NULL){ //对结点p做相应处理 p = p-\u0026gt;prior; } 循环链表 循环单链表 循环单链表的特点：\n单链表：表尾结点的next指针指向 NULL 从一个结点出发只能找到后续的各个结点 循环单链表：表尾结点的next指针指向头结点 从一个结点出发可以找到其他任何一个结点 初始化循环单链表 1 2 3 4 5 6 7 bool InitList(LinkList \u0026amp;L){ L=(LNode *)malloc(sizeof(LNode)); if(L=NULL) return false; L-\u0026gt;next=L;//头结点next指向头结点 return true; } 判断循环单链表是否为空 1 2 3 4 5 6 7 bool Empty(LinkList L){ if(L-\u0026gt;next==L){ return true; } else return false; } 判断结点p是否为循环单链表的表尾结点 1 2 3 4 5 6 bool isTail(LinkList L,LNode *p){ if(p-\u0026gt;next==L) return true; else return false; } 循环双链表 双链表：表头结点的 prior 指向 NULL； 表尾结点的 next 指向 NULL 循环双链表：表头结点的 prior 指向表尾结点； 表尾结点的 next 指向头结点 初始化循环双链表 1 2 3 4 5 6 7 8 bool InitDList(DLinkList \u0026amp;L){ L=(DNode *)malloc(sizeof(DNode)); if(L=NULL) return false; L-\u0026gt;next=L; L-\u0026gt;prior=L; return true; } 判断循环单链表是否为空 1 2 3 4 5 6 7 bool Empty(DLinkList L){ if(L-\u0026gt;next==L){ return true; } else return false; } 判断结点p是否为循环单链表的表尾结点 1 2 3 4 5 6 bool isTail(DLinkList L,DNode *p){ if(p-\u0026gt;next==L) return true; else return false; } 静态链表 单链表：各个结点在内存中星罗棋布、散落天涯。 静态链表：分配一整片连续的内存空间，各个结 点集中安置。 静态链表的定义 1 2 3 4 5 #define MaxSize 10//静态链表的最大长度 typedef struct Node{//静态链表结构类型的定义 ElemType data;//存储数据元素 int next;//下一个元素的数组下标 }SLinkList[MaxSize]; SLinkList b —— 相当于定义了一个长度为 MaxSize 的 Node型数组\n基本操作的简述 初始化静态链表：把 a[0] 的 next 设为 -1，把其他结点的 next 设为一个特殊值用来表示结点空闲，如 -2 查找：从头结点出发挨个往后遍历结点 删除某个结点： ①从头结点出发找到前驱结点 ②修改前驱结点的游标 ③被删除结点 next 设为 -2 插入位序为i的结点：1.找到一个空的结点，存入数据元素 2.从头结点出发找到位序为i-1的结点 3.修改新结点的next 4.修改i-1号结点的next 静态链表的特点 静态链表：用数组的方式实现的链表 优点：增、删 操作不需要大量移动元素 缺点：不能随机存取，只能从头结点开始依次往后查找；容量固定不可变 适用场景：①不支持指针的低级语言；②数据元素数量固定不变的场景（如操作系统的文件分配表FAT）\n顺序表和链表的对比 逻辑结构 都属于线性表，都是线性结构\n存储结构 顺序表：优点：支持随机存取、存储密度高 缺点：大片连续空间分配不方便，改变容量不方便 链表：优点：离散的小空间分配方便，改变容量方便 缺点：不可随机存取，存储密度低 基本操作 顺序表：1.需要预分配大片连续空间。若分配空间过小，则之后不方便拓展容量；若分配空间过大，则浪费内存资源 2.插入/删除元素要将后续元素都后移/前移 3.时间复杂度 O(n)，时间开销主要来自移动元素 4.移动的时间代价很高 5.按位查找：O(1) 6.按值查找：O(n)若表内元素有序，可在O(log2n) 时间内找到 链表：1.只需分配一个头结点（也可以不要头结点，只声明一个头指针），之后方便拓展 2.插入/删除元素只需修改指针即可 3.时间复杂度 O(n)，时间开销主要来自查找目标元素 4.查找元素的时间代价更低 5.按位查找：O(n) 6.按值查找：O(n） 栈、队列和数组 栈的基本概念 线性表是具有相同数据类型的n（n≥0）个数据元素的有限 序列，其中n为表长，当n = 0时线 性表是一个空表。若用L命名线性表，则其一般表示为 L = (a1, a2, \u0026hellip; , ai, ai+1, \u0026hellip; , an) 栈（Stack）是只允许在一端进行插入或删除操作的线性表 栈的基本操作 InitStack(\u0026amp;S)：初始化栈。构造一个空栈 S，分配内存空间。\nDestroyStack(\u0026amp;S)：销毁栈。销毁并释放栈 S 所占用的内存空间。\nPush(\u0026amp;S,x)：进栈，若栈S未满，则将x加入使之成为新栈顶。\nPop(\u0026amp;S,\u0026amp;x)：出栈，若栈S非空，则弹出栈顶元素，并用x返回。\nGetTop(S, \u0026amp;x)：读栈顶元素。若栈 S 非空，则用 x 返回栈顶元素\n其他常用操作：\nStackEmpty(S)：判断一个栈 S 是否为空。若S为空，则返回true，否则返回false。\n常见问题：栈的进出栈问题 进栈顺序： a-\u0026gt;b-\u0026gt;c-\u0026gt;d-\u0026gt;e 有哪些合法的出栈顺序？ n个不同元素进栈，出栈元素不同排列的个数为1/n+1C2nn\n上述公式称为卡特兰（Catalan）数，可采用数学归纳法证明（不要求掌握）。\n顺序栈的实现 顺序栈的定义 1 2 3 4 5 #define MaxSize 10 typedef struct{ ElemType data[MaxSize];//静态数组中存放栈中元素 int top;//栈顶指针 }SqStack; 初始化操作 1 2 3 void InitStack(SqStack \u0026amp;S){ S.top=-1; } 判空操作 1 2 3 4 5 6 7 bool StackEmpty(SqStack S){ if(top==-1) return true; else return false; } 进栈操作 1 2 3 4 5 6 7 8 bool Push(SqStack \u0026amp;S,ElemType x){ if(S.top==MaxSize-1) return false;//栈满，操作失败 S.top+=1; S.data[S.top]=x; //这两步可以直接写为S.data[++S.top]=x return true; } 出栈操作 1 2 3 4 5 6 7 8 bool pop(SqStack \u0026amp;S,ElemType \u0026amp;x){ if(S.top==-1) return false;//栈空，报错 x=S.data[S.top]; S.top-=1; //这两步可以直接写为x=S.data[S.top--] return true; } 读栈顶元素 1 2 3 4 5 6 bool GetTop(SqStack \u0026amp;S,ElemType \u0026amp;x){ if(S.top==-1) return false; x=S.data[S.top]; return true; } 另一种方式 另一种方式就是把S.top的初始值设为0，其他地方一致\n共享栈 1 2 3 4 5 6 #define MaxSize 10 typedef struct{ ElemType data[MaxSize]; int top0;//0号栈栈顶指针 int top1;//1号栈栈顶指针 }ShStack; 初始化栈\n1 2 3 4 void InitStack(SqStack \u0026amp;S){ S.top0=-1; S.top1=MaxSize; } 注意！栈满的条件：top0 + 1 == top1\n链栈的实现 链栈的定义 1 2 3 4 typedef struct LinkNode{ ElemType data;//数据域 struct LinkNode *next;//指针域 }*LiStack;//栈类型定义 进栈/出栈都只能在栈顶一端进行（链头作为栈顶）\n队列的基本概念 队列的定义 队列（Queue）是只允许在一端进行插入，在另一端删除的线性表 队列的特点：先进先出 First In First Out（FIFO） 队头：允许删除的一端 队尾：允许插入的一端 队列的基本操作 InitQueue(\u0026amp;Q)：初始化队列，构造一个空队列Q。\nDestroyQueue(\u0026amp;Q)：销毁队列。销毁并释放队列Q所占用的内存空间。\nEnQueue(\u0026amp;Q,x)：入队，若队列Q未满，将x加入，使之成为新的队尾。\nDeQueue(\u0026amp;Q,\u0026amp;x)：出队，若队列Q非空，删除队头元素，并用x返回。\nGetHead(Q,\u0026amp;x)：读队头元素，若队列Q非空，则将队头元素赋值给x。\n其他常用操作：\nQueueEmpty(Q)：判队列空，若队列Q为空返回true，否则返回false。\n队列的顺序实现 顺序队列的定义 1 2 3 4 5 #define MaxSize 10 typedef struct{ ElemType data[MaxSzie];//用静态数组存放队列元素 int front,rear;//队头指针和队尾指针 }SqQueue; 注意：rear指向队尾元素的后一个位置（下一个应该插入的位置）\n初始化操作 1 2 3 void InitQueue(SqQueue \u0026amp;Q){ Q.front=Q.rear=0; } 判空操作 1 2 3 4 5 6 bool QueueEmpty(SqQueue \u0026amp;Q){ if(Q.rear==Q.front) return true; else return false; } 入队操作 1 2 3 4 5 6 7 bool EnQueue(SqQueue \u0026amp;Q,ElemType x){ if((Q.rear+1)%MaxSize==Q.front) return false; Q.data[Q.rear]=x; Q.rear=(Q.rear+1)%MaxSize; return true; } 队列已满的条件：队尾指针的再下一个位置是队头，即 (Q.rear+1)%MaxSize==Q.front\n判空操作 1 2 3 4 5 6 bool QueueEmpty(SqQueue Q){ if(Q.rear==Q.front) return true; else return false; } 出队操作 1 2 3 4 5 6 7 bool DeQueue(SqQueue \u0026amp;Q,ElemType \u0026amp;x){ if(Q.rear==Q.front) return false; x=Q.data[Q.front]; Q.front=(Q.front+1)\u0026amp;MaxSize; return true; } 获得对头元素的值，用x的值 1 2 3 4 5 6 bool GetHead(SqQueue Q,ElemType \u0026amp;x){ if(Q.rear==Q.front) return false; x=Q.data[Q.front]; return true; } 判断队列已满/已空 方案一 队列已满的条件：队尾指针的再下一个位置是队头，即(Q.rear+1)%MaxSize==Q.front 队空条件：Q.rear==Q.front 队列元素个数：(rear+MaxSize-front)%MaxSize 缺点：浪费了一个存储空间 方案二 定义数据结构时，多定义一个int类型的size，插入成功size++，插入失败size\u0026ndash; 队列已满的条件：size==MaxSize 队空条件：size==0 方案三 定义数据结构时，多定义一个int类型的tag，每次删除操作成功时，都令tag=0；每次插入操作成功时，都令tag=1；只有删除操作，才可能导致队空；只有插入操作，才可能导致队满 队满条件：front==rear \u0026amp;\u0026amp; tag == 1 队空条件：front==rear \u0026amp;\u0026amp; tag == 0 队列的链式实现 链式队列的定义 1 2 3 4 5 6 7 typedef struct LinkNode{ ElemType data; struct LinkNode *next }LinkNode; typedef struct{ LinkNode *front,*rear; }LinkQueue; 初始化链式队列（带头结点） 1 2 3 4 5 void InitQueue (LinkQueue \u0026amp;Q){ //初始时 front、rear 都指向头结点 Q. front=Q. rear=(LinkNode*)malloc(sizeof(LinkNode)); Q. front-\u0026gt;next=NULL; } 判空操作（带头结点） 1 2 3 4 5 6 bool IsEmpty (LinkQueue Q){ if(Q. front==Q. rear) return true; else return false; } 初始化链式队列（不带头结点） 1 2 3 4 5 void InitQueue (LinkQueue \u0026amp;Q){ //初始时front、rear都指向NULL Q. front=NULL; Q. rear=NULL; } 判空操作（不带头结点） 1 2 3 4 5 6 bool IsEmpty (LinkQueue Q){ if(Q.front==NULL) return true; else return false; } 入队（带头结点） 1 2 3 4 5 6 7 void EnQueue (LinkQueue \u0026amp;Q, ElemType x){ LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode)); s-\u0026gt;data=x; s-\u0026gt;next=NULL; Q.rear-\u0026gt;next=s;//新结点插入到rear之后 Q.rear=s;//修改表尾指针 } 入队（不带头结点） 1 2 3 4 5 6 7 8 9 10 11 12 void EnQueue(LinkQueue \u0026amp;Q, ElemType x){ LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode)); s-\u0026gt;data=x; s-\u0026gt;next=NULLi if(Q.front = NULL){//在空队列中插入第一个元素 Q.front = s; Q. rear=s;//修改队头队尾指针不带头结点的队列，第一个元素入队时需要特别处理 }else{ Q. rear-\u0026gt;next=s;//新结点插入到 rear 结点之后 Q. rear=s;//修改 rear 指针 } } 出队（带头结点） 1 2 3 4 5 6 7 8 9 10 11 bool DeQueue(LinkQueue \u0026amp;Q, ElemType \u0026amp;x){ if(Q.front==Q.rear) return false;//空队 LinkNode *p=Q.front-\u0026gt;next; x=p-\u0026gt;data;//用变量x返回队头元素 Q.front-\u0026gt;next=p-\u0026gt;next; //修改头结点的 next 指针 if(Q.rear==p)//此次是最后一个结点出队 Q. rear=Q. front;//修改 rear 指针 free(p);//释放结点空间 return true; } 出队（不带头结点） 1 2 3 4 5 6 7 8 9 10 11 12 13 bool DeQueue(LinkQueue \u0026amp;Q, ElemType \u0026amp;x){ if(Q. front==NULL) return false;//空队 LinkNode *p=Q.front;//p指向此次出队的结点 x=p-\u0026gt;data//用变量x返回队头元素 Q. front=p-\u0026gt;next;//修改 front 指针 if(Q. rear==p){//此次是最后一个结点出队 Q. front = NULL; Q. rear = NULL; } free (p);//释放结点空间 return true; } 队列满的条件 双端队列 ![](https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/截屏2024-12-02 18.46.59.png)\n判断输出序列的合法性 根据逻辑进行判断即可\n栈的应用\u0026ndash;括号匹配 最后出现的左括号最先被匹配(LIFO)，每出现一个右括号，就“消耗”（出栈）一个左括号\n算法流程图 算法实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool bracketCheck(char str[l, int length) { SqStack S; InitStack（S）； //初始化一个栈 for (int i=0; i\u0026lt;length; i++){ if （strlil==\u0026#39;（\u0026#39;|| strlil==\u0026#39;［\u0026#39;I| strli］==\u0026#39;｛\u0026#39;）｛ Push（S，str［i］）；//扫描到左括号，入栈 else 1 if(StackEmpty(S))1/扫描到右括号，且当前栈空 return false;//匹配失败 char topElem; Pop（S,topElem）； //栈顶元素出栈 if(str[i]==\u0026#39;)\u0026#39; \u0026amp;\u0026amp; topElem!=\u0026#39;(\u0026#39;) return false; if(str[i]=\u0026#39;]\u0026#39; \u0026amp;\u0026amp; topElem!=\u0026#39;[\u0026#39;) return false; if(str[i]=\u0026#39;}\u0026#39; \u0026amp;\u0026amp; topElem!=\u0026#39;{\u0026#39;) return false; } return StackEmpty（S）； //检索完全部括号后，栈空说明匹配成功 注意：考试中可直接使用基本操作，建议简要说明接口\n//初始化栈 void InitStack(SqStack \u0026amp;S) //判断栈是否为空 bool StackEmpty(SqStack S) //新元素入栈 bool Push(SqStack \u0026amp;S, char x) 11栈顶元素出栈，用×返回 bool Pop (SqStack \u0026amp;S, char \u0026amp;x)\n栈的应用\u0026ndash;表达式求值 表达式分为三个部分：操作数、运算符、界限符\n波兰科学家的一个灵感：可以不用界限符也能无歧义地表达运算顺序 Reverse Polish notation（逆波兰表达式=后缀表达式） Polish notation（波兰表达式=前缀表达式） 中缀表达式\u0026mdash;运算符在两个操作数中间 后缀表达式\u0026mdash;运算符在两个操作数后面 前缀表达式\u0026mdash;运算符在两个操作数前面 中缀表达式转后缀表达式（手算） 中缀转后缀的手算方法： ① 确定中缀表达式中各个运算符的运算顺序 ② 选择下一个运算符，按照「左操作数 右操作数运算符」的方式组合成一个新的操作数 ③ 如果还有运算符没被处理，就继续 ②\n私房菜：“左优先”原则，不要Freestyle，保证手算和机算结果相同 “左优先”原则：只要左边的运算符能先计算，就优先算左边的\u0026mdash;-可保证运算顺序唯一\n运算顺序不唯一，因此对应的后缀表达式也不唯一\n后缀表达式的计算方法（手算）： 从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，合体为一个操作数 注意：两个操作数的左右顺序 特点：最后出现的操作数先被运算\n用栈实现后缀表达式的计算（机算）： ①从左往右扫描下一个元素，直到处理完所有元素 ②若扫描到操作数则压入栈，并回到①；否则执行③ ③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到① 注意：先出栈的是“右操作数” 若表达式合法，则最后栈中只会留下一个元素，就是最终结果\n中缀表达式转前缀表达式（手算） 中缀转前缀的手算方法： ① 确定中缀表达式中各个运算符的运算顺序 ② 选择下一个运算符，按照「运算符 左操作数 右操作数」的方式组合成一个新的操作数 ③ 如果还有运算符没被处理，就继续② “右优先”原则：只要右边的运算符能先计算，就优先算右边的 注意：先出栈的是“左操作数”\n中缀表达式转后缀表达式（机算） 初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。 从左到右处理各个元素，直到末尾。可能遇到三种情况： ① 遇到操作数。直接加入后缀表达式。 ② 遇到界限符。遇到“(”直接入栈；遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到弹出“(”为止。注意：“(”不加入后缀表达式。 ③ 遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“(”或栈空则停止。之后再把当前运算符入栈。 按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。\n中缀表达式的计算（用栈实现） 用栈实现中缀表达式的计算： 初始化两个栈，操作数栈和运算符栈 若扫描到操作数，压入操作数栈 若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈）\n本质：中缀转后缀+后缀表达式求值，两个算法的结合 栈的应用\u0026ndash;递归 函数调用背后的过程 函数调用的特点：最后被调用的函数最先执行结束（LIFO） 函数调用时，需要用一个栈存储： ① 调用返回地址 ② 实参 ③ 局部变量 栈在递归中的应用 适合用“递归”算法解决：可以把原始问题转换为属性相同，但规模较小的问题\nEg1：计算正整数的阶乘 n！ 1 2 3 4 5 6 int factorial (int n){ if (n==0 || n==1) return 1; else return n*factorial(n-1); } 递归调用时，函数调用栈可称为“递归工作栈” 每进入一层递归，就将递归调用所需信息压入栈顶 每退出一层递归，就从栈顶弹出相应信息\n缺点：太多层递归可能会导致栈溢出\nEg 2：求斐波那契数列 1 2 3 4 5 6 7 8 int Fib(int n){ if(n==0) return 0; else if (n==1) return 1; else return Fib(n-1)+Fib(n-2); } 可以自定义栈将递归算法改造成非递归算法\n队列的应用 队列应用一一树的层次遍历 队列应用——图的广度优先遍历 队列在操作系统中的应用 多个进程争抢着使用有限的系统资源时，FCFS（First Come First Service，先来先服务）\u0026mdash;可用队列实现\u0026mdash;是一种常用策略。 Eg：CPU资源的分配、打印数据缓冲区 串 串的定义和基本操作 串的定义 串，即字符串（String）是由零个或多个字符组成的有限序列。一般记为 S=\u0026lsquo;a1a2\u0026hellip;\u0026hellip;an\u0026rsquo;(n≥0) 其中，S是串名，单引号括起来的字符序列是串的值；a，可以是字母、数字或其他字符；串中字符的个数n称串的长度。n=0时的串称空串。\n串 VS 线性表 串是一种特殊的线性表，数据元素之间呈线性关系 串的数据对象限定为字符集（如中文字符、英文字符、数字字符、标点字符等）\n串的基本操作，如增删改查等通常以子串操作对象\n串的基本操作 StrAssign（\u0026amp;T,chars）：赋值操作。把串T赋值为chars。 StrCopy（\u0026amp;T,S）：复制操作。由串S复制得到串T。 StrEmpty（S）：判空操作。若S为空串，则返回TRUE，否则返回FALSE。 StrLength（S）：求串长。返回串S的元素个数。 ClearString（\u0026amp;S）：清空操作。将S清为空串。 DestroyString（\u0026amp;S）：销毁串。将串S销毁（回收存储空间）。 Concat（\u0026amp;T,S1,S2）：串联接。用T返回由S1和S2联接而成的新串 Substring（\u0026amp;Sub,S,pos,len）：求子串。用Sub返回串S的第pos个字符起长度为len的子串。 Index（S,T）：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值\u0026lt;0。 StrCompare（S,T）：比较操作。若S\u0026gt;T，则返回值\u0026gt;0；若S=T，则返回值=0；若S\u0026lt;T，则返回值\u0026lt;0。\n串的比较操作 StrCompare（S,T）：比较操作。若S\u0026gt;T，则返回值\u0026gt;0；若S=T，则返回值=0；若S\u0026lt;T，则返回值\u0026lt;0。\n字符集编码\ny=f(x)\n字符集：函数定义域\n编码：函数映射规则f\ny：对应的二进制数\n任何数据存到计算机中一定是二进制数。 需要确定一个字符和二进制数的对应规则这就是“编码”\n“字符集”：英文字符——ASCII字符集中英文——Unicode字符集 基于同一个字符集，可以有多种编码方案， Eg: UTF-8, UTF-16 注：采用不同的编码方式，每个字符所占空间不同，考研中只需默认每个字符占1B即可\n串的存储结构 串的顺序存储 定义 静态数组 1 2 3 4 5 #define MAXLEN 255//预定义最大串长为255 typedef struct{ char ch[MAXLEN];//每个分量存储一个字符 int length;//串的实际长度 }SString; 动态数组 1 2 3 4 5 6 7 typedef struct{ char *ch; //按串长分配存储区，ch指向串的基地址 int length;//串的长度 }HString: HString S; S.ch = (char *) malloc(MAXLEN * sizeof(char)); S.lenath =0: 存储方式 串的链式存储 1 2 3 4 typedef struct StringNode{ char ch;//每个结点存1个字符 struct StringNode *next; }StringNode, *String; 1 2 3 4 typedef struct StringNode{ char ch [4];//每个结点存多个字符 struct StringNode * next; }StringNode, * String; 基本操作的实现 SubString（\u0026amp;Sub,S,pos,len）：求子串。用Sub返回串S的第pos个字符起长度为len的子串。\n1 2 3 4 5 6 7 8 9 bool SubString (SString \u0026amp;Sub,SString S, int pos, int len){ //子串范围越界 if (pos+len-1 \u0026gt; S.length) return false; for (int i=pos; i\u0026lt;pos+len; i++){ Sub.ch[i-pos+1] = S.ch[il; Sub. length = len; return true } StrCompare(S,T):比较操作。若S\u0026gt;T，则返回值\u0026gt;0；若S=T，则返回值=0；若S\u0026lt;T，则返回值\u0026lt;0。\n1 2 3 4 5 6 7 8 9 //比较操作。若S\u0026gt;T，则返回值\u0026gt;0；若S=T， 则返回值=0；若S\u0026lt;T，则返回值≤0 int StrCompare(SString S, SString T) { for (int i=1; i\u0026lt;=S.length \u0026amp;\u0026amp; i\u0026lt;=T.length; i++){ if (S.ch[i]!=T.ch[i]) return S.ch[il-T.ch[il; } //扫描过的所有字符都相同，则长度长的串更大 return S. length-T. length; } Index（S,T）：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0。 1 2 3 4 5 6 7 8 9 10 int Index(SString S, SString T){ int i=1, n=StrLength(S), m=StrLength(T); SString sub； //用于暂存子串 while(i\u0026lt;=n-m+1){ Substring(sub, S, i,m)； if(StrCompare(sub,T)！=0) ++i； else return i; //返回子串在主串中的位置 } return 0; //S中不存在与T相等的子串 } 字符串\u0026mdash;-朴素模式匹配算法 字符串模式匹配：在主串中找到与模式串相同的子串，并返回其所在位置。\n两种方法：朴素模式匹配算法、KMP算法 朴素模式匹配算法 主串长度为n，模式串长度为 m 朴素模式匹配算法：将主串中所有长度为m的子串依次与模式串对比，直到找到一个完全匹配的子串，或所有的子串都不匹配为止。（最多对比 n-m+1个子串）\n若当前子串匹配失败，则主串指针i指向下一个子串的第一个位置，模式串指针j回到模式串的第一个位置。若j\u0026gt;T.length，则当前子串匹配成功，返回当前子串第一个字符的位置\u0026mdash;-i- T.length\nIndex(S,T):定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0。\n1 2 3 4 5 6 7 8 9 10 int Index(SString S, SString T){ int i=1, n=StrLength(S), m=StrLength(T); String sub;//用于暂存子串 while(i\u0026lt;=n-m+1){//最多对比 n-m+1个子串 SubString(sub,S,i,m);//取出从位置i开始，长度为m的子串 if(Strcompare(sub,T)!=0)//子串和模式串对比，若不匹配，则匹配下一个子串 else return i; //返回子串在主串中的位置 } return 0; //S中不存在与T相等的子串 } 接下来：不使用字符串的基本操作，直接通过数组下标实现朴素模式匹配算法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int Index(SString S,SString T){ int i=1,j=1; while(i\u0026lt;=S.length \u0026amp;\u0026amp; j\u0026lt;=T.length){ if(S.ch [i]==T.ch[j]){ ++1;++j;//继续比较后继字符 } else{ i=1-j+2; j=1;//指针后退重新开始匹配 } if(j\u0026gt;T.length) return i-T.length; else return 0; } 最坏的情况，每个子串都要对比 m 个字符，共n-m+1个子串，复杂度=O((n-m+1)m)=O(nm)\n字符串\u0026mdash;-KMP算法 KMP算法 由D.E.Knuth,J.H.Morris和V.R.Pratt提出，因此称为KMP算法\n不匹配的字符之前，一定是和模式串一致的 Eg：对于模式串 T= ‘abaabc\u0026rsquo; 当第6个元素匹配失败时，可令主串指针i不变，模式串指针j=3 当第5个元素匹配失败时，可令主串指针i不变，模式串指针j=2 当第4个元素匹配失败时，可令主串指针i不变，模式串指针j=2 当第3个元素匹配失败时，可令主串指针i不变，模式串指针j=1 当第2个元素匹配失败时，可令主串指针i不变，模式串指针j=1 当第1个元素匹配失败时，匹配下一个相邻子串，令j=0,i++，j++ next数组 next数组只和短短的模式串有关，和长长的主串无关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int Index_KMP(SString S,SString T,int nextl]){ int i=1, j=1; while (i\u0026lt;=S.length\u0026amp;\u0026amp;j\u0026lt;=T.length){ if (j==0||S.ch[i]==T.chljl){ ++i; ++j;//继续比较后继字符 } else j=next[j];//模式串向右移动 if(j\u0026gt;T. length) return i-T. length；//匹配成功 else return 0; } KMP算法\u0026mdash;-求next数组 next数组的作用：当模式串的第j个字符失配时，从模式串的第 nextljl 的继续往后匹配\n任何模式串都一样，第一个字符不匹配时，只能匹配下一个子串，因此，往后余生，next［1］都无脑写0 任何模式串都一样，第2个字符不匹配时，应尝试匹配模式串的第1个字符，因此，往后余生，next［2］都无脑写1 在不匹配的位置前边，划一根美丽的分界线，模式串一步一步往后退，直到分界线之前“能对上”，或模式串完全跨过分界线为止，此时j指向哪儿，next数组值就是多少 KMP算法\u0026mdash;-进一步优化 树和二叉树 树的定义与基本术语 树的基本概念 非空树的特性： 有且仅有一个根节点 没有后继的结点称为“叶子结点”（或终端结点） 有后继的结点称为“分支结点”（或非终端结点） 除了根节点外，任何一个结点都有且仅有一个前驱 每个结点可以有0个或多个后继。 除了根节点外，任何一个结点都有且仅有一个前驱 树是n(n\u0026gt;=0)个结点的有限集合，n=0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足： 1）有且仅有一个特定的称为根的结点。 2）当n\u0026gt;1时，其余结点可分为m(m\u0026gt;0)个互不相交的有限集合T1，T2\u0026hellip;\u0026hellip;Tm，其中每个集合本身又是一棵树，并且称为根结点的子树。 什么是两个结点之间的路径？\u0026mdash;只能从上往下 什么是路径长度？\u0026mdash;经过几条边 属性： 结点的层次(深度)\u0026mdash;-从上往下数 结点的高度\u0026mdash;-从下往上数 树的高度(深度)\u0026mdash;-总共多少层 结点的度\u0026mdash;-有几个孩子（分支） 树的度\u0026mdash;-各结点的度的最大值 有序树V.S无序树 有序树—-逻辑上看，树中结点的各子树从左至右是有次序的，不能互换 无序树—-逻辑上看，树中结点的各子树从左至右是无次序的，可以互换\n树V.S森林 森林。森林是m（m≥0）棵互不相交的树的集合\n树的常考性质 常见考点1：结点数=总度数+1 结点的度—一结点有几个孩子（分支）\n树的度——各结点的度的最大值 m叉树一一每个结点最多只能有m个孩子的树\n度为m的树 m叉树 任意结点的度≤m（最多m个孩子） 任意结点的度≤m（最多m个孩子） 至少有一个结点度=m（有m个孩子） 允许所有结点的度都＜ m 一定是非空树，至少有m+1个结点 可以是空树 常见考点2：度为m的树、m叉树的区别\n常见考点3：度为m的树第i层至多有mi-1个结点（i\u0026gt;=1） m叉树第i层至多有mi-1 个结点（1\u0026gt;=1）\n常见考点4：高度为h的m叉树至多有mh-1/m-1个结点。 等比数列求和公式：a+aq+aq2+\u0026hellip;\u0026hellip;+aqn-1=a(1-qn)/1-q\n常见考点5：高度为h的m叉树至少有h个结点。 高度为h、度为m的树至少有h+m-1个结点。\n常见考点6：具有n个结点的m又树的最小高度为 logm(n(m-1)+1)\n高度最小的情况——所有结点都有m个孩子\n二叉树的定义与基本定语 二叉树的基本概念 二叉树是n(n\u0026gt;=0)个结点的有限集合： ① 或者为空二叉树，即n=0。 ② 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。 特点：①每个结点至多只有两棵子树 ②左右子树不能颠倒（二叉树是有序树） *注意区别：度为2的有序树\n二叉树的五种状态\n1.空二叉树\n2.只有左子树\n3.只有右子树\n4.只有根结点\n5.左右子树都有\n几种特殊的二叉树 满二叉树。一棵高度h，且含有2-1个结点的二叉树\n特点： ①只有最后一层有叶子结点 ②不存在度为1的结点 ③按层序从1开始编号，结点i的左孩子2i，右孩子为2i+1；结点i的父节点为|/2」（如果有的话）\n完全二叉树。当且仅当其每个结点都与高度为h的满二叉树中编号为1～n的结点一一对应时，称为完全二叉树\n特点： ①只有最后两层可能有叶子结点 ②最多只有一个度为1的结点 ③按层序从1开始编号，结点i的左孩子2i，右孩子为2i+1；结点i的父节点为|/2」（如果有的话） ④i\u0026lt;=[n/2]为分支结点，i\u0026gt;[n/2]为叶子结点\n二叉排序树。一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树： 左子树上所有结点的关键字均小于根结点的关键字； 右子树上所有结点的关键字均大于根结点的关键字。 左子树和右子树又各是一棵二叉排序树。 \u0026mdash;-二叉排序树可用于元素的排序、搜索\n平衡二叉树。树上任一结点的左子树和右子树的深度之差不超过1。\n二叉树常考性质 二叉树常考性质 常见考点1：设非空二叉树中度为0、1和2的结点个数分别为n0、n1和n2，则n0=n2+1(叶子结点 比二分支结点多一个)\n证明：假设树中结点总数为n，则 (1)n = n0+ n1+ n2 (2)n = n1+ 2n2+1\u0026mdash;-树的结点数=总度数+1 (1)-(2):n0=n2+1\n常见考点2：二叉树第i层至多有2i-1 个结点（i≥1） m叉树第i层至多有mi-1 个结点（i≥1）\n常见考点3：高度为h的二叉树至多有 2h—1个结点（满二叉树） 高度为h的m叉树至多有mh-1/m-1个结点 等比数列求和公式：a+aq+aq2+\u0026hellip;\u0026hellip;+aqn-1=a(1-qn)/1-q\n完全二叉树常考性质 常见考点1：具有n个（n\u0026gt;0）结点的完全二叉树的高度h为 log2(n+1) 或log2n +1\nlog2(n+1)是怎么来的？\n高为h的满二叉树共有2h-1个结点，\n高h-1的满二叉树共有2h-1—1个结点，\n所以要想高度为h就必须满足：\n2h-1-1 \u0026lt;n≤2h-1 2h-1 \u0026lt; n+1≤2h h - 1 \u0026lt; log2(n+1) ≤ h h = log2(n+ 1)\nlog2n +1是怎么来的？\n高h-1的满二叉树共有2h-1—1个结点，\n所以高为h的二叉树则至少比他多一个结点，\n即至少为2h-1，\n至多为2h-1-1\n常见考点2：对于完全二叉树，可以由的结点数n推出度为0、1和2的结点个数为n0、n1和n2\n完全二叉树最多只有一个度1的结点，即n0=0或1 n0=n2+1 \u0026ndash;\u0026gt; n0+n2一定是奇数\n若完全二叉树有2k个(偶数)个结点，则必有n1=1，n0=k，n2=k-1 若完全二叉树有2k-1个(奇数)个结点，则必有n1=0, n0=k, n2 = k-1\n二叉树的存储结构 二叉树的顺序存储 代码定义 1 2 3 4 5 6 #define MaxSize 100 struct TreeNode { ftemTypeyalue; //结点中的数据元素 bool isEmpty;//结点是否为空 ｝； TreeNode t [MaxSizel; 定义一个长度为 MaxSize 的数组t，按照从上至下、从左至右的顺序依次存储完全二叉树中的各个结点\n注意：可以让第一个位置为空，保证数组下标和结点编号一致\n几个重要常考的基本操作：\ni 的左孩子——2i i 的右孩子——2i+1 i 的父节点——i/2 i 所在的层次——log2(n+1) 或 [log2n ]+1 若完全二叉树中共有n个结点，则（注意，只有完全二叉树才符合这个规则 ） 判断 i 是否有左孩子？——2i ≤ n？ 判断 i 是否有右孩子？——2i+1 ≤ n? 判断 i 是否是叶子/分支结点？ ——i\u0026gt;[n/2]？ 如果不是完全二叉树怎么办？\n二叉树的顺序存储中，一定要把二叉树的结点编号与完全二叉树对应起来\n结论：二叉树的顺序存储结构，只适合存储完全二叉树\n二叉树的链式存储 代码定义\n1 2 3 4 5 //二叉树的结点（链式存储） typedef struct BiTNode{ ElemType data: //数据域 struct BiNode *child, *rchild;//左、右孩子指针 }BiTNode *BiTree: 线索二叉树\n若有n个结点，则有2n个指针，除了跟结点，每一个结点上面一定会有一个指针指向他，共有n-1个，所以有n+1个空的指针域，可以利用这些空间构造线索二叉树\n二叉树的构建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct ElemType{ int value; }; typedef struct BiTNode{ ElemType data; struct BiNode *lchild,*rchild; }BiT Node,*BiTree; //定义一棵空树 BiTree root = NULL; //插入根节点 root = (BiTree)malloc(sizeof(BiTNode)); root-\u0026gt;data = {1}; root-\u0026gt;lchild = NULL; root-\u0026gt;rchild = NULL; //插入新结点 BiTNode *p = (BiTNode *) malloc(sizeof(BiTNode)); p-\u0026gt;data = {2}; p-\u0026gt;lchild = NULL; p-\u0026gt;rchild = NULL; root-\u0026gt;lchild=p;v//作为根节点的左孩子 三叉链表 可以增加一个父结点指针以方便找父结点 二叉树的先中后序遍历 先序遍历：根左右（NLR）\n代码实现\n先序遍历（PreOrder）的操作过程如下：\n若二叉树空，则什么也不做； 若二叉树非空： ①访问根结点； ②先序遍历左子树； ③先序遍历右子树。 1 2 3 4 5 6 7 void PreOrder(BiTree T){ if (T!=NULL){ visit(T); PreOrder (T-\u0026gt;lchild); PreOrder (T-\u0026gt;rchild); } } 中序遍历：左根右（LNR）\n代码实现\n中序遍历（InOrder）的操作过程如下：\n若二叉树为空，则什么也不做； 若二叉树非空： ①先序遍历左子树； ②访问根结点； ③先序遍历右子树。 1 2 3 4 5 6 7 void InOrder(BiTree T){ if (T!=NULL){ PreOrder (T-\u0026gt;lchild); visit(T); PreOrder (T-\u0026gt;rchild); } } 后序遍历：左右根（LRN）\n后序遍历（InOrder）的操作过程如下：\n若二叉树为空，则什么也不做； 若二叉树非空： ①先序遍历左子树； ⑨先序遍历右子树； ③访问根结点。 先序遍历 前缀表达式 中序遍历 中缀表达式（需要加界限符） 后序遍历 后缀表达式\n脑补空结点，从根节点出发，画一条路： 如果左边还有没走的路，优先往左边走走到路的尽头（空结点）就往回走 如果左边没路了，就往右边走 如果左、右都没路了，则往上面走，经过三次时访问该结点\n例：求树的深度\n1 2 3 4 5 6 7 8 9 10 11 int treeDepth(BiTree T){ if (T == NULL) { return 0; } else { int l = treeDepth(T-\u0026gt;child); int r = treeDepth(T-\u0026gt;rchild); //树的深度=Max（左子树深度，右子树深度）+1 return l\u0026gt;r ? l+1 : r+1； ｝ } 二叉树的层次遍历 算法思想： 1.初始化一个辅助队列 2.根结点入队 3.若队列非空，则队头结点出队，访问该结点：并将其左、右孩子插入队尾（如果有的话） 4.重复3直至队列为空 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //层序遍历 void LevelOrder(BiTree D){ LinkQueue Q; InitQueue (Q);//初始化辅助队列 BiTree p; EnQueue (Q,T);//将根结点入队 while(!IsEmpty(Q)){//队列不空则循环 DeQueue（Q,p）；//队头结点出队 visit(p);//访问出队结点 if(p-\u0026gt;|child!=NULL) EnQueue(Q,P-\u0026gt;lchild);//左孩子入队 if(p-\u0026gt;rchild!=NULL) EnQueue(Q, p-\u0026gt;rchild);//右孩子入队 } } 由遍历序列来构造二叉树 若只给出一棵二叉树的前/中/后/层序遍历序列中的一种，不能唯一确定一棵二叉树\n前序＋中序遍历序列 前序遍历：根结点、前序遍历左子树、前序遍历右子树 中序遍历：中序遍历左子树、根结点、中序遍历右子树\n后序＋中序遍历序列\n逻辑与前序+中序类似\n层序＋中序遍历序列 线索二叉树的概念 二叉树存在的一些问题\n不能从一个指定结点开始中序遍历 找到前驱和后继比较麻烦 思路： 从根节点出发，重新进行一次中序 遍历，指针q记录当前访问的结点，指针 pre 记录上一个被访问的结点 ①当q=p时，pre为p的前驱 ②当pre=p时，q为p的后继 引入线索二叉树\n因为n个结点的二叉树会存在n+1个空链域，所以可以利用这些空间存储二叉树的前驱和后继\n代码定义\n1 2 3 4 5 6 //线索二叉树结点 typedef struct ThreadNode{ ElemType data； struct ThreadNode *lchild,*rchild; int ltag, rtag;//左、右线索标志,tag==0表示指向的是孩子，tag==1表示指向的是线索 }ThreadNode, *ThreadTree; 二叉树的线索化 \u0026ldquo;土方法\u0026quot;找中序前驱\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void FindPre(BiTree T){ if(T!=NULL){ InOrder (T-\u0026gt;l child);//递归遍历左子树 visit (T);//访问根结点 InOrder (T-\u0026gt;rchild);//递归遍历右子树 } } void visit(BiTNode * q){ if (q==p)//当前访问结点刚好是结点人展 final = pre;//找到p的前驱 else pre = q;//pre指向当前访问的结点 } //辅助全局变量，用于查找结点p的前驱 BiTNode *p;//p指向目标结点 Biz[Node * pre=NULL;//指向当前访问结点的前驱 BiTNode * final=NULL;//用于记录最终结果 中序线索化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //线索二叉树结点 typedef struct ThreadNode{ ElemType data; struct ThreadNode *lchild,*rchild; int ltag,rtag;//左、右线索标志 }ThreadNode, *ThreadTree; //中序遍历二叉树，一边遍历一边线索化 void InThread(ThreadTree T){ if(T!=NULL){ InThread(T-\u0026gt;lchild)；//中序遍历左子树 visit(T);//访问根节点 InThread (T-\u0026gt;rchild);//中序遍历右子树 } } void visit(ThreadNode *q){ if(q-\u0026gt;lchild==NULL){//左子树为空，建立前驱线索 q-\u0026gt;lchild=pre; q-\u0026gt;ltag=1; } if(pre!=NULL\u0026amp;\u0026amp;pre-\u0026gt;rchild==NULL){ pre-\u0026gt;rchild=q； //建立前驱结点的后继线索 pre-\u0026gt;rtag=1; ｝ pre=q; ｝ //全局变量 pre，指向当前访问结点的前驱 ThreadNode *pre=NULL: 中序线索化（王道教材版）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //中序线索化 void InThread (ThreadTree p, ThreadTree \u0026amp;pre){ if(p!=NULL){ InThread (p-\u0026gt;lchild, pre);//递归，线索化左子树 if(p-\u0026gt;lchild==NULL){//左子树为空，建立前驱线索 p-\u0026gt;lchild=pre; p-\u0026gt;ltag=1; } if(pre!=NULL\u0026amp;\u0026amp;pre-\u0026gt;rchild==NULL){ pre-\u0026gt;rchild=p;//建立前驱结点的后继线索 pre-\u0026gt;rtag=1; } pre=p; InThread (p-\u0026gt;rchild, pre) ; }//if(p!=NULL) } //中序线索化二叉树T void CreateInThread(ThreadTree T){ ThreadTree pre=NULL; if(T!=NULL){ InThread(T,pre);//非空二叉树，线索化 pre-\u0026gt;rchild=NULL；//线索化二叉树 pre-\u0026gt;rtag=1;//处理遍历的最后一个结点 } } 思考：处理遍历的最后一个结点时，为什么没有判断 rchild 是否为NULL？ 答：中序遍历的最后一个结点右孩子指针必为空。\n先序线索化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 //全局变量 pre，指向当前访问结点的前驱 ThreadNode *pre=NULL; //先序线索化二叉树T void CreatePreThread (ThreadTree T){ pre=NULL;//pre初始为NULL if(T!=NULL){//非空二叉树才能线索化 PreThread (T) ;//先序线索化二叉树 if (pre-\u0026gt;rchild==NULL) pre-\u0026gt;rtag=1;//处理遍历的最后一个结点 } //先序遍历二叉树，一边遍历一边线索化 void PreThread(ThreadTree T){ if(T!=NULL){ visit(T);//先处理根节点 if(T-\u0026gt;Ltag==0)//lchild不是前驱线索 PreThread(T-\u0026gt;|child); PreThread(T-\u0026gt;rchild); } } void visit(ThreadNode *q){ if(q-\u0026gt;Lchild==NULL){//左子树为空，建立前驱线索 q-\u0026gt;Lchild=pre; q-\u0026gt;ltag=1; } if(pre!=NULL\u0026amp;\u0026amp;pre-\u0026gt;rchild==NULL){ pre-\u0026gt;rchild=q； //建立前驱结点的后继线索 pre-\u0026gt;rtag=1; } pre=q; } 后序线索化\n在线索二叉树中找前驱后继 中序线索二叉树找中序后继 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //找到以P为根的子树中，第一个被中序遍历的结点 ThreadNode *Firstnode (ThreadNode *p){ //循环找到最左下结点（不一定是叶结点） while(p-\u0026gt;Ltag==0) p=p-\u0026gt;lchild; return p; } //在中序线索二叉树中找到结点p的后继结点 ThreadNode *Nextnode(ThreadNode *p){ //右子树中最左下结点 if(p-\u0026gt;rtag==0) return Firstnode(p-\u0026gt;rchild); else return p-\u0026gt;rchild;//ctag==1直接返回后继线索 } //对中序线索二叉树进行中序遍历（利用线索实现的非递归算法） void Inorder(ThreadNode *T){ for(ThreadNode *p=Firstnode(T);p!=NULL;p=Nextnode(p)) visit (p); } 中序线索二叉树找中序前驱 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //找到以P为根的子树中，最后一个被中序遍历的结点 ThreadNode *Lastnode (ThreadNode *p){ //循环找到最右下结点（不一定是叶结点） while (p-\u0026gt;rtag==0) p=p-\u0026gt;rchild; return p; ｝ //在中序线索二叉树中找到结点p的前驱结点 ThreadNode *Prenode (ThreadNode *p){ //左子树中最右下结点 if(p-\u0026gt;ltag==0) return Lastnode(p-\u0026gt;lchild); else return p-\u0026gt;lchild; //ltag==1直接返回前驱线索 ｝ //对中序线索二叉树进行逆向中序遍历 void RevInorder(ThreadNode *T){ for (ThreadNode *p=Lastnode(T);p!=NULL; p=Prenode(p)) visit(p); } 树的存储结构 树的逻辑结构 树是n(n\u0026gt;=0)个结点的有限集合，n=0时，称空树，这是一种特殊情况。在任意一棵非空树中应满足： 1）有且仅有一个特定的称次根的结点。 2）当n\u0026gt;1时，其余结点可分为m（m\u0026gt;0）个互不相交的有限集合T1，T2…，Tm，其中每个集合本身又是一棵树，并且称为根结点的子树。 树是一种递归定义的数据结构 如何实现树的顺序存储 思路：用数组顺序存储各个结点。每个结点中保存数据元素、指向双亲结点（父节点）的“指针”\n树的存储1:双亲表示法\n1 2 3 4 5 6 7 8 9 #define MAX_TREE_SIZE 100//树中最多结点数 typedef struct{//树的结点定义 ElemType data;//数据元素 int parent;//双亲位置域 }PTNode: typedef struct{//树的类型定义 PTNode nodes[MAX_TREE_SIZE];//双亲表示 int n;//结点数 }PTree; 优点：找双亲（父节点）很方便 缺点：找孩子不方便，只能从头到尾遍历整个数组\n适用于“找父亲”多，“找孩子”少的应用场景。如：并查集\n树的存储2：孩子表示法\n孩子表示法：用数组顺序存储各个结点。每个结点中保存数据元素、孩子链表头指针\n1 2 3 4 5 6 7 8 9 10 11 12 struct CTNode{ int child; //孩子结点在数组中的位置、 struct CTNode *next;//下一个孩子 }; typedef struct{ ElemType data; struct CTNode *firstChild; //第一个孩子 }СТВох; typedef struct { СТBох nodes [MAX_TREE_SIZE]; int n,r;//结点数和根的位置 } CTree; 孩子表示法存储“森林”\n孩子表示法的优缺点\n优点：找孩子很方便 缺点：找双亲（父节点）不方便，只能遍历每个链表\n树的存储3：孩子兄弟表示法\n1 2 3 4 5 //树的存储：孩子兄弟表示法 typedef struct CSNode{ ElemType data; struct CSNode *firstchild,*nextsibling; }CSNode, *CSTree; 树的孩子兄弟表示法，与二叉树类似，采用二叉链表实现每个结点内保存数据元素和两个指针，但两个指针的含义与二叉树结点不同\n1 2 3 4 5 //二叉树的结点（链式存储） typedef struct BiTNode{ ElemType data; struct BiTNode *lchild,*rchild; }BiTNode, *BiTree; 当使用“孩子兄弟表示法”存储树或森林时，从存储视角来看形态上与二叉树类似，如下图：\n树、森林与二叉树的转换 树-\u0026gt;二叉树的转换 树-二叉树 转换技巧： ①先在二叉树中，画一个根节点。 ②按“树的层序”依次处理每个结点。\n处理一个结点的方法是：如果当前处理的结点在树中有孩子，就把所有孩子结点“用右指针串成糖葫芦”，并在二叉树中把第一个孩子挂在当前结点的左指针下方\n森林-\u0026gt;二叉树的转换 注意：森林中各棵树的根节点视为平级的兄弟关系\n森林-\u0026gt;二叉树转换技巧： ①先把所有树的根结点画出来，在二叉树中用右指针串成糖葫芦。 ②按“森林的层序”依次处理每个结点。 处理一个结点的方法是：如果当前处理的结点在树中有孩子，就把所有孩子结点“用右指针串成糖葫芦”，并在二叉树中把第一个孩子挂在当前结点的左指针下方\n二叉树-\u0026gt;树的转换 二叉树-\u0026gt;树的转换技巧： ①先画出树的根节点 ②从树的根节点开始，按“树的层序”恢复每个结点的孩子 如何恢复一个结点的孩子：在二叉树中，如果当前处理的结点有左孩子，就把左孩子和“一整串右指针糖葫芦”拆下来，按顺序挂在当前结点的下方\n二叉树-\u0026gt;森林的转换 二叉树-\u0026gt;森林的转换技巧： ①先把二叉树的根节点和“一整串右指针糖葫芦”拆下来，作多棵树的根节点 ②按“森林的层序”恢复每个结点的孩子 如何恢复一个结点的孩子：在二叉树中，如果当前处理的结点有左孩子，就把左孩子和“一整串右指针糖葫芦”拆下来，按顺序挂在当前结点的下方\n树、森林的遍历 树的先根遍历和后根遍历 （1）先根遍历。若树非空，先访问根结点，再依次对每棵子树进行先根遍历。（深度优先遍历）\n伪代码如下（具体代码实现需要根据具体树的存储结构编写）：\n1 2 3 4 5 6 7 8 //树的先根遍历 void PreOrder (TreeNode *R){ if(R!=NULL){ visit(R);//访问根节点 while(R还有下一个子树T) PreOrder(T);//先根遍历下一棵子树 } } （2）后根遍历。若树非空，先依次对每棵子树进行后根遍历，最后再访问根结点。（深度优先遍历）\n伪代码如下（具体代码实现需要根据具体树的存储结构编写）：\n1 2 3 4 5 6 7 8 //树的后根遍历 void PostOrder(TreeNode *R){ if(R!=NULL){ while(R还有下一个子树T) PostOrder(T);//后根遍历下一棵子树 visit(R);//访问根节点 } } 树的层次遍历 （3）层次遍历（用队列实现）（广度优先遍历） ①若树非空，则根节点入队 ②若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队 ③重复②直到队列为空\n森林的先序遍历、中序遍历 1） 先序遍历森林。 若森林非空，则按如下规则进行遍历： 访问森林中第一棵树的根结点。 先序遍历第一棵树中根结点的子树森林。 先序遍历除去第一棵树之后剩余的树构成的森林。\n（效果等于先序遍历每个树）\n2） 中序遍历森林。 若森林为非空，则按如下规则进行遍历： 中序遍历森林中第一棵树的根结点的子树森林。 访问第一棵树的根结点。 中序遍历除去第一棵树之后剩余的树构成的森林。\n哈夫曼树 带权路径长度 结点的权：有某种现实含义的数值（如：表示结点的重要性等） 结点的带权路径长度：从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积 树的带权路径长度：树中所有叶结点的带权路径长度之和（WPL, Weighted Path Length）\n哈夫曼树的定义 在含有n个带权叶结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称哈夫曼树，也称最优二叉树\n哈夫曼树的构造 给定n个权值分别为w1，w2…，wn的结点，构造哈夫曼树的算法描述如下： 1）将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。 2）构造一个新结点，从F中选取两棵根结点权值最小的树作新结点的左、右子树，并且将新结点的权值置左、右子树上根结点的权值之和。 3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中。 4）重复步骤2）和3），直至F中只剩下一棵树为止。\n最后： 1）每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大 2）哈夫曼树的结点总数为2n-1 3）哈夫曼树中不存在度1的结点。 4）哈夫曼树并不唯一，但WPL必然相同且为最优\n哈夫曼编码 Eg：\nA\u0026ndash;00\nB\u0026ndash;01\nC\u0026ndash;10\nD\u0026ndash;11\n假设，100题中有80题选C，10题选A，8题选B，2题选D,所有答案的二进制长度=80*2+10*2+8*2+2*2=200bit\n因为选C的概率大，所以我们可以把哈夫曼编码改良为：\nC\u0026ndash;0\nA\u0026ndash;10\nB-111\nD-110\n这是一种可变长度编码—一允许对不同字符用不等长的二进制位表示\n但是，如果改为：\nC\u0026ndash;0\nA\u0026ndash;1\nB\u0026ndash;111\nD\u0026ndash;110\n这样是不对的，因为会导致歧义，究其根本原因是字符A没有作为叶子结点\n固定长度编码一一每个字符用相等长度的二进制位表示\n可变长度编码—一允许对不同字符用不等长的二进制位表示\n若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码 有哈夫曼树得到哈夫曼编码——字符集中的每个字符作为一个叶子结点，各个字符出现的频度作为结点的权值，根据之前介绍的方法构造哈夫曼树\n图 图的基本概念 图的定义 图G（Graph）由顶点集V（Vertex）和边集E（Edge）组成，记为G=（V,E），其中V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系（边）集合。若V={v1，v2..， vn}，则用|V|表示图G中顶点的个数，也称图G的阶，E={u,v)| u∈V,v∈V}，用|E|表示图G中边的条数。 注意：线性表可以是空表，树可以是空树，但图不可以是空，即V一定是非空集\n无向图、有向图 若E是无向边（简称边）的有限集合时，则图G为无向图。边是顶点的无序对，记为（v,w）或（w, v），因为（v,w）=（w, v），其中v、w是顶点。可以说顶点w和顶点v互为邻接点。边（v,w）依附于顶点w和v，或者说边（v,w）和顶点 、w相关联。 若E是有向边（也称弧）的有限集合时，则图G为有向图。弧是顶点的有序对，记为\u0026lt;v，w\u0026gt;，其中v、w是顶点，v称为弧尾，w称为弧头，\u0026lt;v，w\u0026gt;称为从顶点到顶点w的弧，也称v邻接到w，或w邻接自v。\u0026lt;v,w\u0026gt;≠\u0026lt;w,v\u0026gt; 简单图、多重图 简单图——① 不存在重复边； ② 不存在顶点到自身的边 多重图——图G中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联，则G为多重图 顶点的度、入度、出度 对于无向图：顶点v的度是指依附于该顶点的边的条数，记为 TD(v)。 在具有n个顶点、e条边的无向图中，∑i=1nTD(vi)=2e 即无向图的全部顶点的度的和等于边数的2倍 对于有向图： 入度是以顶点v为终点的有向边的数目，记为ID(v)； 出度是以顶点v为起点的有向边的数目，记为OD(v)。 顶点v的度等于其入度和出度之和，即TD（v）=ID（V）+ OD（w）。 顶点-顶点的关系描述 路径一一顶点vp到顶点vq之间的一条路径是指顶点序列\u0026mdash;\u0026ndash;vp,vi1\u0026hellip;\u0026hellip;vim,vq 回路一一第一个顶点和最后一个顶点相同的路径称为回路或环 简单路径一一在路径序列中，顶点不重复出现的路径称为简单路径。 简单回路—-除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。 路径长度一一路径上边的数目 点到点的距离一一从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到v的距离。 若从u到v根本不存在路径，则记该距离为无穷（∞）。 无向图中，若从顶点v到顶点w有路径存在，则称v和w是连通的 有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的 连通图、强连通图 若图G中任意两个顶点都是连通的，则称图G 连通图，否则称为非连通图。\n常见考点： 对于n个顶点的无向图G， 若G是连通图，则最少有n-1条边 若G是非连通图，则最多可能有C2n-1条边\n若图中任何一对顶点都是强连通的，则称此图为强连通图。\n常见考点： 对于n个顶点的有向图G， 若G是强连通图，则最少有n条边（形成回路）\n研究图的局部一一子图 设有两个图G=(V, E)和G’=(V’,E’)，若V’是V的子集，且E是E’的子集，则称G’是G的子图。 若有满足V(G’)=V(G)的子图G\u0026rsquo;，也就是顶点相同，则称其为G的生成子图\n连通分量 无向图中的极大连通子图（子图必须连通，且包含尽可能多的顶点和边）称连通分量。 有向图中的极大强连通子图（子图必须强连通，同时保留尽可能多的边）称有向图的强连通分量 生成树 连通图的生成树是包含图中全部顶点的一个极小连通子图（边尽可能的少，但要保持连通）。\n若图中顶点数为n，则它的生成树含有n-1条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。\n在非连通图中，连通分量的生成树构成了非连通图的生成森林。\n边的权、带权图/网 边的权一一在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。 **带权图/网****一一边上带有权值的图称为带权图，也称网。 带权路径长度一一当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度 几种特形态的图 无向完全图\n无向完全图一一无向图中任意两个顶点之间都存在边 若无向图的顶点数IVI=n，则IEI ∈ [0, C2n] = [0, n(n-1)/2]\n有向完全图\n有向完全图——有向图中任意两个顶点之间都存在方向相反的两条弧 若有向图的顶点数IVI=n，则IEI ∈ [0,2C2n] = [0, n(n-1)]\n","date":"2024-11-12T20:43:19+08:00","permalink":"http://localhost:1313/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E7%8E%8B%E9%81%93%E7%BD%91%E8%AF%BE/","title":"数据结构---王道网课"},{"content":"第1章 绪论 考纲内容 算法时间复杂度和空间复杂度的分析与计算 复习提示 本章内容是数据结构概述，并不在考研大纲中。读者可通过对本章的学习，初步了解数据结构的基本内容和基本方法。分析算法的时间复杂度和空间复杂度是本章重点，需要熟练掌握，算法设计题通常都会要求分析时间复杂度、空间复杂度，同时会出现考查时间复杂度的选择题。 ","date":"2024-11-12T20:43:19+08:00","permalink":"http://localhost:1313/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E7%8E%8B%E9%81%93%E4%B9%A6/","title":"数据结构--王道书"},{"content":"简单的HTML语法 1.简单的 HTML 页面架构 2. HTML 常见标签 2.1. meta 标签 \u0026lt;meta\u0026gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎 和更新频度的描述和关键词。\n设置网站关键字 \u0026lt;meta name=\u0026ldquo;keywords\u0026rdquo; content=\u0026ldquo;网络安全，WEB 渗透，数据安全，渗透测试， 安全培训\u0026rdquo; /\u0026gt;\n2.1.1\u0026lt;link\u0026gt;\u0026mdash;-标签定义文档与外部资源的关系。 \u0026lt;link\u0026gt; 标签用于在 HTML 文档中引入外部资源，通常用于链接样式表（CSS），设置网站图标，或者定义其他与文档相关的信息。它是一个自闭合标签。\n\u0026mdash;-基本语法\u0026mdash;- \u0026lt;link rel=\u0026ldquo;关系类型\u0026rdquo; href=\u0026ldquo;资源路径\u0026rdquo; 属性=\u0026ldquo;值\u0026rdquo;\u0026gt;\n\u0026mdash;-常见用法\u0026mdash;-\n引入外部样式表（CSS） 这是\u0026lt;link\u0026gt; 最常见的用途，用于将 CSS 文件引入 HTML 文档。\n\u0026lt;link rel=\u0026ldquo;stylesheet\u0026rdquo; href=\u0026ldquo;styles.css\u0026rdquo;\u0026gt;\n•\trel=\u0026quot;stylesheet\u0026quot;：指定链接的是一个样式表。 •\thref=\u0026quot;styles.css\u0026quot;：指定样式表的路径。 设置网站图标（Favicon） 通过 \u0026lt;link\u0026gt; 定义网站的图标。\n\u0026lt;link rel=\u0026ldquo;icon\u0026rdquo; href=\u0026ldquo;favicon.ico\u0026rdquo; type=\u0026ldquo;image/x-icon\u0026rdquo;\u0026gt;\n•\trel=\u0026quot;icon\u0026quot;：指定这是一个图标。 •\ttype=\u0026quot;image/x-icon\u0026quot;：图标的文件类型。 •\thref=\u0026quot;favicon.ico\u0026quot;：图标文件的路径。 定义预加载资源 可以通过 \u0026lt;link\u0026gt; 提前加载关键资源以提升页面性能。\n\u0026lt;link rel=\u0026ldquo;preload\u0026rdquo; href=\u0026ldquo;font.woff2\u0026rdquo; as=\u0026ldquo;font\u0026rdquo; type=\u0026ldquo;font/woff2\u0026rdquo; crossorigin=\u0026ldquo;anonymous\u0026rdquo;\u0026gt;\n•\trel=\u0026quot;preload\u0026quot;：提前加载资源。 •\tas=\u0026quot;font\u0026quot;：指定资源的类型。 •\tcrossorigin：如果资源需要跨域加载，需要添加此属性。 引入其他文档类型 例如，引入一个 RSS 订阅文件。\n\u0026lt;link rel=\u0026ldquo;alternate\u0026rdquo; type=\u0026ldquo;application/rss+xml\u0026rdquo; title=\u0026ldquo;RSS\u0026rdquo; href=\u0026ldquo;feed.xml\u0026rdquo;\u0026gt;\n引用网站的规范 URL 用于避免重复内容问题，定义此页面的标准 URL。\n\u0026lt;link rel=\u0026ldquo;canonical\u0026rdquo; href=\u0026ldquo;https://www.example.com/page\"\u003e\n放置位置\u0026mdash;-必须放在 \u0026lt;head\u0026gt; 标签内，通常作为元信息的一部分。\n6.示例代码\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026ldquo;en\u0026rdquo;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026ldquo;UTF-8\u0026rdquo;\u0026gt; \u0026lt;meta name=\u0026ldquo;viewport\u0026rdquo; content=\u0026ldquo;width=device-width, initial-scale=1.0\u0026rdquo;\u0026gt; \u0026lt;title\u0026gt;示例页面\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026ldquo;stylesheet\u0026rdquo; href=\u0026ldquo;styles.css\u0026rdquo;\u0026gt; \u0026lt;link rel=\u0026ldquo;icon\u0026rdquo; href=\u0026ldquo;favicon.ico\u0026rdquo;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;欢迎访问！\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;\n注意事项\n1.\t自闭合：\u0026lt;link\u0026gt; 是自闭合标签，不需要 \u0026lt;/link\u0026gt;。 2.\t文件路径：确保 href 路径正确，支持绝对路径和相对路径。 3.\t缓存问题：更新样式文件时，可在 href 中加版本号，如 styles.css?v=1.1。 2.1.2\u0026lt;script\u0026gt; 引入 js 文件 \u0026lt;script\u0026gt; 标签用于在 HTML 文档中嵌入或引用 JavaScript 脚本。它可以用来实现交互、操作 DOM、动态更新内容等功能。\n基本语法\n\u0026lt;script 属性=\u0026ldquo;值\u0026rdquo;\u0026gt;JavaScript代码\n用法\n引入外部 JavaScript 文件 通过 src 属性引用外部的 JavaScript 文件。\n•\tsrc：指定 JavaScript 文件的路径。 •\t文件路径可以是相对路径或绝对路径。 内联 JavaScript 直接在 异步加载脚本（async 属性） 当脚本不依赖于页面的其他内容，可以通过 async 属性异步加载，提高页面加载速度。\n•\t异步加载：脚本加载完成后立即执行，不等待其他内容加载完成。 延迟加载脚本（defer 属性） 使用 defer 属性，脚本会在 HTML 解析完成后执行（但在 DOMContentLoaded 事件之前）。\n•\t延迟加载：保证脚本的执行顺序与页面结构一致。 指定脚本类型（type 属性） 通常默认是 text/javascript，但可以用于其他脚本\n注释 :\u0026lt;!\u0026ndash;这是一段注释。注释不会在浏览器中显示。\u0026ndash;\u0026gt; \u0026lt;p\u0026gt;这是一段普通的段落。\u0026lt;/p\u0026gt; 2.2. 标题标签 由大到小 原代码： \u0026lt;h1\u0026gt;h1\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;h2\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;h3\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;h4\u0026lt;/h4\u0026gt; \u0026lt;h5\u0026gt;h5\u0026lt;/h5\u0026gt; \u0026lt;h6\u0026gt;h6\u0026lt;/h6\u0026gt; 实际效果： h1 h2 h3 h4 h5 h6 换行线标签 \u0026lt;br\u0026gt; 换行标签\u0026mdash;直接放在\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;之中即可，无需闭合为\u0026lt;br /\u0026gt; 2.3. 文本属性 \u0026lt;strong\u0026gt;加粗\u0026lt;/strong\u0026gt;\n\u0026lt;b\u0026gt;\u0026lt;/b\u0026gt;加粗\n\u0026lt;i\u0026gt;\u0026lt;/i\u0026gt;斜体\n\u0026lt;u\u0026gt;\u0026lt;/u\u0026gt;下划线\n\u0026lt;sup\u0026gt;\u0026lt;/sup\u0026gt;上标\n\u0026lt;sub\u0026gt;\u0026lt;/sub\u0026gt;下标\n\u0026lt;del\u0026gt;\u0026lt;/del\u0026gt; 删除线\n\u0026lt;font\u0026gt;\u0026lt;/font\u0026gt; 规定字体属性:size 字体的大小 color 字体颜色 face规定字体\nEg：\u0026lt;font size=\u0026ldquo;4\u0026rdquo; color=\u0026ldquo;blue\u0026rdquo; face=\u0026ldquo;Arial\u0026rdquo;\u0026gt;这是蓝色的 Arial 字体文字\u0026lt;/font\u0026gt;\n注：一般不建议使用\u0026lt;font\u0026gt;，可以直接使用现代化的CSS来控制文本样式\n代码样式原样输出\u0026lt;pre\u0026gt;\u0026lt;/pre\u0026gt;\n2.4. form 表单 **form表单: 规定当提交表单时向何处发送表单数据 **\nmethod 提交的方法有get、post规定在发送表单数据之前如何对其进行编码。\nenctype属性可能的值\n​ application/x-www-form-urlencoded\u0026mdash;\u0026mdash;\u0026mdash;-默认值 ​ multipart form-data\u0026mdash;\u0026mdash;\u0026mdash;-使用文件上传标签需要使用这个值！！！ ​ text/plain\u0026mdash;\u0026mdash;\u0026mdash;表单数据将以纯文本格式发送（不常用）\ninput 标签 name：同样是表示的该文本输入框名称。\nsize：输入框的长度大小。\nmaxlength：输入框中允许输入字符的最大数。\nvalue：输入框中的默认值\nreadonly：表示该框中只能显示，不能添加修改。\ninput 的类型\ntype=password 密码输入框 type=file文件上传 type=hidden隐藏域 button按钮 checkbox复选框 radio单选框 type=submit提交按钮 type=reset重置按钮\n2.5. a 标签、img 标签、table 标签 a 标签的作用 a 标签的作用就是用于控制界面与页面之间的跳转 默认就是 self\nself：用于在当前选项卡中跳转，也就是不新建页面跳转 _blank ：用于在新的选项卡中跳转，也就是新建页面跳转 Eg: \u0026lt;a href=\u0026ldquo;http://www.baidu.com\u0026rdquo; target=\u0026ldquo;self\u0026rdquo;\u0026gt;百度\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026ldquo;http://www.baidu.com\u0026rdquo; target=\u0026quot;_blank\u0026rdquo;\u0026gt;百度\u0026lt;/a\u0026gt; _blank 在新窗口中打开被链接文档。 _self 默认。在相同的框架中打开被链接文档。 _parent 在父框架集中打开被链接文档。 _top 在整个窗口中打开被链接文档。 2.6. 锚文本 1.基本语法\n\u0026lt;a href=\u0026quot;#2\u0026quot;\u0026gt;锚点\u0026lt;/a\u0026gt;\n(1) 跳转到外部网页\n(2) 跳转到页面的某个位置\na.设置目标锚点\n使用 id 为目标元素标记位置：\n\u0026lt;h2 id=\u0026ldquo;section1\u0026rdquo;\u0026gt;这是目标位置\u0026lt;/h2\u0026gt;\nb.创建锚文本链接\n\u0026lt;a href=\u0026quot;#section1\u0026quot;\u0026gt;跳转到目标位置\u0026lt;/a\u0026gt;\n点击后页面会滚动到 id=\u0026ldquo;section1\u0026rdquo; 的位置\n(3) 打开本地文件或资源\n\u0026lt;a href=\u0026ldquo;files/document.pdf\u0026rdquo;\u0026gt;下载 PDF 文档\u0026lt;/a\u0026gt;\n点击后会打开或下载 document.pdf 文件，前提是文件路径正确。\n(4)发送邮件\n使用 mailto: 协议打开用户默认的邮件客户端：\n\u0026lt;a href=\u0026ldquo;mailto:example@example.com\u0026rdquo;\u0026gt;发送邮件\u0026lt;/a\u0026gt;\n点击后会打开邮件客户端并准备发送邮件。\n(5)拨打电话\n使用 tel: 协议实现点击拨号功能（通常用于移动设备）：\n\u0026lt;a href=\u0026ldquo;tel:+1234567890\u0026rdquo;\u0026gt;拨打电话\u0026lt;/a\u0026gt;\n点击后会启动拨号应用。\n添加属性扩展功能 （1）在新窗口打开链接\n通过 target=\u0026quot;_blank\u0026quot; 属性设置链接在新窗口或新标签页中打开：\n\u0026lt;a href=\u0026ldquo;https://www.example.com\u0026rdquo; target=\u0026quot;_blank\u0026quot;\u0026gt;访问 Example 网站\u0026lt;/a\u0026gt;\n（2）添加提示信息\n使用 title 属性提供鼠标悬停时的提示：\n\u0026lt;a href=\u0026ldquo;https://www.example.com\u0026rdquo; title=\u0026ldquo;点击访问 Example 网站\u0026rdquo;\u0026gt;访问 Example 网站\u0026lt;/a\u0026gt;\n（3）设置链接样式\n结合 CSS，改变锚文本的外观：\n\u0026lt;a href=\u0026ldquo;https://www.example.com\u0026rdquo; style=\u0026ldquo;color: red; text-decoration: none;\u0026quot;\u0026gt;访问 Example 网站\u0026lt;/a\u0026gt;\n（4）下载文件\n通过 download 属性提示浏览器下载文件而不是直接打开：\n\u0026lt;a href=\u0026ldquo;files/document.pdf\u0026rdquo; download\u0026gt;下载 PDF 文档\u0026lt;/a\u0026gt;\n\u0026lt;a name=\u0026ldquo;2\u0026rdquo;\u0026gt;锚点\u0026lt;/a\u0026gt;\n2.7. img 标签 img 元素向网页中嵌入一幅图像。 \u0026lt;img src=\u0026rdquo;../../../../../../../i/eg_tulip.jpg\u0026quot; alt=\u0026ldquo;上海鲜花港 - 郁金香\u0026rdquo; /\u0026gt;\nsrc：图片的来源（路径）。 这是必需属性，指向图片的 URL 或文件路径。 alt：图片的替代文本。 如果图片无法加载或被禁用，替代文本会显示在页面上，且对搜索引擎和无障碍工具（如屏幕阅读器）非常重要。 width 规定图片的高度 height 规定图片的宽度 2.8. table 表格 基本结构 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;列1\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;列2\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;列3\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;数据1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;数据2\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;数据3\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;table\u0026gt;：定义表格的容器。 \u0026lt;tr\u0026gt;：定义表格中的一行（row） \u0026lt;th\u0026gt;：定义表头单元格（通常加粗显示）。 \u0026lt;td\u0026gt;：定义表格中的普通单元格。\n显示效果 列1 列2 列3 数据1 数据2 数据3 **表格的标题** \u0026lt;caption\u0026gt;我的标题\u0026lt;/caption\u0026gt;\n表格属性\n1.border：设置表格边框宽度。\n2.cellpadding：设置单元格内边距。\n3.cellspacing：设置单元格间距。\n4.width 和 height：设置表格宽高。\n5.align：设置表格对齐方式（不推荐，建议用 CSS）。\n表格样式\u0026mdash;推荐用CSS\n可以通过 CSS 自定义表格样式，例如\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;style\u0026gt; table { border-collapse: collapse; /* 合并边框 */ width: 100%; } th, td { border: 1px solid black; text-align: center; /* 居中对齐 */ padding: 10px; /* 内边距 */ } th { background-color: #f2f2f2; /* 设置表头背景色 */ } \u0026lt;/style\u0026gt; 合并单元格\n行合并：使用 rowspan 属性。\n示例代码 1 2 3 4 5 6 7 8 9 \u0026lt;table border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th rowspan=\u0026#34;2\u0026#34;\u0026gt;合并两行\u0026lt;/th\u0026gt; \u0026lt;td\u0026gt;数据1\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;数据2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 合并两行 数据1 数据2 列合并：使用 colspan 属性。\n示例代码\n1 2 3 4 5 6 7 8 9 \u0026lt;table border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th colspan=\u0026#34;2\u0026#34;\u0026gt;合并两列\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;数据1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;数据2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 合并两列 数据1 数据2 2.9 列表标签 HTML 提供两种主要的列表形式：无序列表和有序列表，以及一种常用的描述列表。\n1. 无序列表 \u0026lt;ul\u0026gt;\n定义：无序列表用\u0026lt;ul\u0026gt; 表示，列表项用 \u0026lt;li\u0026gt; 包裹。\n特点：项目符号默认是圆点（disc），可以自定义样式。\ndisc：默认圆点。\ncircle：空心圆。\nsquare：方块。\n基本语法\n1 2 3 4 5 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;项目 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;项目 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;项目 3\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 显示效果\n项目 1 项目 2 项目 3 2. 有序列表 \u0026lt;ol\u0026gt;\n定义：有序列表用 \u0026lt;ol\u0026gt; 表示，列表项用 \u0026lt;li\u0026gt; 包裹。\n特点：项目符号为数字或字母，按顺序排列。\n基本语法\n1 2 3 4 5 \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;项目 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;项目 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;项目 3\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 显示效果\n项目 1 项目 2 项目 3 自定义项目符号类型\n1：默认数字 (1, 2, 3…)。\nA：大写字母 (A, B, C…)。\na：小写字母 (a, b, c…)。\nI：大写罗马数字 (I, II, III…)。\ni：小写罗马数字 (i, ii, iii…)。\n样例\n1 2 3 4 5 6 7 8 \u0026lt;ol type=\u0026#34;A\u0026#34;\u0026gt; \u0026lt;li\u0026gt;大写字母\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;大写字母\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;ol type=\u0026#34;i\u0026#34;\u0026gt; \u0026lt;li\u0026gt;小写罗马数字\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;小写罗马数字\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 起始编号\n通过 start 属性设置起始编号：\n1 2 3 4 \u0026lt;ol start=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;li\u0026gt;从数字 5 开始\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;从数字 6 开始\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 3. 描述列表 \u0026lt;dl\u0026gt;\n定义：描述列表用\u0026lt;dl\u0026gt; 表示，包含描述项\u0026lt;dt\u0026gt; 和描述内容\u0026lt;dd\u0026gt;。\n用途：用于术语解释、属性说明等场景。\n基本语法\n1 2 3 4 5 6 \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;HTML\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;超文本标记语言\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;CSS\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;层叠样式表\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; 显示效果\nHTML 超文本标记语言 CSS 层叠样式表 4. 嵌套列表\n可以将列表嵌套在另一个列表中，支持任意深度。\n1 2 3 4 5 6 7 8 9 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;项目 1 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;子项目 1.1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;子项目 1.2\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;项目 2\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 显示效果\n项目 1 子项目 1.1 子项目 1.2 项目 2 5. CSS 样式定制列表\n5.1 自定义项目符号 可以通过 CSS 设置 list-style-type 或使用图片作为符号：\n1 2 3 \u0026lt;ul style=\u0026#34;list-style-image: url(\u0026#39;bullet.png\u0026#39;);\u0026#34;\u0026gt; \u0026lt;li\u0026gt;自定义符号\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 5.2 删除项目符号 设置 list-style: none; 可以移除符号：\n1 2 3 \u0026lt;ul style=\u0026#34;list-style: none;\u0026#34;\u0026gt; \u0026lt;li\u0026gt;无符号项目\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 5.3 设置列表间距 可以通过 margin 和 padding 调整：\n1 2 3 \u0026lt;ul style=\u0026#34;margin: 20px; padding: 10px;\u0026#34;\u0026gt; \u0026lt;li\u0026gt;调整间距\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 6. 特殊用法 6.1 自定义编号 通过 CSS 和伪元素创建完全自定义的编号样式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;普通样式\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;普通样式\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;style\u0026gt; ol { counter-reset: custom-counter; /* 初始化计数器 */ } ol \u0026gt; li { counter-increment: custom-counter; /* 递增计数器 */ } ol \u0026gt; li::before { content: \u0026#34;★ \u0026#34; counter(custom-counter) \u0026#34;. \u0026#34;; /* 自定义编号样式 */ color: red; } \u0026lt;/style\u0026gt; 2.10. 框架的使用 1. 基本结构\n使用 \u0026lt;frameset\u0026gt; 标签代替 \u0026lt;body\u0026gt;，通过 \u0026lt;frame\u0026gt; 标签定义每个框架的内容。\ncols 定义框架集中列的数目和尺寸 rows 定义框架集中行的数目和尺寸\n示例：两列布局\n1 2 3 4 \u0026lt;frameset cols=\u0026#34;50%,50%\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;left.html\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;right.html\u0026#34;\u0026gt; \u0026lt;/frameset\u0026gt; 说明：\n•\t\u0026lt;frameset\u0026gt;：定义框架的布局方式，取代 \u0026lt;body\u0026gt;。 •\tcols：定义列布局（水平分割），可用像素、百分比或 *。 •\trows：定义行布局（垂直分割），用法与 cols 类似。 •\t\u0026lt;frame\u0026gt;：定义每个框架加载的页面。 •\tsrc：指定每个框架加载的内容，可以是 HTML 文件或其他资源。\n2. 常见布局方式\n2.1 水平分割页面\n1 2 3 4 \u0026lt;frameset rows=\u0026#34;70%,30%\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;top.html\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;bottom.html\u0026#34;\u0026gt; \u0026lt;/frameset\u0026gt; 2.2 网格式布局\n1 2 3 4 5 6 7 \u0026lt;frameset rows=\u0026#34;50%,50%\u0026#34;\u0026gt; \u0026lt;frameset cols=\u0026#34;50%,50%\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;top-left.html\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;top-right.html\u0026#34;\u0026gt; \u0026lt;/frameset\u0026gt; \u0026lt;frame src=\u0026#34;bottom.html\u0026#34;\u0026gt; \u0026lt;/frameset\u0026gt; 3. 嵌套框架\n框架可以嵌套实现复杂布局。\n示例：上下左右分割页面\n1 2 3 4 5 6 7 \u0026lt;frameset rows=\u0026#34;80,*\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;header.html\u0026#34;\u0026gt; \u0026lt;frameset cols=\u0026#34;30%,70%\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;menu.html\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;content.html\u0026#34;\u0026gt; \u0026lt;/frameset\u0026gt; \u0026lt;/frameset\u0026gt; 4. 添加边框、滚动和标题\n框架可以通过属性设置样式：\nframeborder：设置边框（0 表示无边框）。\nscrolling：设置是否显示滚动条（yes、no、auto）。\nname：给框架命名，便于其他页面的链接跳转。\n示例\n1 2 3 4 \u0026lt;frameset cols=\u0026#34;70%,30%\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;content.html\u0026#34; name=\u0026#34;main\u0026#34; frameborder=\u0026#34;1\u0026#34; scrolling=\u0026#34;yes\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;menu.html\u0026#34; name=\u0026#34;menu\u0026#34; frameborder=\u0026#34;0\u0026#34; scrolling=\u0026#34;no\u0026#34;\u0026gt; \u0026lt;/frameset\u0026gt; 5. 框架中的链接跳转\n框架中的链接可以指定目标框架加载内容，通过 target 属性实现：\n示例：\n1 2 3 4 \u0026lt;frameset cols=\u0026#34;20%,80%\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;menu.html\u0026#34; name=\u0026#34;menu\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;content.html\u0026#34; name=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;/frameset\u0026gt; menu.html 中的链接：\n1 2 \u0026lt;a href=\u0026#34;page1.html\u0026#34; target=\u0026#34;main\u0026#34;\u0026gt;加载 Page 1\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;page2.html\u0026#34; target=\u0026#34;main\u0026#34;\u0026gt;加载 Page 2\u0026lt;/a\u0026gt; 6. 替代方案：使用现代技术\n由于框架的以下问题，HTML5 废弃了 \u0026lt;frameset\u0026gt; 和 \u0026lt;frame\u0026gt;：\n•\t不利于 SEO（搜索引擎无法有效索引）。 •\t用户体验差，不能轻松导航和书签管理。 •\t兼容性问题。 推荐使用现代技术：\n1.\tCSS Flexbox 和 Grid Layout：布局灵活且易于控制。 2.\t\u0026lt;iframe\u0026gt; 标签：加载独立页面到当前页面中。 示例：\u0026lt;iframe\u0026gt; 使用\n1 \u0026lt;iframe src=\u0026#34;page.html\u0026#34; width=\u0026#34;100%\u0026#34; height=\u0026#34;500px\u0026#34; frameborder=\u0026#34;0\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; ","date":"2024-11-12T20:43:19+08:00","permalink":"http://localhost:1313/p/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/","title":"网络安全"},{"content":"title=\u0026ldquo;Markdown语法\u0026rdquo;\n什么是MarkDown语法？ Markdown 致力于使阅读和创作文档变得容易。\nMarkdown是一种轻量级的标记语言，设计初衷是让人们可以使用简单的文本格式来书写和编辑文档，同时具有一定的格式化效果。通过使用Markdown语法，用户可以快速地将纯文本转换为格式化的文档，例如标题、列表、链接、图片等。Markdown语法简单直观，易于学习和使用，逐渐成为了各种平台上书写文档的常用格式，甚至还可以实现Markdown文档对PDF、Word等格式的快速转换。\nMarkdown的文件通常以.md或.markdown为扩展名\n我们可以创建一个TXT文本文档，然后将其后缀改为.md即可开始编辑此Markdown文档。\n基础语法讲解 段落和换行 Markdown文档与我们常见的Word文档或是TXT文档类似，只需要直接输入内容，就可以展示了：\n[][https://oss.itbaima.cn/internal/markdown/2024/04/01/HVqab9QUm4vw73P.png]\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/","title":""},{"content":"计算机发展历程 什么计算机系统 计算机系统=硬件+软件 硬件：计算机的实体，如主机、外设等 软件：由具有各类特殊作用的程序组成 计算机性能的好坏取决于“软”、“硬”件功能的总和 软件可以分为系统软件和应用软件 系统软件：用来管理整个计算机系统\u0026mdash;如操作系统、数据库管理系统（DBMS）、标准程序库、网络软件、语言处理程序、服务程序 应用软件：微信、哔哩哔哩等\u0026hellip; \u0026hellip; 硬件的发展 第一台计算机 台电子数字计算机：ENIAC(1946) 占地面积约170平方米 耗电量150千瓦 运算速度：5000次加法/秒 逻辑元件：电子管 四代计算机 发展阶段 时间 逻辑元件 速度(次/秒) 内存 外存 第一代 1946-1957 电子管 几千-几万 汞延迟线、磁鼓 穿孔卡片、纸带 第二代 1958-1964 晶体管 几万-几十万 磁芯存储器 磁带 第三代 1964-1971 中小规模集成 电路 几十万-几百万 半导体存储器 第四代 1972-现在 大规模、超大 规模集成电路 上千万-万亿 半导体存储器 磁盘、磁带、光盘、半导体存储器 各代计算机特点 第一代：电子管时代体积超大、耗电量超大 使用机器语言编程 逻辑元件：电子管 第二代：晶体管时代 体积、功耗降低 出现面向过程的程序设计语言：FORTRAN 有了操作系统雏形 逻辑元件：晶体管 第三代：中小规模集成电路时代 计算机主要用于科学计算等专业用途 高级语言迅速发展 开始有了分时操作系统 将元件集成在基片上 第四代：大规模、超大规模集成电路时代 开始出现“微处理器”、微型计算机个人计算机（PC）萌芽 操作系统：Windows、MacOS、Linux Eg：苹果A13制造工艺：7nm （每个元件宽度7nm） 拥有85亿个晶体管 微处理器的发展 微处理器的发展：微型计算机的发展以微处理器技术为标志 机器字长：计算机一次整数运算所能处理的二进制位数\n1947年，贝尔实验室，发明了“晶体管〞 1955年，肖克利在硅谷创建 肖克利实验室股份有限公司 1957年，八叛徒（traitorous eight）创立 仙童半导体公司 1959年，仙童半导体公司发明“集成电路“ 1968年，摩尔等人离开仙童，创立 Intel 1969年，仙童销售部负责人桑德斯离开仙童，创立 AMD 摩尔定律 摩尔定律揭示了信息技术进步的速度 集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，整体性能也将提升一倍 半导体存储器的发展 1970年，仙童公司生产出第一个较大容量的半导体存储器 半导体存储器单芯片容量：1KB、4KB、16KB、64KB、256KB、1MB、4MB、16MB、64MB、 256MB, 1GB\u0026hellip; 计算机硬件的基本组成 早期冯诺依曼机 “存储程序” “存储程序”的概念是指将指令以二进制代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。\n冯诺伊曼计算机的基本逻辑（注意流程图）\n输入设备：将信息转换成机器能识别的形式 存储器：存放数据和程序 运算器：算术运算逻辑运算 输出设备：将结果转换成人们熟悉的形式 控制器：指挥程序运行\n在计算机系统中，软件和硬件在逻辑上是等效的。 为什么说是等效的？：对于乘法运算，可以设计一个专门的硬件电路实现乘法运算也可以用软件的方式，执行多次加法运算来实现\n冯•诺依曼计算机的特点：\n计算机由五大部件组成 指令和数据以同等地位存于存储器，可按地址寻访（后文会有详细介绍） 指令和数据用二进制表示 指令由操作码（指明这条指令要干什么）和地址码（指明对哪一个内存单元进行操作）组成 存储程序 以运算器为中心（输入/输出设备与存储器之间的数据传送通过运算器完成） 现代计算机的结构 现代计算机：以存储器为中心 (输入设备直接放到存储器中) CPU=运算器+控制器 存储器=主存+辅存 (Eg:手机中的APP平常就存在辅存中，只有使用的时候才会调到主存) 主机=主存+CPU I/O设备=辅存+输入设备+输出设备 硬件=主机+I/O设备 Eg:像平常说的，手机内存8gb，指的就是主存储器是8gb ，机身存储128gb，就是指的辅存\n现代计算机简化图： 各个硬件的工作原理 主存储器的基本组成 主存储器=存储体+MAR+MDR Memory Address Register （存储地址寄存器） Memory Data Register （存储数据寄存器）\n寄存器：存放二进制数据\n存储单元：每个存储单元存放一串二进制代码 存储字（word）：存储单元中二进制代码的组合（一个字根据不同电脑的设置，大小是不一样的） 存储字长：存储单元中二进制代码的位数 存储元：即存储二进制的电子元件，每个存储元可存 1bit\nMAR位数反映存储单元的个数\n数据在存储体内按地址存储\nMDR位数=存储字长\n例： MAR=4位 总共有24个存储单元 MDR=16位 每个存储单元可存放16bit， 1个字(word) = 16bit 易混淆：1个字节（Byte）= 8bit 1B=1个字节，1b=1个bit\n运算器的基本组成 运算器：用于实现算术运算（如：加减乘除）、逻辑运算（如：与或非） ACC:累加器，用于存放操作数，或运算结果。 MQ:乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。 X:通用的操作数寄存器，用于存放操作数 ALU:算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算 加 减 乘 除 ACC 被加数、和 被减数、差 乘积高位 MQ 乘数、乘积低位 X 加数 减数 被乘数 ACC:Accumulator MQ:Multiple-Quotient Register ALU:Arithmetic and Logic Unit 控制器的基本组成 控制器由CU、IR和PC组成： CU：控制单元，分析指令，给出控制信号 IR：指令寄存器，存放当前执行的指令 PC：程序计数器，存放下一条指令地址，有自动加1功能 Control Unit Instruction Register Program Counter 完成一条指令：取指令-\u0026gt;分析指令-\u0026gt;执行指令 取指=PC+IR CU 执行 计算机的工作过程 PC 主存地址 指令 注释 0 操作码：000001 地址码：0000000101 取数a至ACC 1 操作码：000100 地址码：0000000110 乘得ab，存于ACC中 2 操作码：000011 地址码：0000000111 加c得ab+c，存于ACC中 3 操作码000010 地址码：0000001000 将ab+c.存于主存单元 4 操作码：000110 地址码：0000000000 停机 5 0000000000000010 原始数据a=2 6 0000000000000011 原始数据b=3 7 0000000000000001 原始数据c=1 8 0000000000000000 原始数据y=0 流程图 注：取指令（#1~#4） 分析指令（#5） 执行取数指令（#6~#9）\n初：（PC）=0，指向第一条指令的存储地址 #1: (PC)→MAR, 导致(MAR)=0 #3: M(MAR)→MDR, 导致(MDR)=000001 0000000101 #4: (MDR)→IR, 导致(|R)=000001 0000000101 #5:OP(IR)→CU，指令的操作码送到CU，CU分析后得知，这是“取数”指令 #6:Ad(IR)→MAR，指令的地址码送到MAR，导致（MAR）=5 #8: M(MAR)→MDR, 导致(MDR)=0000000000000010=2 #9: (MDR)→ACC, 导致(ACC)=0000000000000010=2\n取指令（#1~#4） 分析指令（#5） 执行乘法指令（#6~#11）\n上一条指令取指后PC自动+1，（PC）=1；执行后，（ACC）=2 #1: (PC)→MAR, 导致(MAR)=1 #3: M(MAR)→MDR, 导致(MDR)=000100 0000000110 #4: (MDR)→IR, 导致(IR)= 000100 0000000110 #5:OP（IR）\u0026gt;CU，指令的操作码送到CU，CU分析后得知，这是“乘法”指令 #6：Ad（IR）\u0026gt;MAR，指令的地址码送到MAR，导致（MAR）=6 #8: M(MAR)→MDR, 导致(MDR)=0000000000000011=3 #9：(MDR)→MQ，导致(MQ)=0000000000000011=3 #10：(ACC)X，导致(X)=2 #11：(MQ)*(X)→ACC，由ALU实现乘法运算，导致（ACC）=6，如果乘积太大，则需要MQ辅助存储\n取指令（#1~#4） 分析指令（#5） 执行加法指令（#6~#10）\n上一条指令取指后（PC）=2，执行后，（ACC）=6 #1：(PC)→MAR，导致（MAR）=2 #3: M(MAR)→MDR, 导致(MDR)= 000011 0000000111 #4：(MDR)→IR，导致(IR)= 000011 0000000111 #5:OP(IR)→CU，指令的操作码送到CU，CU分析后得知，这是“加法”指令 #6:Ad(IR)→MAR，指令的地址码送到MAR，导致（MAR）=7 #8: M(MAR) →MDR, 导致(MDR)=0000000000000001=1 #9: (MDR)→X, 导致(X)=0000000000000001=1 #10：（ACC）+（X） ACC，导致（ACC）=7，由ALU实现加法运算\n取指令（#1~#4） 分析指令（#5） 执行存数指令（#6~#9）\n上一条指令取指后（PC）=4 #1: (PC)→MAR, 导致(MAR)=3 #3: M(MAR)→MDR, 导致(MDR)=000110 00000 #4：(MDR)→IR，导致(IR)= 000110 0000000000 #5:OP(IR)→ CU，指令的操作码送到CU，CU分析后得知，这是“停机”指令 （利用中断机制通知操作系统终止该进程）\n注：现在的计算机通常把MAR、MDR也集成在CPU中\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/","title":"计算机组成原理"}]