[{"content":"MarkDown语法 Markdown 致力于使阅读和创作文档变得容易。\nMarkdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。\nMarkdown的文件通常以.md或.markdown为扩展名\n我们可以创建一个TXT文本文档，然后将其后缀改为.md即可开始编辑此Markdown文档。\n基础语法讲解 首先我们需要一个软件来书写markdown，一般选择Typora，另外，Idea也支持Typora。\n段落和换行 换行效果： 在上一行的末尾连续添加两个空格，然后再换行。 换段效果： 连续换两行。 加粗和斜体 想要使得文本加粗，我们只需要在需要加粗文本两边添加两个星号即可，或是使用两个下划线，效果相同 斜体与加粗类似，我们只需在需要斜体的文本两边添加一个星号即可，同样也可以使用一个下划线代替，效果相同。 如果需要同时使用加粗和斜体，我们可以直接使用连续的三个星号或是下划线。 和c语言一样，如果知识单纯想使用*等符号，可以使用转义字符，也就是在前面加上反斜杠\u0026quot;\u0026quot;。 删除线 实现删除线的效果，我们只需要在需要加删除线的文本两边添加两个~波浪线即可 下划线 在markdown原生语法中是没有下划线的，但可以借助于HTML中的语法，也就是\u0026hellip;..这样的形式。 分割线 单独使用三个星号即可实现，同样，下划线也可以。 标题 可以使用#井号来实现标题，两个井号代表二级标题，以此类推。 还有另外一种方式，可以在一段文字下面打上=等号和-减号分别代表一级标题和二级标题快速创建。 列表 要创建一个无序列表，我们只需要使用星号作为前缀，注意需要空格,可以用+加号和-减号来代替，但是，如果混用会显示为几个不同的列表。 如果想要创建一个带有数字的有序列表，可以用数字加点的形式来实现。 在列表中换行同样需要像普通文本那样，如果只是单纯换行编写，会被认为是一个空格；如果是在末尾添加两个空格再换行，会被认为是在列表项内换行；只有两个连续的换行才能脱离列表，作为新的段落开始编写。 列表可以设置层级嵌套，可以在一级列表下创建二级列表，需要在前面添加两个或四个空格（也可以是一个TAB缩进）。 勾选框 勾选框：需要在列表的形式下添加一个方括号，方括号里加x则代表此勾选框已勾选。 代码块 要创建一个代码块，只需要在本行的最前面添加四个空格即可，注意代码块要与上面的其他文本隔开一行。 还有另一种更加简便的方法，可以用三个连续的`符号将代码块包起来即可。 在三个`后可以添加语言名称，markdown编辑器可以进行识别。 引用 使用\u0026gt;大于符号进行引用 和列表一样，也需要进行两次换行脱离引用块。 引用中，可以进行嵌套，例如列表和代码块，甚至引用本身。 链接 在Markdown文档中插入超链接，只需要使用[]和()组合就能完成，格式为[链接文本](链接地址)。 有些时候可能我们的文档中有很多链接，甚至还有重复，此时一个一个编写相当费时间，而且源代码中满屏的链接显得相当杂乱，我们可以利用变量来优化这种情况，变量可以在文章的末尾再确定值。 图片 语法于链接类似：!图片描述 注意：只能使用本地图片地址或是网络图片地址。 图片和链接一样，都可以使用变量。 脚注 语法：曼联[^1]又赢了✌️。 [^1]: 世界上最好的俱乐部。 鼠标移动上去时也会展示脚注内容。 表格 Eg.| 名称 | 年龄 | 性别 | | \u0026mdash; | \u0026mdash; | \u0026mdash; | 最上一排就是表头，需要在左右使用|表示这是一个表格，同时，下方需要添加分割线，分割线使用-减号表示，写一个或多个都可以，推荐与表的宽度一致，更加美观。这样，就可以顺利展示为一个表格了 :\u0026mdash; 为左对齐 \u0026mdash;: 为右对齐 :\u0026mdash;: 为居中对齐 表格中也可以嵌套使用诸如加粗、斜体、行内代码块这类Markdown语法 HTML标签 markdown中可以支持HTML中的一些语法 内嵌iframe页面，可以实现B站视频播放 其他扩展语法 文本高亮，使用两个=等号包括 文本的上标和下标分别可以使用单个^和~包括来实现 数学公式语法 公式块 需要编写数学公式，我们同样需要在特定的块中编写，公式块使用$美元符表示。多行公式使用连续的两个美元符 行内编写，一行内容只需要使用一个美元符包括即可 特殊数学符号 代码 符号 描述 \\not= ≠ 不等于 \\approx ≈ 约等于 \\times × 乘号 ｜\\div ÷ 除号 \\leq ≤ 小于等于 \\geq ≥ 大于等于 \\pm ± 正负号 \\sum ∑ 求和符号（累加） \\prod ∏ 累乘 \\coprod ∐ 累除 \\overline{a + b + c} 平均值 数学中常见特殊字符: 代码 符号 代码 符号 \\alpha α \\beta β \\gamma γ \\delta δ ｜\\epsilon ϵ \\eta η \\theta θ \\pi π \\omega ω \\rho ρ \\sigma σ \\mu μ 还有我们数学中常见的三角函数相关: 代码 符号 描述 \\sin sin 正弦 \\cos cos 余弦 \\tan tan 正切 \\cot cot 余切 \\sec sec 正割 \\csc csc 余割 \\circ ∘ 度 积分和求导相关: 代码 符号 描述 \\infty ∞ 无穷 \\int ∫ 定积分 \\iint ∬ 双重积分 \\iiint ∭ 三重积分 \\oint ∮ 曲线积分 x\\prime x′ 求导 \\lim lim 极限 集合相关: 代码 符号 描述 \\emptyset ∅ 空集 \\in ∈ 不属于 \\notin ∉ 双重积分 \\supset ⊃ 真包含 \\supseteq ⊇ 包含 \\bigcap ⋂ 交集 \\bigcup ⋃ 并集 对数函数相关： 代码 符号 描述 \\log log 对数函数 \\ln ln 以e为底的对数函数 \\lg lg 以10为底的对数函数 分数 格式：$ \\frac{分子}{分母} $ 开方 格式：$\\sqrt{4}$ 若要修改几次根号：$\\sqrt[3]{8}$ 上下标 在公式块中的上下标与Markdown中的不同，语法也不一样，其中^表示上标， _ 表示下标 如果上标或下标内容多于一个字符，需要使用 {} 括起来，包括后续的其他代码如果出现只有一个字符生效的情况下，考虑使用花括号包括全部内容 积分和极限 积分格式：$ \\int_1^2xdx $ 极限格式：$ \\lim_{n\\rightarrow+\\infty}\\frac{1}{n + 1} $ 其他符号 向量符号：$ \\vec{a} $ 省略号：$ \\cdots $ 居中省略号 $ \\ldots $ 靠底部的省略号 点乘号：$ \\cdot $ 累加：$ \\sum_1^n $ ","date":"2024-11-12T20:43:19+08:00","permalink":"https://Manunited.github.io/p/mark-down%E8%AF%AD%E6%B3%95/","title":"Mark Down语法"},{"content":"计算机发展历程 什么计算机系统 计算机系统=硬件+软件 硬件：计算机的实体，如主机、外设等 软件：由具有各类特殊作用的程序组成 计算机性能的好坏取决于“软”、“硬”件功能的总和 软件可以分为系统软件和应用软件 系统软件：用来管理整个计算机系统\u0026mdash;如操作系统、数据库管理系统（DBMS）、标准程序库、网络软件、语言处理程序、服务程序 应用软件：微信、哔哩哔哩等\u0026hellip; \u0026hellip; 硬件的发展 第一台计算机 台电子数字计算机：ENIAC(1946) 占地面积约170平方米 耗电量150千瓦 运算速度：5000次加法/秒 逻辑元件：电子管 四代计算机 发展阶段 时间 逻辑元件 速度(次/秒) 内存 外存 第一代 1946-1957 电子管 几千-几万 汞延迟线、磁鼓 穿孔卡片、纸带 第二代 1958-1964 晶体管 几万-几十万 磁芯存储器 磁带 第三代 1964-1971 中小规模集成 电路 几十万-几百万 半导体存储器 第四代 1972-现在 大规模、超大 规模集成电路 上千万-万亿 半导体存储器 磁盘、磁带、光盘、半导体存储器 各代计算机特点 第一代：电子管时代体积超大、耗电量超大 使用机器语言编程 逻辑元件：电子管 第二代：晶体管时代 体积、功耗降低 出现面向过程的程序设计语言：FORTRAN 有了操作系统雏形 逻辑元件：晶体管 第三代：中小规模集成电路时代 计算机主要用于科学计算等专业用途 高级语言迅速发展 开始有了分时操作系统 将元件集成在基片上 第四代：大规模、超大规模集成电路时代 开始出现“微处理器”、微型计算机个人计算机（PC）萌芽 操作系统：Windows、MacOS、Linux Eg：苹果A13制造工艺：7nm （每个元件宽度7nm） 拥有85亿个晶体管 微处理器的发展 微处理器的发展：微型计算机的发展以微处理器技术为标志 机器字长：计算机一次整数运算所能处理的二进制位数\n1947年，贝尔实验室，发明了“晶体管〞 1955年，肖克利在硅谷创建 肖克利实验室股份有限公司 1957年，八叛徒（traitorous eight）创立 仙童半导体公司 1959年，仙童半导体公司发明“集成电路“ 1968年，摩尔等人离开仙童，创立 Intel 1969年，仙童销售部负责人桑德斯离开仙童，创立 AMD 摩尔定律 摩尔定律揭示了信息技术进步的速度 集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，整体性能也将提升一倍 半导体存储器的发展 1970年，仙童公司生产出第一个较大容量的半导体存储器 半导体存储器单芯片容量：1KB、4KB、16KB、64KB、256KB、1MB、4MB、16MB、64MB、 256MB, 1GB\u0026hellip; 计算机硬件的基本组成 早期冯诺依曼机 “存储程序” “存储程序”的概念是指将指令以二进制代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。 冯诺伊曼计算机的基本逻辑（注意流程图） 输入设备：将信息转换成机器能识别的形式 存储器：存放数据和程序 运算器：算术运算逻辑运算 输出设备：将结果转换成人们熟悉的形式 控制器：指挥程序运行 在计算机系统中，软件和硬件在逻辑上是等效的。 Eg：对于乘法运算，可以设计一个专门的硬件电路实现乘法运算也可以用软件的方式，执行多次加法运算来实现 冯•诺依曼计算机的特点：\n计算机由五大部件组成 指令和数据以同等地位存于存储器，可按地址寻访 指令和数据用二进制表示 指令由操作码和地址码组成 存储程序 以运算器为中心（输入/输出设备与存储器之间的数据传送通过运算器完成） 现代计算机的结构 现代计算机：以存储器为中心 CPU=运算器+控制器 存储器=主存+辅存 主机=主存+CPU I/O设备=辅存+输入设备+输出设备 硬件=主机+I/O设备\n各个硬件的工作原理 主存储器的基本组成 主存储器=存储体+MAR+MDR Memory Address Register （存储地址寄存器） Memory Data Register （存储数据寄存器） 存储单元：每个存储单元存放一串二进制代码 存储字（word）：存储单元中二进制代码的组合 存储字长：存储单元中二进制代码的位数 存储元：即存储二进制的电子元件，每个存储元可存 1bit MAR位数反映存储单元的个数 数据在存储体内按地址存储 MDR位数=存储字长 例： MAR=4位 总共有24个存储单元 MDR=16位 每个存储单元可存放16bit， 117 (word) = 16bit 易混淆：1个字节（Byte）= 8bit 1B=1个字节，1b=1个bit 运算器的基本组成 运算器：用于实现算术运算（如：加减乘除）、逻辑运算（如：与或非） ACC:累加器，用于存放操作数，或运算结果。 MQ:乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。 X:通用的操作数寄存器，用于存放操作数 ALU:算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算 加 减 乘 除 ACC 被加数、和 被减数、差 乘积高位 MQ 乘数、乘积低位 X 加数 减数 被乘数 ACC:Accumulator MQ:Multiple-Quotient Register ALU:Arithmetic and Logic Unit 控制器的基本组成 控制器由CU、IR和PC组成： CU：控制单元，分析指令，给出控制信号 IR：指令寄存器，存放当前执行的指令 PC：程序计数器，存放下一条指令地址，有自动加1功能 Control Unit Instruction Register Program Counter 完成一条指令：取指令-\u0026gt;分析指令-\u0026gt;执行指令 取指=PC+IR CU 执行 计算机的工作过程 主存地址 指令 注释 0 操作码：000001 地址码：0000000101 取数a至ACC 1 操作码：000100 地址码：0000000110 乘得ab，存于ACC中 2 操作码：000011 地址码：0000000111 加c得ab+c，存于ACC中 3 操作码000010 地址码：0000001000 将ab+c.存于主存单元 4 操作码：000110 地址码：0000000000 停机 5 0000000000000010 原始数据a=2 6 0000000000000011 原始数据b=3 7 0000000000000001 原始数据c=1 8 0000000000000000 原始数据y=0 ","date":"2024-11-12T20:43:19+08:00","permalink":"https://Manunited.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/","title":"计算机组成原理"},{"content":"数据结构基本概念 数据 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。 数据元素、数据项 数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。 一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。 数据结构、数据对象： 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。 数据对象是具有相同性质的数据元素的集合，是数据的一个子集。 数据结构的三要素 逻辑结构，物理结构（存储结构），数据的运算。 逻辑结构 集合：各个元素同属一个集合，别无其他关系 线性结构：数据元素之间是一对一的关系。除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继 树形结构：数据元素之间是一对多的关系 图结构：数据元素之间是多对多的关系 物理结构（存储结构） 顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储 单元的邻接关系来体现。 链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。 索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址） 散列存储。根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储 其中，链式存储、索引存储、散列存储也并称为非顺序存储\n以下几点需要注意 若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用 非顺序存储，则各个数据元素在物理上可以是离散的。 数据的存储结构会影响存储空间分配的方便程度 数据的存储结构会影响对数据运算的速度 数据的运算 施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的， 指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。\n数据类型、抽象数据类型 数据类型是一个值的集合和定义在此集合上的一组操作的总称。 1）原子类型。其值不可再分的数据类型。 2）结构类型。其值可以再分解为若干成分（分量）的数据类型。 抽象数据类型（Abstract Data Type，ADT）是抽象数据组织及与之相关的操作。\nADT 用数学化的语言定义数据的逻辑结构、定义运算。与具体的实现无关。 算法的基本概念 什么是算法 程序 = 数据结构（如何用数据正确地描述现实世界的问题，并存入计算机） + 算法（如何高效地处理这些数据，以解决实际问题） 算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令 表示一个或多个操作 算法的特性 有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。用有限步骤解决某个特定的问题 注：算法必须是有穷的，而程序可以是无穷的 确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。 “好”算法的特性 设计算法时尽量遵循的目标\n正确性。算法应能够正确地解决求解问题。 可读性。算法应具有良好的可读性，以帮助人们理解。 健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。 高效率与低存储量需求 算法效率的度量 如何评估算法时间开销 算法时间复杂度： 事前预估算法时间开销T(n)与问题规模 n 的关系（T 表示 “time”） 例子：用算法表白——“爱你n遍” 1 2 3 4 5 6 7 8 void loveyou(int n){ ①int i; ②while(i\u0026lt;=n){ ③i++; ④cout\u0026lt;\u0026lt;\u0026#34;I Love You %d\u0026#34;\u0026lt;\u0026lt;endl; } ⑤cout\u0026lt;\u0026lt;\u0026#34;I Love You More Than %d\u0026#34;\u0026lt;\u0026lt;endl; } 语句频度： ① ——1次 ② ——3001次 ③④ ——3000次 ⑤ ——1次 T(3000) = 1 + 3001 + 2*3000 + 1 时间开销与问题规模 n 的关系： T(n)=3n+3\n结论：1.可以只考虑阶数高的部分\n2.问题规模足够大时，常数项系数也可以忽略 加法规则和乘法规则 a）加法规则 T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n))) b）乘法规则 T(n) = T1(n)×T2(n) = O(f(n))×O(g(n)) = O(f(n)×g(n)) Eg：T3(n)= n3 + n2 log2n = O(n3) + O(n2 log2n) = ？？？\n1.顺序执行的代码只会影响常数项，可以忽略 2.只需挑循环中的一个基本操作分析它的执行次数与 n 的关系即可 3.如果有多层嵌套循环，只需关注最深层循环循环了几次 最坏时间复杂度：最坏情况下算法的时间复杂度 平均时间复杂度：所有输入示例等概率出现的情况下，算法的期望运行时间 最好时间复杂度：最好情况下算法的时间复杂度 程序运行时的内存需求 无论问题规模怎么变，算法运行所需的内存空间都是固定的常量，算法空间复杂度为S(n) = O(1) 注：S 表示 “Space”算法原地工作——算法所需内存空间为常量 O(1) \u0026lt; O(log2n) \u0026lt; O(n) \u0026lt; O(nlog2n) \u0026lt; O(n2) \u0026lt; O(n3) \u0026lt; O(2n) \u0026lt; O(n!) \u0026lt; O(nn) 函数递归带来的内存开销 空间复杂度 = 递归调用的深度\n线性表 线性表定义、基本操作 定义 线性表是具有相同数据类型的n（n≥0）个数据元素的有限 序列，其中n为表长，当n = 0时线 性表是一个空表。若用L命名线性表，则其一般表示为L = (a1, a2, \u0026hellip; , ai, ai+1, \u0026hellip; , an) 几个概念： ai 是线性表中的“第i个”元素线性表中的位序 a1 是表头元素；an 是表尾元素。 除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继 a1 a2 a3 a4 a5 有次序 注意：位序从1开始 数组下标从0开始 每个数据元素所占空间一样大 基本操作 InitList(\u0026amp;L):初始化表。构造一个空的线性表L，分配内存空间。\nDestroyList(\u0026amp;L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。\nListInsert(\u0026amp;L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e。\nListDelete(\u0026amp;L,i,\u0026amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。\nLocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。\nGetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。\n其他常用操作：\nLength(L)：求表长。返回线性表L的长度，即L中数据元素的个数。\nPrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值。\nEmpty(L)：判空操作。若L为空表，则返回true，否则返回false。\nKey：命名要有可读性\nTips： ①对数据的操作（记忆思路） —— 创销、增删改查 ②C语言函数的定义 —— \u0026lt;返回值类型\u0026gt; 函数名 (\u0026lt;参数1类型\u0026gt; 参数1，\u0026lt;参数2类型\u0026gt; 参数2，\u0026hellip;\u0026hellip;) ③实际开发中，可根据实际需求定义其他的基本操作 ④函数名和参数的形式、命名都可改变（Reference：严蔚敏版《数据结构》） ⑤什么时候要传入引用“\u0026amp;” —— 对参数的修改结果需要“带回来”\n顺序表的定义 线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列。\n顺序表——用顺序存储的方式实现线性表顺序存储。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。 顺序表的实现\u0026ndash;静态分配 代码实现： 1 2 3 4 5 #define MaxSize 10 //定义最大长度 typedef struct{ ElemType data[MaxSize]; //用静态的“数组”存放数据元素 int length; //顺序表的当前长度 }SqList; //顺序表的类型定义（静态分配方式） InitList函数（静态分配） 1 2 3 4 5 6 void InitList(SqList \u0026amp;L){ for(int i=0;i\u0026lt;MaxSize;i++){ data[i]=0; } L.length=0; } 注意：如果不进行初始化，内存中会有遗留的“脏数据”，但其实如果正常访问的话（指在进行访问数据的时候，没有赋值的不去访问），也不会有影响，也可以直接把长度设为零即可。\n顺序表的实现\u0026ndash;动态分配 代码实现： 1 2 3 4 5 6 #define InitSize 10 //顺序表的初始长度 typedef struct{ ElemType *data; //指示动态分配数组的指针 int MaxSize; //顺序表的最大容量 int length; //顺序表的当前长度 } SeqList; //顺序表的类型定义（动态分配方式） malloc函数 L.data = (ElemType *) malloc (sizeof(ElemType) * InitSize) 注：需要包含头文件\u0026lt;stdlib.h\u0026gt; InitList函数（动态分配） 1 2 3 4 5 void InitLIst(SqList \u0026amp;L){ L.data=(int *)malloc(InitSize*sizeof(int)); L.length=0; L.Maxsize=InitSize; } IncreaseSize函数（动态分配）（增加数组的长度） 1 2 3 4 5 6 7 8 9 void IncreaseSize(SqList \u0026amp;L,int len){ int *p=L.data; L.data=(int *)malloc((L.MaxSize+len)*sizeof(int)); for(int i=0;i\u0026lt;L.length;i++){ L.data[i]=p[i]; } L.MaxSize+=len; free(p); } 顺序表的特点： ①随机访问，即可以在 O(1) 时间内找到第 i 个元素。 ②存储密度高，每个节点只存储数据元素 ③拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高） ④插入、删除操作不方便，需要移动大量元素 顺序表的插入与删除 顺序表的基本操作\u0026ndash;插入 ListInsert(\u0026amp;L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e。 注：本节代码建立在顺序表的“静态分配”实现方式之上，“动态分配” 也雷同。\n1 2 3 4 5 6 7 8 9 bool ListInsert(SqList \u0026amp;L,int i,int e){ if(i\u0026lt;1||i\u0026gt;L.length+1) return false;//判断i的值是否有效 if(L.length\u0026gt;L.MaxSize) return true;//当前存储空间已满，不能插入 for(int j=L.length;j\u0026gt;=i;j--) L.data[j]=L.data[j-1]; L.data[i-1]=e; L.length++; return true; } 注：好的算法，应该具有“健壮性”。能处理异常情况，并给使用者反馈\n时间复杂度的计算： 最好情况：新元素插入到表尾，不需要移动元素 i = n+1，循环0次；最好时间复杂度 = O(1) 最坏情况：新元素插入到表头，需要将原有的 n 个元素全都向后移动 i = 1，循环 n 次；最坏时间复杂度 = O(n); 平均情况：假设新元素插入到任何一个位置的概率相同，即 i = 1,2,3, \u0026hellip; , length+1 平均时间复杂度 = O(n) 顺序表的基本操作\u0026ndash;删除 ListDelete(\u0026amp;L,i,\u0026amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。\n1 2 3 4 5 6 7 8 9 bool ListDelete(SqList \u0026amp;L,int i,int \u0026amp;e){ if(i\u0026lt;1||i\u0026gt;L.length) return false; e=L.data[i]; for(int j=i;j\u0026lt;L.length;j++){ L.data[j-1]=L.data[j]; } L.length--; return true; } 顺序表的查找 按位查找 GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。\n静态分配 1 2 3 4 5 6 7 8 #define MaxSize 10 //定义最大长度 typedef struct{ ElemType data[MaxSize]; //用静态的“数组”存放数据元素 int length; //顺序表的当前长度 }SqList; ElemType GetElem(SqList L, int i){ return L.data[i-1]; } 动态分配 1 2 3 4 5 6 7 8 9 #define InitSize 10 //顺序表的初始长度 typedef struct{ ElemType *data; //指示动态分配数组的指针 int MaxSize; //顺序表的最大容量 int length; //顺序表的当前长度 } SeqList; //顺序表的类型定义（动态分配方式） ElemType GetElem(SeqList L, int i){ return L.data[i-1]; } 注意，时间复杂度为O(1)\n按值查找 LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。\n静态分配 1 2 3 4 5 6 int LocateElem(SeqList L,ElemType e){ for(int i=0;i\u0026lt;L.length;i++) if(L.data[i]==e) return i+1; //数组下标为i的元素值等于e，返回其位序i+1 return 0; //退出循环，说明查找失败 } 动态分配 1 2 3 4 5 6 int LocateElem(SeqList L,int e){ for(int i=0;i\u0026lt;L.length;i++) if(L.data[i]==e) return i+1; return 0; } 单链表的定义 顺序表与单链表的优缺点 顺序表：优点：可随机存取，存储密度高 缺点：要求大片连续空间，改变容量不方便 单链表：优点：不要求大片连续空间，改变容量方便 缺点：不可随机存取，要耗费一定空间存放指针 单链表的代码实现 1 2 3 4 struct LNode*{ ElemType data; struct LNode* next; }LNode,LinkList; 增加一个新的结点：在内存中申请一个结点所需空间，并用指针 p 指向这个结点 struct LNode * p = (struct LNode *) malloc(sizeof(struct LNode)); typedef 关键字 —— 数据类型重命名 typedef \u0026lt;数据类型\u0026gt; \u0026lt;别名\u0026gt; 强调这是一个单链表 ——使用 LinkList 强调这是一个结点 ——使用 LNode * GetElem函数的代码实现（更好地理解LNode *和LinkList) 1 2 3 4 5 6 7 8 9 10 11 LNode *GetElem(LinkList L,int i){ int j=1; LNode *p=L-\u0026gt;next; if(i==0) return L; if(i\u0026lt;1) return NULL; while(p!=NULL \u0026amp;\u0026amp; j\u0026lt;i){ p=p-\u0026gt;next; j++ } return p; } 头插法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 LinkList List_HeadInsert(LinkList \u0026amp;L){//逆向建立单链表 LNode *s; int x; L=(LinkList)malloc(sizeof(LNode));//创建头结点 L-next=NULL;//初始化为空链表 cin\u0026gt;\u0026gt;x;//输入结点的值 while(x!=9999）{//输入9999表示结束 s=(LNode *)malloc(sizeof(LNode));//创建新结点 s-\u0026gt;data=x; s-\u0026gt;next=L-\u0026gt;next; L-\u0026gt;next=s;//将新结点插入表中，L为头指针 cin\u0026gt;\u0026gt;x; } return L; } 不带头结点的单链表与带头结点的单链表 带头结点，写代码更方便，用过都说好 初始化代码实现\n1 2 3 4 bool InitList(LinkList \u0026amp;L){ L=NULL; return true } 判空代码实现\n1 2 bool Empty(LinkList \u0026amp;L){ return (L==NULL) 不带头结点，写代码更麻烦对第一个数据结点和后续数据结点的处理需要用不同的代码逻辑对空表和非空表的处理需要用不同的代码逻辑 初始化代码实现\n1 2 3 4 5 bool InitList(LinkList \u0026amp;L){ L=(LNode *)malloc(sizeof(LNode));//分配一个头结点 if(L=NULL) return false;//内存不足，分配失败 L-\u0026gt;next=NULL；//头结点暂时还没有结点 return true; 判空代码实现\n1 2 3 bool Empty(LinkList \u0026amp;L){ return (L-\u0026gt;next==NULL) } 单链表的插入与删除 按位序插入（带头结点） ListInsert(\u0026amp;L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 bool ListInsert(LinkList \u0026amp;L,int i,ElemType e){ if(i\u0026lt;1) return false; LNode *p; int j=0; p=L; while(p!=NULL \u0026amp;\u0026amp; j=i-1){ p=p-\u0026gt;next; j++; } if(p==NULL) return false; LNOde *s=(LNode *)malloc(sizeof(LNode)); s-\u0026gt;data=e; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; return true; 按位序插入（不带头结点） 不存在 “第0个”结点，因此 i=1 时需要特殊处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 bool ListInsert(LinkList \u0026amp;L,int i,ElemType e){ if(i\u0026lt;1) return false; if(i==1){ LNode *s=(LNode *)malloc(sizeof(LNode)); s-\u0026gt;data=e; s-\u0026gt;next=L-\u0026gt;next; L=s; return true; } LNode *p; int j=0; p=L; while(p!=NULL \u0026amp;\u0026amp; j=i-1){ p=p-\u0026gt;next; j++; } if(p==NULL) return false; LNOde *s=(LNode *)malloc(sizeof(LNode)); s-\u0026gt;data=e; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; return true; 指定结点的后插操作 1 2 3 4 5 6 7 8 9 10 bool InsertNextNode(LNode *p,ElemType e){ if(p==NULL) return false; LNode *s=(LNode *)malloc(sizeof(LNode)); if(s==NULL) return false;//内存分配失败 s-\u0026gt;data=e; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; return true; 指定结点的前插操作 1 2 3 4 5 6 7 8 9 10 11 12 bool InsertPriorNode(LNode *p,ElemType e){ if(p==NULL) return false; LNode *s=(LNode *)malloc(sizeof(LNode)); if(s==NULL) return false;//内存分配失败 s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; s-\u0026gt;data=p-\u0026gt;data; p-\u0026gt;data=e; return true; } 王道书版本：\n1 2 3 4 5 6 7 8 9 10 bool InsertPriorNode(LNode *p,LNode *s){ if(p==NULL||s==NULL) return false; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; ElemType temp=p-\u0026gt;data; p-\u0026gt;data=s-\u0026gt;data; s-\u0026gt;data=temp; return true; } 按位序删除（带头结点） ListDelete(\u0026amp;L,i,\u0026amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 bool ListDelete(LinkList \u0026amp;L,int i,ElemType \u0026amp;e){ if(i\u0026lt;1) return false; LNode *p; int j=0; p=L; while(p!=NULL \u0026amp;\u0026amp; j\u0026lt;i-1){//循环找到i-1个结点 p=p-\u0026gt;next; j++; } if(p==NULL) return false;//i值不合法 if(p-\u0026gt;next==NULL) return false;//i-1后已无其他结点 LNode *q=p-\u0026gt;next; e=q-\u0026gt;data; p-\u0026gt;next=q-\u0026gt;next; free(q); return true; } 指定结点的删除 ListDelete(LNode *p)：删除指定结点p。\n1 2 3 4 5 6 7 8 9 bool ListDelete(LNode *p){ if(p==NULL) return false; LNode *q=p-\u0026gt;next; p-\u0026gt;data=q-\u0026gt;next-\u0026gt;data; p-next=q-\u0026gt;next; free(q); return true; } 注意：如果p是最后一个结点\u0026hellip;只能从表头开始依次寻找p的前驱，时间复杂度 O(n)\n单链表的查找 按位查找 GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。\n1 2 3 4 5 6 7 8 9 10 11 LNode *GetElem(LinkList L,int i){ if(i\u0026lt;0) return false; LNode *p; int j=0; p=L; while(p!=NULL \u0026amp;\u0026amp; j\u0026lt;i){//循环找到i个结点 p=p-\u0026gt;next; j++; } return p; } 王道书版本：\n1 2 3 4 5 6 7 8 9 10 11 LNode *GetElem(LinkList L,int i){ int j=1; p=L-\u0026gt;next; if(i==0) return L; if(i\u0026lt;1) return NULL; while(p!=NULL \u0026amp;\u0026amp; j\u0026lt;i){ p=p-\u0026gt;next; j++; } return p; } 按值查找 LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。\n1 2 3 4 5 6 7 LNode *LocateElem(LinkList L,ElemType e){ LNode *p=L-\u0026gt;next; while(p!=NULL \u0026amp;\u0026amp; p-\u0026gt;data!=e){ p=p-\u0026gt;next; } return p; } 求表的长度 1 2 3 4 5 6 7 8 9 int length(LinkList L){ int len=0; LNode *p=L; while(p-\u0026gt;next!=NULL){ p=p-\u0026gt;next; len++; } return len; } 单链表的建立 头插法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 LinkList List_HeadInsert(LinkList \u0026amp;L){ //逆向建立单链表 LNode *s; int x; L=(LinkList)malloc(sizeof(LNode)); //创建头结点 L-\u0026gt;next=NULL; //初始为空链表 cin\u0026gt;\u0026gt;x; //输入结点的值 while(x!=9999){ //输入9999表示结束 s=(LNode*)malloc(sizeof(LNode)); //创建新结点 s-\u0026gt;data=x; s-\u0026gt;next=L-\u0026gt;next; L-\u0026gt;next=s; //将新结点插入表中，L为头指针 cin\u0026gt;\u0026gt;x; } return L; } 尾插法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 LinkList List_TailInsert(LinkList \u0026amp;L){//正向建立单链表 int x; L=(LNode *)malloc(sizeof(LNode));//建立头结点（初始化空表） LNode *s,*r;=L;//r为表尾指针 cin\u0026gt;\u0026gt;x;//输入结点的值 while(x!=9999){//输入9999表示结束 s=(LNode *)malloc(sizeof(LNode)); s-\u0026gt;data=x; r-\u0026gt;next=s;//以上三步表示在r结点之后插入x r=s;//r指向新的结点 cin\u0026gt;\u0026gt;x; } r-\u0026gt;next=NULL;//尾指针置空 return L; } 头插法的重要应用：链表的逆置\n1 2 3 4 5 6 7 8 9 10 ListNode* reverseList(ListNode* head) { ListNode* newHead = nullptr;// 新链表头节点，初始为空 while (head) { ListNode* nextNode = head-\u0026gt;next;// 保存原链表的下一个节点 head-\u0026gt;next = newHead;// 当前节点插入到新链表头部 newHead = head;// 更新新链表的头节点 head = nextNode;// 移动到下一个节点 } return newHead; } 双链表 单链表和双链表的区别 单链表：无法逆向检索，有时候不太方便 双链表：可进可退，存储密度更低一丢丢 双链表的初始化（带头结点） 1 2 3 4 5 6 7 8 9 10 11 typedef struct DNode{ ElemType data; struct DNode *prior,*next; }DNode, *DLinkList; bool InitDLinkList(DLinkList \u0026amp;L){ L=(DNode *)malloc(sizeof(DNode));//建立头结点 if(L=NULL) return false; L-\u0026gt;prior=NULL;//prior永远指向NULL L-\u0026gt;next=NULL;//next后暂时还没有结点 return true; } 双链表的插入 1 2 3 4 5 6 7 8 9 10 11 12 bool InsertNextNode(DNode *p,DNode *s){ if(p==NULL||q==NULL){ return false; s-\u0026gt;next=p-\u0026gt;next; if(p-\u0026gt;next!=NULL){ p-\u0026gt;next-\u0026gt;prior=s; } s-\u0026gt;prior=p; p-\u0026gt;next=s; return true; } } 双链表的删除 删除p结点的后续结点 1 2 3 4 5 6 7 8 9 10 11 12 bool DeleteNextDNode(DNode *p){ if(p==NULL) return false; DNode *q=p-\u0026gt;next; if(q==NULL) return false;//p没有后继 p-\u0026gt;next=q-\u0026gt;next; if(q-\u0026gt;next!=NULL)//q结点不是最后一个结点 q-\u0026gt;next-\u0026gt;prior=p; free(q);//释放空间 return true; } 删除整个双链表 1 2 3 4 5 6 void DestroyList(DLinkList \u0026amp;L){ while(L-\u0026gt;next!=NULL) DeleteNextDNode(L);//循环释放各个结点 free(L);//释放头结点 L=NULL;//头指针指向NULL } 双链表的遍历 后向遍历 1 2 3 4 while(p!=NULL){ //对结点p做相应处理，如打印 p = p-\u0026gt;next; } 前向遍历 1 2 3 4 while(p!=NULL){ //对结点p做相应处理，如打印 p = p-\u0026gt;prior; } 前向遍历（不带头结点） 1 2 3 4 while(p-\u0026gt; prior != NULL){ //对结点p做相应处理 p = p-\u0026gt;prior; } 循环链表 循环单链表 循环单链表的特点：\n单链表：表尾结点的next指针指向 NULL 从一个结点出发只能找到后续的各个结点 循环单链表：表尾结点的next指针指向头结点 从一个结点出发可以找到其他任何一个结点 初始化循环单链表 1 2 3 4 5 6 7 bool InitList(LinkList \u0026amp;L){ L=(LNode *)malloc(sizeof(LNode)); if(L=NULL) return false; L-\u0026gt;next=L;//头结点next指向头结点 return true; } 判断循环单链表是否为空 1 2 3 4 5 6 7 bool Empty(LinkList L){ if(L-\u0026gt;next==L){ return true; } else return false; } 判断结点p是否为循环单链表的表尾结点 1 2 3 4 5 6 bool isTail(LinkList L,LNode *p){ if(p-\u0026gt;next==L) return true; else return false; } 循环双链表 双链表：表头结点的 prior 指向 NULL； 表尾结点的 next 指向 NULL 循环双链表：表头结点的 prior 指向表尾结点； 表尾结点的 next 指向头结点 初始化循环双链表 1 2 3 4 5 6 7 8 bool InitDList(DLinkList \u0026amp;L){ L=(DNode *)malloc(sizeof(DNode)); if(L=NULL) return false; L-\u0026gt;next=L; L-\u0026gt;prior=L; return true; } 判断循环单链表是否为空 1 2 3 4 5 6 7 bool Empty(DLinkList L){ if(L-\u0026gt;next==L){ return true; } else return false; } 判断结点p是否为循环单链表的表尾结点 1 2 3 4 5 6 bool isTail(DLinkList L,DNode *p){ if(p-\u0026gt;next==L) return true; else return false; } 静态链表 单链表：各个结点在内存中星罗棋布、散落天涯。 静态链表：分配一整片连续的内存空间，各个结 点集中安置。 静态链表的定义 1 2 3 4 5 #define MaxSize 10//静态链表的最大长度 typedef struct Node{//静态链表结构类型的定义 ElemType data;//存储数据元素 int next;//下一个元素的数组下标 }SLinkList[MaxSize]; SLinkList b —— 相当于定义了一个长度为 MaxSize 的 Node型数组\n基本操作的简述 初始化静态链表：把 a[0] 的 next 设为 -1，把其他结点的 next 设为一个特殊值用来表示结点空闲，如 -2 查找：从头结点出发挨个往后遍历结点 删除某个结点： ①从头结点出发找到前驱结点 ②修改前驱结点的游标 ③被删除结点 next 设为 -2 插入位序为i的结点：1.找到一个空的结点，存入数据元素 2.从头结点出发找到位序为i-1的结点 3.修改新结点的next 4.修改i-1号结点的next 静态链表的特点 静态链表：用数组的方式实现的链表 优点：增、删 操作不需要大量移动元素 缺点：不能随机存取，只能从头结点开始依次往后查找；容量固定不可变 适用场景：①不支持指针的低级语言；②数据元素数量固定不变的场景（如操作系统的文件分配表FAT）\n顺序表和链表的对比 逻辑结构 都属于线性表，都是线性结构\n存储结构 顺序表：优点：支持随机存取、存储密度高 缺点：大片连续空间分配不方便，改变容量不方便 链表：优点：离散的小空间分配方便，改变容量方便 缺点：不可随机存取，存储密度低 基本操作 顺序表：1.需要预分配大片连续空间。若分配空间过小，则之后不方便拓展容量；若分配空间过大，则浪费内存资源 2.插入/删除元素要将后续元素都后移/前移 3.时间复杂度 O(n)，时间开销主要来自移动元素 4.移动的时间代价很高 5.按位查找：O(1) 6.按值查找：O(n)若表内元素有序，可在O(log2n) 时间内找到 链表：1.只需分配一个头结点（也可以不要头结点，只声明一个头指针），之后方便拓展 2.插入/删除元素只需修改指针即可 3.时间复杂度 O(n)，时间开销主要来自查找目标元素 4.查找元素的时间代价更低 5.按位查找：O(n) 6.按值查找：O(n） 栈、队列和数组 栈的基本概念 线性表是具有相同数据类型的n（n≥0）个数据元素的有限 序列，其中n为表长，当n = 0时线 性表是一个空表。若用L命名线性表，则其一般表示为 L = (a1, a2, \u0026hellip; , ai, ai+1, \u0026hellip; , an) 栈（Stack）是只允许在一端进行插入或删除操作的线性表 栈的基本操作 InitStack(\u0026amp;S)：初始化栈。构造一个空栈 S，分配内存空间。\nDestroyStack(\u0026amp;S)：销毁栈。销毁并释放栈 S 所占用的内存空间。\nPush(\u0026amp;S,x)：进栈，若栈S未满，则将x加入使之成为新栈顶。\nPop(\u0026amp;S,\u0026amp;x)：出栈，若栈S非空，则弹出栈顶元素，并用x返回。\nGetTop(S, \u0026amp;x)：读栈顶元素。若栈 S 非空，则用 x 返回栈顶元素\n其他常用操作：\nStackEmpty(S)：判断一个栈 S 是否为空。若S为空，则返回true，否则返回false。\n常见问题：栈的进出栈问题 进栈顺序： a-\u0026gt;b-\u0026gt;c-\u0026gt;d-\u0026gt;e 有哪些合法的出栈顺序？ n个不同元素进栈，出栈元素不同排列的个数为1/n+1C2nn\n上述公式称为卡特兰（Catalan）数，可采用数学归纳法证明（不要求掌握）。\n顺序栈的实现 顺序栈的定义 1 2 3 4 5 #define MaxSize 10 typedef struct{ ElemType data[MaxSize];//静态数组中存放栈中元素 int top;//栈顶指针 }SqStack; 初始化操作 1 2 3 void InitStack(SqStack \u0026amp;S){ S.top=-1; } 判空操作 1 2 3 4 5 6 7 bool StackEmpty(SqStack S){ if(top==-1) return true; else return false; } 进栈操作 1 2 3 4 5 6 7 8 bool Push(SqStack \u0026amp;S,ElemType x){ if(S.top==MaxSize-1) return false;//栈满，操作失败 S.top+=1; S.data[S.top]=x; //这两步可以直接写为S.data[++S.top]=x return true; } 出栈操作 1 2 3 4 5 6 7 8 bool pop(SqStack \u0026amp;S,ElemType \u0026amp;x){ if(S.top==-1) return false;//栈空，报错 x=S.data[S.top]; S.top-=1; //这两步可以直接写为x=S.data[S.top--] return true; } 读栈顶元素 1 2 3 4 5 6 bool GetTop(SqStack \u0026amp;S,ElemType \u0026amp;x){ if(S.top==-1) return false; x=S.data[S.top]; return true; } 另一种方式 另一种方式就是把S.top的初始值设为0，其他地方一致\n共享栈 1 2 3 4 5 6 #define MaxSize 10 typedef struct{ ElemType data[MaxSize]; int top0;//0号栈栈顶指针 int top1;//1号栈栈顶指针 }ShStack; 初始化栈\n1 2 3 4 void InitStack(SqStack \u0026amp;S){ S.top0=-1; S.top1=MaxSize; } 注意！栈满的条件：top0 + 1 == top1\n链栈的实现 链栈的定义 1 2 3 4 typedef struct LinkNode{ ElemType data;//数据域 struct LinkNode *next;//指针域 }*LiStack;//栈类型定义 进栈/出栈都只能在栈顶一端进行（链头作为栈顶）\n队列的基本概念 队列的定义 队列（Queue）是只允许在一端进行插入，在另一端删除的线性表 队列的特点：先进先出 First In First Out（FIFO） 队头：允许删除的一端 队尾：允许插入的一端 队列的基本操作 InitQueue(\u0026amp;Q)：初始化队列，构造一个空队列Q。\nDestroyQueue(\u0026amp;Q)：销毁队列。销毁并释放队列Q所占用的内存空间。\nEnQueue(\u0026amp;Q,x)：入队，若队列Q未满，将x加入，使之成为新的队尾。\nDeQueue(\u0026amp;Q,\u0026amp;x)：出队，若队列Q非空，删除队头元素，并用x返回。\nGetHead(Q,\u0026amp;x)：读队头元素，若队列Q非空，则将队头元素赋值给x。\n其他常用操作：\nQueueEmpty(Q)：判队列空，若队列Q为空返回true，否则返回false。\n队列的顺序实现 顺序队列的定义 1 2 3 4 5 #define MaxSize 10 typedef struct{ ElemType data[MaxSzie];//用静态数组存放队列元素 int front,rear;//队头指针和队尾指针 }SqQueue; 注意：rear指向队尾元素的后一个位置（下一个应该插入的位置）\n初始化操作 1 2 3 void InitQueue(SqQueue \u0026amp;Q){ Q.front=Q.rear=0; } 判空操作 1 2 3 4 5 6 bool QueueEmpty(SqQueue \u0026amp;Q){ if(Q.rear==Q.front) return true; else return false; } 入队操作 1 2 3 4 5 6 7 bool EnQueue(SqQueue \u0026amp;Q,ElemType x){ if((Q.rear+1)%MaxSize==Q.front) return false; Q.data[Q.rear]=x; Q.rear=(Q.rear+1)%MaxSize; return true; } 队列已满的条件：队尾指针的再下一个位置是队头，即 (Q.rear+1)%MaxSize==Q.front\n判空操作 1 2 3 4 5 6 bool QueueEmpty(SqQueue Q){ if(Q.rear==Q.front) return true; else return false; } 出队操作 1 2 3 4 5 6 7 bool DeQueue(SqQueue \u0026amp;Q,ElemType \u0026amp;x){ if(Q.rear==Q.front) return false; x=Q.data[Q.front]; Q.front=(Q.front+1)\u0026amp;MaxSize; return true; } 获得对头元素的值，用x的值 1 2 3 4 5 6 bool GetHead(SqQueue Q,ElemType \u0026amp;x){ if(Q.rear==Q.front) return false; x=Q.data[Q.front]; return true; } ![图片](https://gitee.com/manunited0518/image-store/raw/master/截屏2024-11-27 16.05.41_副本.png)\n","date":"2024-11-12T20:43:19+08:00","permalink":"https://Manunited.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E7%8E%8B%E9%81%93%E7%BD%91%E8%AF%BE/","title":"数据结构---王道网课"},{"content":"第1章 绪论 考纲内容 算法时间复杂度和空间复杂度的分析与计算 复习提示 本章内容是数据结构概述，并不在考研大纲中。读者可通过对本章的学习，初步了解数据结构的基本内容和基本方法。分析算法的时间复杂度和空间复杂度是本章重点，需要熟练掌握，算法设计题通常都会要求分析时间复杂度、空间复杂度，同时会出现考查时间复杂度的选择题。 ","date":"2024-11-12T20:43:19+08:00","permalink":"https://Manunited.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E7%8E%8B%E9%81%93%E4%B9%A6/","title":"数据结构--王道书"},{"content":"简单的HTML语法 1.简单的 HTML 页面架构 2. HTML 常见标签 2.1. meta 标签 \u0026lt;meta\u0026gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎 和更新频度的描述和关键词。 设置网站关键字 meta name=\u0026ldquo;keywords\u0026rdquo; content=\u0026ldquo;网络安全，WEB 渗透，数据安全，渗透测试， 安全培训\u0026rdquo; /\u0026gt; \u0026lt;link\u0026gt; 标签定义文档与外部资源的关系。 \\ ","date":"2024-11-12T20:43:19+08:00","permalink":"https://Manunited.github.io/p/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/","title":"网络安全"},{"content":"title=\u0026ldquo;Markdown语法\u0026rdquo;\n什么是MarkDown语法？ Markdown 致力于使阅读和创作文档变得容易。\nMarkdown是一种轻量级的标记语言，设计初衷是让人们可以使用简单的文本格式来书写和编辑文档，同时具有一定的格式化效果。通过使用Markdown语法，用户可以快速地将纯文本转换为格式化的文档，例如标题、列表、链接、图片等。Markdown语法简单直观，易于学习和使用，逐渐成为了各种平台上书写文档的常用格式，甚至还可以实现Markdown文档对PDF、Word等格式的快速转换。\nMarkdown的文件通常以.md或.markdown为扩展名\n我们可以创建一个TXT文本文档，然后将其后缀改为.md即可开始编辑此Markdown文档。\n基础语法讲解 段落和换行 Markdown文档与我们常见的Word文档或是TXT文档类似，只需要直接输入内容，就可以展示了：\n[][https://oss.itbaima.cn/internal/markdown/2024/04/01/HVqab9QUm4vw73P.png]\n","date":"0001-01-01T00:00:00Z","permalink":"https://Manunited.github.io/p/","title":""}]