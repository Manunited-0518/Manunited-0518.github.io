[{"content":"MarkDown语法 Markdown 致力于使阅读和创作文档变得容易。\nMarkdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。\nMarkdown的文件通常以.md或.markdown为扩展名\n我们可以创建一个TXT文本文档，然后将其后缀改为.md即可开始编辑此Markdown文档。\n基础语法讲解 首先我们需要一个软件来书写markdown，一般选择Typora，另外，Idea也支持Typora。\n段落和换行 换行效果： 在上一行的末尾连续添加两个空格，然后再换行。 换段效果： 连续换两行。 加粗和斜体 想要使得文本加粗，我们只需要在需要加粗文本两边添加两个星号即可，或是使用两个下划线，效果相同 斜体与加粗类似，我们只需在需要斜体的文本两边添加一个星号即可，同样也可以使用一个下划线代替，效果相同。 如果需要同时使用加粗和斜体，我们可以直接使用连续的三个星号或是下划线。 和c语言一样，如果知识单纯想使用*等符号，可以使用转义字符，也就是在前面加上反斜杠\u0026quot;\u0026quot;。 删除线 实现删除线的效果，我们只需要在需要加删除线的文本两边添加两个~波浪线即可 下划线 在markdown原生语法中是没有下划线的，但可以借助于HTML中的语法，也就是\u0026hellip;..这样的形式。 分割线 单独使用三个星号即可实现，同样，下划线也可以。 标题 可以使用#井号来实现标题，两个井号代表二级标题，以此类推。 还有另外一种方式，可以在一段文字下面打上=等号和-减号分别代表一级标题和二级标题快速创建。 列表 要创建一个无序列表，我们只需要使用星号作为前缀，注意需要空格,可以用+加号和-减号来代替，但是，如果混用会显示为几个不同的列表。 如果想要创建一个带有数字的有序列表，可以用数字加点的形式来实现。 在列表中换行同样需要像普通文本那样，如果只是单纯换行编写，会被认为是一个空格；如果是在末尾添加两个空格再换行，会被认为是在列表项内换行；只有两个连续的换行才能脱离列表，作为新的段落开始编写。 列表可以设置层级嵌套，可以在一级列表下创建二级列表，需要在前面添加两个或四个空格（也可以是一个TAB缩进）。 勾选框 勾选框：需要在列表的形式下添加一个方括号，方括号里加x则代表此勾选框已勾选。 代码块 要创建一个代码块，只需要在本行的最前面添加四个空格即可，注意代码块要与上面的其他文本隔开一行。 还有另一种更加简便的方法，可以用三个连续的`符号将代码块包起来即可。 在三个`后可以添加语言名称，markdown编辑器可以进行识别。 引用 使用\u0026gt;大于符号进行引用 和列表一样，也需要进行两次换行脱离引用块。 引用中，可以进行嵌套，例如列表和代码块，甚至引用本身。 链接 在Markdown文档中插入超链接，只需要使用[]和()组合就能完成，格式为[链接文本](链接地址)。 有些时候可能我们的文档中有很多链接，甚至还有重复，此时一个一个编写相当费时间，而且源代码中满屏的链接显得相当杂乱，我们可以利用变量来优化这种情况，变量可以在文章的末尾再确定值。 图片 语法于链接类似：!图片描述 注意：只能使用本地图片地址或是网络图片地址。 图片和链接一样，都可以使用变量。 脚注 语法：曼联[^1]又赢了✌️。 [^1]: 世界上最好的俱乐部。 鼠标移动上去时也会展示脚注内容。 表格 Eg.| 名称 | 年龄 | 性别 | | \u0026mdash; | \u0026mdash; | \u0026mdash; | 最上一排就是表头，需要在左右使用|表示这是一个表格，同时，下方需要添加分割线，分割线使用-减号表示，写一个或多个都可以，推荐与表的宽度一致，更加美观。这样，就可以顺利展示为一个表格了 :\u0026mdash; 为左对齐 \u0026mdash;: 为右对齐 :\u0026mdash;: 为居中对齐 表格中也可以嵌套使用诸如加粗、斜体、行内代码块这类Markdown语法 HTML标签 markdown中可以支持HTML中的一些语法 内嵌iframe页面，可以实现B站视频播放 其他扩展语法 文本高亮，使用两个=等号包括 文本的上标和下标分别可以使用单个^和~包括来实现 数学公式语法 公式块 需要编写数学公式，我们同样需要在特定的块中编写，公式块使用$美元符表示。多行公式使用连续的两个美元符 行内编写，一行内容只需要使用一个美元符包括即可 特殊数学符号 代码 符号 描述 \\not= ≠ 不等于 \\approx ≈ 约等于 \\times × 乘号 ｜\\div ÷ 除号 \\leq ≤ 小于等于 \\geq ≥ 大于等于 \\pm ± 正负号 \\sum ∑ 求和符号（累加） \\prod ∏ 累乘 \\coprod ∐ 累除 \\overline{a + b + c} 平均值 数学中常见特殊字符: 代码 符号 代码 符号 \\alpha α \\beta β \\gamma γ \\delta δ ｜\\epsilon ϵ \\eta η \\theta θ \\pi π \\omega ω \\rho ρ \\sigma σ \\mu μ 还有我们数学中常见的三角函数相关: 代码 符号 描述 \\sin sin 正弦 \\cos cos 余弦 \\tan tan 正切 \\cot cot 余切 \\sec sec 正割 \\csc csc 余割 \\circ ∘ 度 积分和求导相关: 代码 符号 描述 \\infty ∞ 无穷 \\int ∫ 定积分 \\iint ∬ 双重积分 \\iiint ∭ 三重积分 \\oint ∮ 曲线积分 x\\prime x′ 求导 \\lim lim 极限 集合相关: 代码 符号 描述 \\emptyset ∅ 空集 \\in ∈ 不属于 \\notin ∉ 双重积分 \\supset ⊃ 真包含 \\supseteq ⊇ 包含 \\bigcap ⋂ 交集 \\bigcup ⋃ 并集 对数函数相关： 代码 符号 描述 \\log log 对数函数 \\ln ln 以e为底的对数函数 \\lg lg 以10为底的对数函数 分数 格式：$ \\frac{分子}{分母} $ 开方 格式：$\\sqrt{4}$ 若要修改几次根号：$\\sqrt[3]{8}$ 上下标 在公式块中的上下标与Markdown中的不同，语法也不一样，其中^表示上标， _ 表示下标 如果上标或下标内容多于一个字符，需要使用 {} 括起来，包括后续的其他代码如果出现只有一个字符生效的情况下，考虑使用花括号包括全部内容 积分和极限 积分格式：$ \\int_1^2xdx $ 极限格式：$ \\lim_{n\\rightarrow+\\infty}\\frac{1}{n + 1} $ 其他符号 向量符号：$ \\vec{a} $ 省略号：$ \\cdots $ 居中省略号 $ \\ldots $ 靠底部的省略号 点乘号：$ \\cdot $ 累加：$ \\sum_1^n $ ","date":"2024-11-12T20:43:19+08:00","permalink":"http://localhost:1313/p/mark-down%E8%AF%AD%E6%B3%95/","title":"Mark Down语法"},{"content":"数据结构基本概念 数据 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。 数据元素、数据项 数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。 一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。 数据结构、数据对象： 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。 数据对象是具有相同性质的数据元素的集合，是数据的一个子集。 数据结构的三要素 逻辑结构，物理结构（存储结构），数据的运算。 逻辑结构 集合：各个元素同属一个集合，别无其他关系 线性结构：数据元素之间是一对一的关系。除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继 树形结构：数据元素之间是一对多的关系 图结构：数据元素之间是多对多的关系 物理结构（存储结构） 顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储 单元的邻接关系来体现。 链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。 索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址） 散列存储。根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储 其中，链式存储、索引存储、散列存储也并称为非顺序存储\n以下几点需要注意 若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用 非顺序存储，则各个数据元素在物理上可以是离散的。 数据的存储结构会影响存储空间分配的方便程度 数据的存储结构会影响对数据运算的速度 数据的运算 施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的， 指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。\n数据类型、抽象数据类型 数据类型是一个值的集合和定义在此集合上的一组操作的总称。 1）原子类型。其值不可再分的数据类型。 2）结构类型。其值可以再分解为若干成分（分量）的数据类型。 抽象数据类型（Abstract Data Type，ADT）是抽象数据组织及与之相关的操作。\nADT 用数学化的语言定义数据的逻辑结构、定义运算。与具体的实现无关。 算法的基本概念 什么是算法 程序 = 数据结构（如何用数据正确地描述现实世界的问题，并存入计算机） + 算法（如何高效地处理这些数据，以解决实际问题） 算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令 表示一个或多个操作 算法的特性 有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。用有限步骤解决某个特定的问题 注：算法必须是有穷的，而程序可以是无穷的 确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。 “好”算法的特性 设计算法时尽量遵循的目标\n正确性。算法应能够正确地解决求解问题。 可读性。算法应具有良好的可读性，以帮助人们理解。 健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。 高效率与低存储量需求 算法效率的度量 如何评估算法时间开销 算法时间复杂度： 事前预估算法时间开销T(n)与问题规模 n 的关系（T 表示 “time”） 例子：用算法表白——“爱你n遍” 1 2 3 4 5 6 7 8 void loveyou(int n){ ①int i; ②while(i\u0026lt;=n){ ③i++; ④cout\u0026lt;\u0026lt;\u0026#34;I Love You %d\u0026#34;\u0026lt;\u0026lt;endl; } ⑤cout\u0026lt;\u0026lt;\u0026#34;I Love You More Than %d\u0026#34;\u0026lt;\u0026lt;endl; } 语句频度： ① ——1次 ② ——3001次 ③④ ——3000次 ⑤ ——1次 T(3000) = 1 + 3001 + 2*3000 + 1 时间开销与问题规模 n 的关系： T(n)=3n+3\n结论：1.可以只考虑阶数高的部分\n2.问题规模足够大时，常数项系数也可以忽略 加法规则和乘法规则 a）加法规则 T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n))) b）乘法规则 T(n) = T1(n)×T2(n) = O(f(n))×O(g(n)) = O(f(n)×g(n)) Eg：T3(n)= n3 + n2 log2n = O(n3) + O(n2 log2n) = ？？？\n1.顺序执行的代码只会影响常数项，可以忽略 2.只需挑循环中的一个基本操作分析它的执行次数与 n 的关系即可 3.如果有多层嵌套循环，只需关注最深层循环循环了几次 最坏时间复杂度：最坏情况下算法的时间复杂度 平均时间复杂度：所有输入示例等概率出现的情况下，算法的期望运行时间 最好时间复杂度：最好情况下算法的时间复杂度 程序运行时的内存需求 无论问题规模怎么变，算法运行所需的内存空间都是固定的常量，算法空间复杂度为S(n) = O(1) 注：S 表示 “Space”算法原地工作——算法所需内存空间为常量 O(1) \u0026lt; O(log2n) \u0026lt; O(n) \u0026lt; O(nlog2n) \u0026lt; O(n2) \u0026lt; O(n3) \u0026lt; O(2n) \u0026lt; O(n!) \u0026lt; O(nn) 函数递归带来的内存开销 空间复杂度 = 递归调用的深度\n线性表 线性表定义、基本操作 定义 线性表是具有相同数据类型的n（n≥0）个数据元素的有限 序列，其中n为表长，当n = 0时线 性表是一个空表。若用L命名线性表，则其一般表示为L = (a1, a2, \u0026hellip; , ai, ai+1, \u0026hellip; , an)\n几个概念： ai 是线性表中的“第i个”元素线性表中的位序 a1 是表头元素；an 是表尾元素。 除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继 a1 a2 a3 a4 a5\n有次序 注意：位序从1开始 数组下标从0开始 每个数据元素所占空间一样大\n基本操作 InitList(\u0026amp;L):初始化表。构造一个空的线性表L，分配内存空间。\nDestroyList(\u0026amp;L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。\nListInsert(\u0026amp;L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e。\nListDelete(\u0026amp;L,i,\u0026amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。\nLocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。\nGetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。\n其他常用操作：\nLength(L)：求表长。返回线性表L的长度，即L中数据元素的个数。\nPrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值。\nEmpty(L)：判空操作。若L为空表，则返回true，否则返回false。\nKey：命名要有可读性\nTips： ①对数据的操作（记忆思路） —— 创销、增删改查 ②C语言函数的定义 —— \u0026lt;返回值类型\u0026gt; 函数名 (\u0026lt;参数1类型\u0026gt; 参数1，\u0026lt;参数2类型\u0026gt; 参数2，\u0026hellip;\u0026hellip;) ③实际开发中，可根据实际需求定义其他的基本操作 ④函数名和参数的形式、命名都可改变（Reference：严蔚敏版《数据结构》） ⑤什么时候要传入引用“\u0026amp;” —— 对参数的修改结果需要“带回来”\n顺序表的定义 线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列。\n顺序表——用顺序存储的方式实现线性表顺序存储。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。 顺序表的实现\u0026ndash;静态分配 代码实现： 1 2 3 4 5 #define MaxSize 10 //定义最大长度 typedef struct{ ElemType data[MaxSize]; //用静态的“数组”存放数据元素 int length; //顺序表的当前长度 }SqList; //顺序表的类型定义（静态分配方式） InitList函数（静态分配） 1 2 3 4 5 6 void InitList(SqList \u0026amp;L){ for(int i=0;i\u0026lt;MaxSize;i++){ data[i]=0; } L.length=0; } 注意：如果不进行初始化，内存中会有遗留的“脏数据”，但其实如果正常访问的话（指在进行访问数据的时候，没有赋值的不去访问），也不会有影响，也可以直接把长度设为零即可。\n顺序表的实现\u0026ndash;动态分配 代码实现： 1 2 3 4 5 6 #define InitSize 10 //顺序表的初始长度 typedef struct{ ElemType *data; //指示动态分配数组的指针 int MaxSize; //顺序表的最大容量 int length; //顺序表的当前长度 } SeqList; //顺序表的类型定义（动态分配方式） malloc函数 L.data = (ElemType *) malloc (sizeof(ElemType) * InitSize) 注：需要包含头文件\u0026lt;stdlib.h\u0026gt; InitList函数（动态分配） 1 2 3 4 5 void InitLIst(SqList \u0026amp;L){ L.data=(int *)malloc(InitSize*sizeof(int)); L.length=0; L.Maxsize=InitSize; } IncreaseSize函数（动态分配）（增加数组的长度） 1 2 3 4 5 6 7 8 9 void IncreaseSize(SqList \u0026amp;L,int len){ int *p=L.data; L.data=(int *)malloc((L.MaxSize+len)*sizeof(int)); for(int i=0;i\u0026lt;L.length;i++){ L.data[i]=p[i]; } L.MaxSize+=len; free(p); } 顺序表的特点： ①随机访问，即可以在 O(1) 时间内找到第 i 个元素。 ②存储密度高，每个节点只存储数据元素 ③拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高） ④插入、删除操作不方便，需要移动大量元素 顺序表的插入与删除 顺序表的基本操作\u0026ndash;插入 ListInsert(\u0026amp;L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e。 注：本节代码建立在顺序表的“静态分配”实现方式之上，“动态分配” 也雷同。\n1 2 3 4 5 6 7 8 9 bool ListInsert(SqList \u0026amp;L,int i,int e){ if(i\u0026lt;1||i\u0026gt;L.length+1) return false;//判断i的值是否有效 if(L.length\u0026gt;L.MaxSize) return true;//当前存储空间已满，不能插入 for(int j=L.length;j\u0026gt;=i;j--) L.data[j]=L.data[j-1]; L.data[i-1]=e; L.length++; return true; } 注：好的算法，应该具有“健壮性”。能处理异常情况，并给使用者反馈\n时间复杂度的计算： 最好情况：新元素插入到表尾，不需要移动元素 i = n+1，循环0次；最好时间复杂度 = O(1) 最坏情况：新元素插入到表头，需要将原有的 n 个元素全都向后移动 i = 1，循环 n 次；最坏时间复杂度 = O(n); 平均情况：假设新元素插入到任何一个位置的概率相同，即 i = 1,2,3, \u0026hellip; , length+1 平均时间复杂度 = O(n) 顺序表的基本操作\u0026ndash;删除 ListDelete(\u0026amp;L,i,\u0026amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。\n1 2 3 4 5 6 7 8 9 bool ListDelete(SqList \u0026amp;L,int i,int \u0026amp;e){ if(i\u0026lt;1||i\u0026gt;L.length) return false; e=L.data[i]; for(int j=i;j\u0026lt;L.length;j++){ L.data[j-1]=L.data[j]; } L.length--; return true; } 顺序表的查找 按位查找 GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。\n静态分配 1 2 3 4 5 6 7 8 #define MaxSize 10 //定义最大长度 typedef struct{ ElemType data[MaxSize]; //用静态的“数组”存放数据元素 int length; //顺序表的当前长度 }SqList; ElemType GetElem(SqList L, int i){ return L.data[i-1]; } 动态分配 1 2 3 4 5 6 7 8 9 #define InitSize 10 //顺序表的初始长度 typedef struct{ ElemType *data; //指示动态分配数组的指针 int MaxSize; //顺序表的最大容量 int length; //顺序表的当前长度 } SeqList; //顺序表的类型定义（动态分配方式） ElemType GetElem(SeqList L, int i){ return L.data[i-1]; } 注意，时间复杂度为O(1)\n按值查找 LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。\n静态分配 1 2 3 4 5 6 int LocateElem(SeqList L,ElemType e){ for(int i=0;i\u0026lt;L.length;i++) if(L.data[i]==e) return i+1; //数组下标为i的元素值等于e，返回其位序i+1 return 0; //退出循环，说明查找失败 } 动态分配 1 2 3 4 5 6 int LocateElem(SeqList L,int e){ for(int i=0;i\u0026lt;L.length;i++) if(L.data[i]==e) return i+1; return 0; } 单链表的定义 顺序表与单链表的优缺点 顺序表：优点：可随机存取，存储密度高 缺点：要求大片连续空间，改变容量不方便 单链表：优点：不要求大片连续空间，改变容量方便 缺点：不可随机存取，要耗费一定空间存放指针 单链表的代码实现 1 2 3 4 struct LNode*{ ElemType data; struct LNode* next; }LNode,LinkList; 增加一个新的结点：在内存中申请一个结点所需空间，并用指针 p 指向这个结点 struct LNode * p = (struct LNode *) malloc(sizeof(struct LNode)); typedef 关键字 —— 数据类型重命名 typedef \u0026lt;数据类型\u0026gt; \u0026lt;别名\u0026gt; 强调这是一个单链表 ——使用 LinkList 强调这是一个结点 ——使用 LNode * GetElem函数的代码实现（更好地理解LNode *和LinkList) 1 2 3 4 5 6 7 8 9 10 11 LNode *GetElem(LinkList L,int i){ int j=1; LNode *p=L-\u0026gt;next; if(i==0) return L; if(i\u0026lt;1) return NULL; while(p!=NULL \u0026amp;\u0026amp; j\u0026lt;i){ p=p-\u0026gt;next; j++ } return p; } 头插法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 LinkList List_HeadInsert(LinkList \u0026amp;L){//逆向建立单链表 LNode *s; int x; L=(LinkList)malloc(sizeof(LNode));//创建头结点 L-next=NULL;//初始化为空链表 cin\u0026gt;\u0026gt;x;//输入结点的值 while(x!=9999）{//输入9999表示结束 s=(LNode *)malloc(sizeof(LNode));//创建新结点 s-\u0026gt;data=x; s-\u0026gt;next=L-\u0026gt;next; L-\u0026gt;next=s;//将新结点插入表中，L为头指针 cin\u0026gt;\u0026gt;x; } return L; } 不带头结点的单链表与带头结点的单链表 带头结点，写代码更方便，用过都说好 初始化代码实现\n1 2 3 4 bool InitList(LinkList \u0026amp;L){ L=NULL; return true } 判空代码实现\n1 2 bool Empty(LinkList \u0026amp;L){ return (L==NULL) 不带头结点，写代码更麻烦对第一个数据结点和后续数据结点的处理需要用不同的代码逻辑对空表和非空表的处理需要用不同的代码逻辑 初始化代码实现\n1 2 3 4 5 bool InitList(LinkList \u0026amp;L){ L=(LNode *)malloc(sizeof(LNode));//分配一个头结点 if(L=NULL) return false;//内存不足，分配失败 L-\u0026gt;next=NULL；//头结点暂时还没有结点 return true; 判空代码实现\n1 2 3 bool Empty(LinkList \u0026amp;L){ return (L-\u0026gt;next==NULL) } 单链表的插入与删除 按位序插入（带头结点） ListInsert(\u0026amp;L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 bool ListInsert(LinkList \u0026amp;L,int i,ElemType e){ if(i\u0026lt;1) return false; LNode *p; int j=0; p=L; while(p!=NULL \u0026amp;\u0026amp; j=i-1){ p=p-\u0026gt;next; j++; } if(p==NULL) return false; LNOde *s=(LNode *)malloc(sizeof(LNode)); s-\u0026gt;data=e; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; return true; 按位序插入（不带头结点） 不存在 “第0个”结点，因此 i=1 时需要特殊处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 bool ListInsert(LinkList \u0026amp;L,int i,ElemType e){ if(i\u0026lt;1) return false; if(i==1){ LNode *s=(LNode *)malloc(sizeof(LNode)); s-\u0026gt;data=e; s-\u0026gt;next=L-\u0026gt;next; L=s; return true; } LNode *p; int j=0; p=L; while(p!=NULL \u0026amp;\u0026amp; j=i-1){ p=p-\u0026gt;next; j++; } if(p==NULL) return false; LNOde *s=(LNode *)malloc(sizeof(LNode)); s-\u0026gt;data=e; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; return true; 指定结点的后插操作 1 2 3 4 5 6 7 8 9 10 bool InsertNextNode(LNode *p,ElemType e){ if(p==NULL) return false; LNode *s=(LNode *)malloc(sizeof(LNode)); if(s==NULL) return false;//内存分配失败 s-\u0026gt;data=e; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; return true; 指定结点的前插操作 1 2 3 4 5 6 7 8 9 10 11 12 bool InsertPriorNode(LNode *p,ElemType e){ if(p==NULL) return false; LNode *s=(LNode *)malloc(sizeof(LNode)); if(s==NULL) return false;//内存分配失败 s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; s-\u0026gt;data=p-\u0026gt;data; p-\u0026gt;data=e; return true; } 王道书版本：\n1 2 3 4 5 6 7 8 9 10 bool InsertPriorNode(LNode *p,LNode *s){ if(p==NULL||s==NULL) return false; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; ElemType temp=p-\u0026gt;data; p-\u0026gt;data=s-\u0026gt;data; s-\u0026gt;data=temp; return true; } 按位序删除（带头结点） ListDelete(\u0026amp;L,i,\u0026amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 bool ListDelete(LinkList \u0026amp;L,int i,ElemType \u0026amp;e){ if(i\u0026lt;1) return false; LNode *p; int j=0; p=L; while(p!=NULL \u0026amp;\u0026amp; j\u0026lt;i-1){//循环找到i-1个结点 p=p-\u0026gt;next; j++; } if(p==NULL) return false;//i值不合法 if(p-\u0026gt;next==NULL) return false;//i-1后已无其他结点 LNode *q=p-\u0026gt;next; e=q-\u0026gt;data; p-\u0026gt;next=q-\u0026gt;next; free(q); return true; } 指定结点的删除 ListDelete(LNode *p)：删除指定结点p。\n1 2 3 4 5 6 7 8 9 bool ListDelete(LNode *p){ if(p==NULL) return false; LNode *q=p-\u0026gt;next; p-\u0026gt;data=q-\u0026gt;next-\u0026gt;data; p-next=q-\u0026gt;next; free(q); return true; } 注意：如果p是最后一个结点\u0026hellip;只能从表头开始依次寻找p的前驱，时间复杂度 O(n)\n单链表的查找 按位查找 GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。\n1 2 3 4 5 6 7 8 9 10 11 LNode *GetElem(LinkList L,int i){ if(i\u0026lt;0) return false; LNode *p; int j=0; p=L; while(p!=NULL \u0026amp;\u0026amp; j\u0026lt;i){//循环找到i个结点 p=p-\u0026gt;next; j++; } return p; } 王道书版本：\n1 2 3 4 5 6 7 8 9 10 11 LNode *GetElem(LinkList L,int i){ int j=1; p=L-\u0026gt;next; if(i==0) return L; if(i\u0026lt;1) return NULL; while(p!=NULL \u0026amp;\u0026amp; j\u0026lt;i){ p=p-\u0026gt;next; j++; } return p; } 按值查找 LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。\n1 2 3 4 5 6 7 LNode *LocateElem(LinkList L,ElemType e){ LNode *p=L-\u0026gt;next; while(p!=NULL \u0026amp;\u0026amp; p-\u0026gt;data!=e){ p=p-\u0026gt;next; } return p; } 求表的长度 1 2 3 4 5 6 7 8 9 int length(LinkList L){ int len=0; LNode *p=L; while(p-\u0026gt;next!=NULL){ p=p-\u0026gt;next; len++; } return len; } 单链表的建立 头插法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 LinkList List_HeadInsert(LinkList \u0026amp;L){ //逆向建立单链表 LNode *s; int x; L=(LinkList)malloc(sizeof(LNode)); //创建头结点 L-\u0026gt;next=NULL; //初始为空链表 cin\u0026gt;\u0026gt;x; //输入结点的值 while(x!=9999){ //输入9999表示结束 s=(LNode*)malloc(sizeof(LNode)); //创建新结点 s-\u0026gt;data=x; s-\u0026gt;next=L-\u0026gt;next; L-\u0026gt;next=s; //将新结点插入表中，L为头指针 cin\u0026gt;\u0026gt;x; } return L; } 尾插法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 LinkList List_TailInsert(LinkList \u0026amp;L){//正向建立单链表 int x; L=(LNode *)malloc(sizeof(LNode));//建立头结点（初始化空表） LNode *s,*r;=L;//r为表尾指针 cin\u0026gt;\u0026gt;x;//输入结点的值 while(x!=9999){//输入9999表示结束 s=(LNode *)malloc(sizeof(LNode)); s-\u0026gt;data=x; r-\u0026gt;next=s;//以上三步表示在r结点之后插入x r=s;//r指向新的结点 cin\u0026gt;\u0026gt;x; } r-\u0026gt;next=NULL;//尾指针置空 return L; } 头插法的重要应用：链表的逆置\n1 2 3 4 5 6 7 8 9 10 ListNode* reverseList(ListNode* head) { ListNode* newHead = nullptr;// 新链表头节点，初始为空 while (head) { ListNode* nextNode = head-\u0026gt;next;// 保存原链表的下一个节点 head-\u0026gt;next = newHead;// 当前节点插入到新链表头部 newHead = head;// 更新新链表的头节点 head = nextNode;// 移动到下一个节点 } return newHead; } 双链表 单链表和双链表的区别 单链表：无法逆向检索，有时候不太方便 双链表：可进可退，存储密度更低一丢丢 双链表的初始化（带头结点） 1 2 3 4 5 6 7 8 9 10 11 typedef struct DNode{ ElemType data; struct DNode *prior,*next; }DNode, *DLinkList; bool InitDLinkList(DLinkList \u0026amp;L){ L=(DNode *)malloc(sizeof(DNode));//建立头结点 if(L=NULL) return false; L-\u0026gt;prior=NULL;//prior永远指向NULL L-\u0026gt;next=NULL;//next后暂时还没有结点 return true; } 双链表的插入 1 2 3 4 5 6 7 8 9 10 11 12 bool InsertNextNode(DNode *p,DNode *s){ if(p==NULL||q==NULL){ return false; s-\u0026gt;next=p-\u0026gt;next; if(p-\u0026gt;next!=NULL){ p-\u0026gt;next-\u0026gt;prior=s; } s-\u0026gt;prior=p; p-\u0026gt;next=s; return true; } } 双链表的删除 删除p结点的后续结点 1 2 3 4 5 6 7 8 9 10 11 12 bool DeleteNextDNode(DNode *p){ if(p==NULL) return false; DNode *q=p-\u0026gt;next; if(q==NULL) return false;//p没有后继 p-\u0026gt;next=q-\u0026gt;next; if(q-\u0026gt;next!=NULL)//q结点不是最后一个结点 q-\u0026gt;next-\u0026gt;prior=p; free(q);//释放空间 return true; } 删除整个双链表 1 2 3 4 5 6 void DestroyList(DLinkList \u0026amp;L){ while(L-\u0026gt;next!=NULL) DeleteNextDNode(L);//循环释放各个结点 free(L);//释放头结点 L=NULL;//头指针指向NULL } 双链表的遍历 后向遍历 1 2 3 4 while(p!=NULL){ //对结点p做相应处理，如打印 p = p-\u0026gt;next; } 前向遍历 1 2 3 4 while(p!=NULL){ //对结点p做相应处理，如打印 p = p-\u0026gt;prior; } 前向遍历（不带头结点） 1 2 3 4 while(p-\u0026gt; prior != NULL){ //对结点p做相应处理 p = p-\u0026gt;prior; } 循环链表 循环单链表 循环单链表的特点：\n单链表：表尾结点的next指针指向 NULL 从一个结点出发只能找到后续的各个结点 循环单链表：表尾结点的next指针指向头结点 从一个结点出发可以找到其他任何一个结点 初始化循环单链表 1 2 3 4 5 6 7 bool InitList(LinkList \u0026amp;L){ L=(LNode *)malloc(sizeof(LNode)); if(L=NULL) return false; L-\u0026gt;next=L;//头结点next指向头结点 return true; } 判断循环单链表是否为空 1 2 3 4 5 6 7 bool Empty(LinkList L){ if(L-\u0026gt;next==L){ return true; } else return false; } 判断结点p是否为循环单链表的表尾结点 1 2 3 4 5 6 bool isTail(LinkList L,LNode *p){ if(p-\u0026gt;next==L) return true; else return false; } 循环双链表 双链表：表头结点的 prior 指向 NULL； 表尾结点的 next 指向 NULL 循环双链表：表头结点的 prior 指向表尾结点； 表尾结点的 next 指向头结点 初始化循环双链表 1 2 3 4 5 6 7 8 bool InitDList(DLinkList \u0026amp;L){ L=(DNode *)malloc(sizeof(DNode)); if(L=NULL) return false; L-\u0026gt;next=L; L-\u0026gt;prior=L; return true; } 判断循环单链表是否为空 1 2 3 4 5 6 7 bool Empty(DLinkList L){ if(L-\u0026gt;next==L){ return true; } else return false; } 判断结点p是否为循环单链表的表尾结点 1 2 3 4 5 6 bool isTail(DLinkList L,DNode *p){ if(p-\u0026gt;next==L) return true; else return false; } 静态链表 单链表：各个结点在内存中星罗棋布、散落天涯。 静态链表：分配一整片连续的内存空间，各个结 点集中安置。 静态链表的定义 1 2 3 4 5 #define MaxSize 10//静态链表的最大长度 typedef struct Node{//静态链表结构类型的定义 ElemType data;//存储数据元素 int next;//下一个元素的数组下标 }SLinkList[MaxSize]; SLinkList b —— 相当于定义了一个长度为 MaxSize 的 Node型数组\n基本操作的简述 初始化静态链表：把 a[0] 的 next 设为 -1，把其他结点的 next 设为一个特殊值用来表示结点空闲，如 -2 查找：从头结点出发挨个往后遍历结点 删除某个结点： ①从头结点出发找到前驱结点 ②修改前驱结点的游标 ③被删除结点 next 设为 -2 插入位序为i的结点：1.找到一个空的结点，存入数据元素 2.从头结点出发找到位序为i-1的结点 3.修改新结点的next 4.修改i-1号结点的next 静态链表的特点 静态链表：用数组的方式实现的链表 优点：增、删 操作不需要大量移动元素 缺点：不能随机存取，只能从头结点开始依次往后查找；容量固定不可变 适用场景：①不支持指针的低级语言；②数据元素数量固定不变的场景（如操作系统的文件分配表FAT）\n顺序表和链表的对比 逻辑结构 都属于线性表，都是线性结构\n存储结构 顺序表：优点：支持随机存取、存储密度高 缺点：大片连续空间分配不方便，改变容量不方便 链表：优点：离散的小空间分配方便，改变容量方便 缺点：不可随机存取，存储密度低 基本操作 顺序表：1.需要预分配大片连续空间。若分配空间过小，则之后不方便拓展容量；若分配空间过大，则浪费内存资源 2.插入/删除元素要将后续元素都后移/前移 3.时间复杂度 O(n)，时间开销主要来自移动元素 4.移动的时间代价很高 5.按位查找：O(1) 6.按值查找：O(n)若表内元素有序，可在O(log2n) 时间内找到 链表：1.只需分配一个头结点（也可以不要头结点，只声明一个头指针），之后方便拓展 2.插入/删除元素只需修改指针即可 3.时间复杂度 O(n)，时间开销主要来自查找目标元素 4.查找元素的时间代价更低 5.按位查找：O(n) 6.按值查找：O(n） 栈、队列和数组 栈的基本概念 线性表是具有相同数据类型的n（n≥0）个数据元素的有限 序列，其中n为表长，当n = 0时线 性表是一个空表。若用L命名线性表，则其一般表示为 L = (a1, a2, \u0026hellip; , ai, ai+1, \u0026hellip; , an) 栈（Stack）是只允许在一端进行插入或删除操作的线性表 栈的基本操作 InitStack(\u0026amp;S)：初始化栈。构造一个空栈 S，分配内存空间。\nDestroyStack(\u0026amp;S)：销毁栈。销毁并释放栈 S 所占用的内存空间。\nPush(\u0026amp;S,x)：进栈，若栈S未满，则将x加入使之成为新栈顶。\nPop(\u0026amp;S,\u0026amp;x)：出栈，若栈S非空，则弹出栈顶元素，并用x返回。\nGetTop(S, \u0026amp;x)：读栈顶元素。若栈 S 非空，则用 x 返回栈顶元素\n其他常用操作：\nStackEmpty(S)：判断一个栈 S 是否为空。若S为空，则返回true，否则返回false。\n常见问题：栈的进出栈问题 进栈顺序： a-\u0026gt;b-\u0026gt;c-\u0026gt;d-\u0026gt;e 有哪些合法的出栈顺序？ n个不同元素进栈，出栈元素不同排列的个数为1/n+1C2nn\n上述公式称为卡特兰（Catalan）数，可采用数学归纳法证明（不要求掌握）。\n顺序栈的实现 顺序栈的定义 1 2 3 4 5 #define MaxSize 10 typedef struct{ ElemType data[MaxSize];//静态数组中存放栈中元素 int top;//栈顶指针 }SqStack; 初始化操作 1 2 3 void InitStack(SqStack \u0026amp;S){ S.top=-1; } 判空操作 1 2 3 4 5 6 7 bool StackEmpty(SqStack S){ if(top==-1) return true; else return false; } 进栈操作 1 2 3 4 5 6 7 8 bool Push(SqStack \u0026amp;S,ElemType x){ if(S.top==MaxSize-1) return false;//栈满，操作失败 S.top+=1; S.data[S.top]=x; //这两步可以直接写为S.data[++S.top]=x return true; } 出栈操作 1 2 3 4 5 6 7 8 bool pop(SqStack \u0026amp;S,ElemType \u0026amp;x){ if(S.top==-1) return false;//栈空，报错 x=S.data[S.top]; S.top-=1; //这两步可以直接写为x=S.data[S.top--] return true; } 读栈顶元素 1 2 3 4 5 6 bool GetTop(SqStack \u0026amp;S,ElemType \u0026amp;x){ if(S.top==-1) return false; x=S.data[S.top]; return true; } 另一种方式 另一种方式就是把S.top的初始值设为0，其他地方一致\n共享栈 1 2 3 4 5 6 #define MaxSize 10 typedef struct{ ElemType data[MaxSize]; int top0;//0号栈栈顶指针 int top1;//1号栈栈顶指针 }ShStack; 初始化栈\n1 2 3 4 void InitStack(SqStack \u0026amp;S){ S.top0=-1; S.top1=MaxSize; } 注意！栈满的条件：top0 + 1 == top1\n链栈的实现 链栈的定义 1 2 3 4 typedef struct LinkNode{ ElemType data;//数据域 struct LinkNode *next;//指针域 }*LiStack;//栈类型定义 进栈/出栈都只能在栈顶一端进行（链头作为栈顶）\n队列的基本概念 队列的定义 队列（Queue）是只允许在一端进行插入，在另一端删除的线性表 队列的特点：先进先出 First In First Out（FIFO） 队头：允许删除的一端 队尾：允许插入的一端 队列的基本操作 InitQueue(\u0026amp;Q)：初始化队列，构造一个空队列Q。\nDestroyQueue(\u0026amp;Q)：销毁队列。销毁并释放队列Q所占用的内存空间。\nEnQueue(\u0026amp;Q,x)：入队，若队列Q未满，将x加入，使之成为新的队尾。\nDeQueue(\u0026amp;Q,\u0026amp;x)：出队，若队列Q非空，删除队头元素，并用x返回。\nGetHead(Q,\u0026amp;x)：读队头元素，若队列Q非空，则将队头元素赋值给x。\n其他常用操作：\nQueueEmpty(Q)：判队列空，若队列Q为空返回true，否则返回false。\n队列的顺序实现 顺序队列的定义 1 2 3 4 5 #define MaxSize 10 typedef struct{ ElemType data[MaxSzie];//用静态数组存放队列元素 int front,rear;//队头指针和队尾指针 }SqQueue; 注意：rear指向队尾元素的后一个位置（下一个应该插入的位置）\n初始化操作 1 2 3 void InitQueue(SqQueue \u0026amp;Q){ Q.front=Q.rear=0; } 判空操作 1 2 3 4 5 6 bool QueueEmpty(SqQueue \u0026amp;Q){ if(Q.rear==Q.front) return true; else return false; } 入队操作 1 2 3 4 5 6 7 bool EnQueue(SqQueue \u0026amp;Q,ElemType x){ if((Q.rear+1)%MaxSize==Q.front) return false; Q.data[Q.rear]=x; Q.rear=(Q.rear+1)%MaxSize; return true; } 队列已满的条件：队尾指针的再下一个位置是队头，即 (Q.rear+1)%MaxSize==Q.front\n判空操作 1 2 3 4 5 6 bool QueueEmpty(SqQueue Q){ if(Q.rear==Q.front) return true; else return false; } 出队操作 1 2 3 4 5 6 7 bool DeQueue(SqQueue \u0026amp;Q,ElemType \u0026amp;x){ if(Q.rear==Q.front) return false; x=Q.data[Q.front]; Q.front=(Q.front+1)\u0026amp;MaxSize; return true; } 获得对头元素的值，用x的值 1 2 3 4 5 6 bool GetHead(SqQueue Q,ElemType \u0026amp;x){ if(Q.rear==Q.front) return false; x=Q.data[Q.front]; return true; } 判断队列已满/已空 方案一 队列已满的条件：队尾指针的再下一个位置是队头，即(Q.rear+1)%MaxSize==Q.front 队空条件：Q.rear==Q.front 队列元素个数：(rear+MaxSize-front)%MaxSize 缺点：浪费了一个存储空间 方案二 定义数据结构时，多定义一个int类型的size，插入成功size++，插入失败size\u0026ndash; 队列已满的条件：size==MaxSize 队空条件：size==0 方案三 定义数据结构时，多定义一个int类型的tag，每次删除操作成功时，都令tag=0；每次插入操作成功时，都令tag=1；只有删除操作，才可能导致队空；只有插入操作，才可能导致队满 队满条件：front==rear \u0026amp;\u0026amp; tag == 1 队空条件：front==rear \u0026amp;\u0026amp; tag == 0 队列的链式实现 链式队列的定义 1 2 3 4 5 6 7 typedef struct LinkNode{ ElemType data; struct LinkNode *next }LinkNode; typedef struct{ LinkNode *front,*rear; }LinkQueue; 初始化链式队列（带头结点） 1 2 3 4 5 void InitQueue (LinkQueue \u0026amp;Q){ //初始时 front、rear 都指向头结点 Q. front=Q. rear=(LinkNode*)malloc(sizeof(LinkNode)); Q. front-\u0026gt;next=NULL; } 判空操作（带头结点） 1 2 3 4 5 6 bool IsEmpty (LinkQueue Q){ if(Q. front==Q. rear) return true; else return false; } 初始化链式队列（不带头结点） 1 2 3 4 5 void InitQueue (LinkQueue \u0026amp;Q){ //初始时front、rear都指向NULL Q. front=NULL; Q. rear=NULL; } 判空操作（不带头结点） 1 2 3 4 5 6 bool IsEmpty (LinkQueue Q){ if(Q.front==NULL) return true; else return false; } 入队（带头结点） 1 2 3 4 5 6 7 void EnQueue (LinkQueue \u0026amp;Q, ElemType x){ LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode)); s-\u0026gt;data=x; s-\u0026gt;next=NULL; Q.rear-\u0026gt;next=s;//新结点插入到rear之后 Q.rear=s;//修改表尾指针 } 入队（不带头结点） 1 2 3 4 5 6 7 8 9 10 11 12 void EnQueue(LinkQueue \u0026amp;Q, ElemType x){ LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode)); s-\u0026gt;data=x; s-\u0026gt;next=NULLi if(Q.front = NULL){//在空队列中插入第一个元素 Q.front = s; Q. rear=s;//修改队头队尾指针不带头结点的队列，第一个元素入队时需要特别处理 }else{ Q. rear-\u0026gt;next=s;//新结点插入到 rear 结点之后 Q. rear=s;//修改 rear 指针 } } 出队（带头结点） 1 2 3 4 5 6 7 8 9 10 11 bool DeQueue(LinkQueue \u0026amp;Q, ElemType \u0026amp;x){ if(Q.front==Q.rear) return false;//空队 LinkNode *p=Q.front-\u0026gt;next; x=p-\u0026gt;data;//用变量x返回队头元素 Q.front-\u0026gt;next=p-\u0026gt;next; //修改头结点的 next 指针 if(Q.rear==p)//此次是最后一个结点出队 Q. rear=Q. front;//修改 rear 指针 free(p);//释放结点空间 return true; } 出队（不带头结点） 1 2 3 4 5 6 7 8 9 10 11 12 13 bool DeQueue(LinkQueue \u0026amp;Q, ElemType \u0026amp;x){ if(Q. front==NULL) return false;//空队 LinkNode *p=Q.front;//p指向此次出队的结点 x=p-\u0026gt;data//用变量x返回队头元素 Q. front=p-\u0026gt;next;//修改 front 指针 if(Q. rear==p){//此次是最后一个结点出队 Q. front = NULL; Q. rear = NULL; } free (p);//释放结点空间 return true; } 队列满的条件 双端队列 ![](https://raw.githubusercontent.com/Manunited-0518/ImageStore/main/images/截屏2024-12-02 18.46.59.png)\n判断输出序列的合法性 根据逻辑进行判断即可\n栈的应用\u0026ndash;括号匹配 最后出现的左括号最先被匹配(LIFO)，每出现一个右括号，就“消耗”（出栈）一个左括号\n算法流程图 算法实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool bracketCheck(char str[l, int length) { SqStack S; InitStack（S）； //初始化一个栈 for (int i=0; i\u0026lt;length; i++){ if （strlil==\u0026#39;（\u0026#39;|| strlil==\u0026#39;［\u0026#39;I| strli］==\u0026#39;｛\u0026#39;）｛ Push（S，str［i］）；//扫描到左括号，入栈 else 1 if(StackEmpty(S))1/扫描到右括号，且当前栈空 return false;//匹配失败 char topElem; Pop（S,topElem）； //栈顶元素出栈 if(str[i]==\u0026#39;)\u0026#39; \u0026amp;\u0026amp; topElem!=\u0026#39;(\u0026#39;) return false; if(str[i]=\u0026#39;]\u0026#39; \u0026amp;\u0026amp; topElem!=\u0026#39;[\u0026#39;) return false; if(str[i]=\u0026#39;}\u0026#39; \u0026amp;\u0026amp; topElem!=\u0026#39;{\u0026#39;) return false; } return StackEmpty（S）； //检索完全部括号后，栈空说明匹配成功 注意：考试中可直接使用基本操作，建议简要说明接口\n//初始化栈 void InitStack(SqStack \u0026amp;S) //判断栈是否为空 bool StackEmpty(SqStack S) //新元素入栈 bool Push(SqStack \u0026amp;S, char x) 11栈顶元素出栈，用×返回 bool Pop (SqStack \u0026amp;S, char \u0026amp;x)\n栈的应用\u0026ndash;表达式求值 表达式分为三个部分：操作数、运算符、界限符\n波兰科学家的一个灵感：可以不用界限符也能无歧义地表达运算顺序 Reverse Polish notation（逆波兰表达式=后缀表达式） Polish notation（波兰表达式=前缀表达式） 中缀表达式\u0026mdash;运算符在两个操作数中间 后缀表达式\u0026mdash;运算符在两个操作数后面 前缀表达式\u0026mdash;运算符在两个操作数前面 中缀表达式转后缀表达式（手算） 中缀转后缀的手算方法： ① 确定中缀表达式中各个运算符的运算顺序 ② 选择下一个运算符，按照「左操作数 右操作数运算符」的方式组合成一个新的操作数 ③ 如果还有运算符没被处理，就继续 ②\n私房菜：“左优先”原则，不要Freestyle，保证手算和机算结果相同 “左优先”原则：只要左边的运算符能先计算，就优先算左边的\u0026mdash;-可保证运算顺序唯一\n运算顺序不唯一，因此对应的后缀表达式也不唯一\n后缀表达式的计算方法（手算）： 从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，合体为一个操作数 注意：两个操作数的左右顺序 特点：最后出现的操作数先被运算\n用栈实现后缀表达式的计算（机算）： ①从左往右扫描下一个元素，直到处理完所有元素 ②若扫描到操作数则压入栈，并回到①；否则执行③ ③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到① 注意：先出栈的是“右操作数” 若表达式合法，则最后栈中只会留下一个元素，就是最终结果\n中缀表达式转前缀表达式（手算） 中缀转前缀的手算方法： ① 确定中缀表达式中各个运算符的运算顺序 ② 选择下一个运算符，按照「运算符 左操作数 右操作数」的方式组合成一个新的操作数 ③ 如果还有运算符没被处理，就继续② “右优先”原则：只要右边的运算符能先计算，就优先算右边的 注意：先出栈的是“左操作数”\n中缀表达式转后缀表达式（机算） 初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。 从左到右处理各个元素，直到末尾。可能遇到三种情况： ① 遇到操作数。直接加入后缀表达式。 ② 遇到界限符。遇到“(”直接入栈；遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到弹出“(”为止。注意：“(”不加入后缀表达式。 ③ 遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“(”或栈空则停止。之后再把当前运算符入栈。 按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。\n中缀表达式的计算（用栈实现） 用栈实现中缀表达式的计算： 初始化两个栈，操作数栈和运算符栈 若扫描到操作数，压入操作数栈 若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈）\n本质：中缀转后缀+后缀表达式求值，两个算法的结合 栈的应用\u0026ndash;递归 函数调用背后的过程 函数调用的特点：最后被调用的函数最先执行结束（LIFO） 函数调用时，需要用一个栈存储： ① 调用返回地址 ② 实参 ③ 局部变量 栈在递归中的应用 适合用“递归”算法解决：可以把原始问题转换为属性相同，但规模较小的问题\nEg1：计算正整数的阶乘 n！ 1 2 3 4 5 6 int factorial (int n){ if (n==0 || n==1) return 1; else return n*factorial(n-1); } 递归调用时，函数调用栈可称为“递归工作栈” 每进入一层递归，就将递归调用所需信息压入栈顶 每退出一层递归，就从栈顶弹出相应信息\n缺点：太多层递归可能会导致栈溢出\nEg 2：求斐波那契数列 1 2 3 4 5 6 7 8 int Fib(int n){ if(n==0) return 0; else if (n==1) return 1; else return Fib(n-1)+Fib(n-2); } 可以自定义栈将递归算法改造成非递归算法\n队列的应用 队列应用一一树的层次遍历 队列应用——图的广度优先遍历 队列在操作系统中的应用 多个进程争抢着使用有限的系统资源时，FCFS（First Come First Service，先来先服务）\u0026mdash;可用队列实现\u0026mdash;是一种常用策略。 Eg：CPU资源的分配、打印数据缓冲区 串 串的定义和基本操作 串的定义 串，即字符串（String）是由零个或多个字符组成的有限序列。一般记为 S=\u0026lsquo;a1a2\u0026hellip;\u0026hellip;an\u0026rsquo;(n≥0) 其中，S是串名，单引号括起来的字符序列是串的值；a，可以是字母、数字或其他字符；串中字符的个数n称串的长度。n=0时的串称空串。\n串 VS 线性表 串是一种特殊的线性表，数据元素之间呈线性关系 串的数据对象限定为字符集（如中文字符、英文字符、数字字符、标点字符等）\n串的基本操作，如增删改查等通常以子串操作对象\n串的基本操作 StrAssign（\u0026amp;T,chars）：赋值操作。把串T赋值为chars。 StrCopy（\u0026amp;T,S）：复制操作。由串S复制得到串T。 StrEmpty（S）：判空操作。若S为空串，则返回TRUE，否则返回FALSE。 StrLength（S）：求串长。返回串S的元素个数。 ClearString（\u0026amp;S）：清空操作。将S清为空串。 DestroyString（\u0026amp;S）：销毁串。将串S销毁（回收存储空间）。 Concat（\u0026amp;T,S1,S2）：串联接。用T返回由S1和S2联接而成的新串 Substring（\u0026amp;Sub,S,pos,len）：求子串。用Sub返回串S的第pos个字符起长度为len的子串。 Index（S,T）：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值\u0026lt;0。 StrCompare（S,T）：比较操作。若S\u0026gt;T，则返回值\u0026gt;0；若S=T，则返回值=0；若S\u0026lt;T，则返回值\u0026lt;0。\n串的比较操作 StrCompare（S,T）：比较操作。若S\u0026gt;T，则返回值\u0026gt;0；若S=T，则返回值=0；若S\u0026lt;T，则返回值\u0026lt;0。\n字符集编码\ny=f(x)\n字符集：函数定义域\n编码：函数映射规则f\ny：对应的二进制数\n任何数据存到计算机中一定是二进制数。 需要确定一个字符和二进制数的对应规则这就是“编码”\n“字符集”：英文字符——ASCII字符集中英文——Unicode字符集 基于同一个字符集，可以有多种编码方案， Eg: UTF-8, UTF-16 注：采用不同的编码方式，每个字符所占空间不同，考研中只需默认每个字符占1B即可\n串的存储结构 串的顺序存储 定义 静态数组 1 2 3 4 5 #define MAXLEN 255//预定义最大串长为255 typedef struct{ char ch[MAXLEN];//每个分量存储一个字符 int length;//串的实际长度 }SString; 动态数组 1 2 3 4 5 6 7 typedef struct{ char *ch; //按串长分配存储区，ch指向串的基地址 int length;//串的长度 }HString: HString S; S.ch = (char *) malloc(MAXLEN * sizeof(char)); S.lenath =0: 存储方式 串的链式存储 1 2 3 4 typedef struct StringNode{ char ch;//每个结点存1个字符 struct StringNode *next; }StringNode, *String; 1 2 3 4 typedef struct StringNode{ char ch [4];//每个结点存多个字符 struct StringNode * next; }StringNode, * String; 基本操作的实现 SubString（\u0026amp;Sub,S,pos,len）：求子串。用Sub返回串S的第pos个字符起长度为len的子串。\n1 2 3 4 5 6 7 8 9 bool SubString (SString \u0026amp;Sub,SString S, int pos, int len){ //子串范围越界 if (pos+len-1 \u0026gt; S.length) return false; for (int i=pos; i\u0026lt;pos+len; i++){ Sub.ch[i-pos+1] = S.ch[il; Sub. length = len; return true } StrCompare(S,T):比较操作。若S\u0026gt;T，则返回值\u0026gt;0；若S=T，则返回值=0；若S\u0026lt;T，则返回值\u0026lt;0。\n1 2 3 4 5 6 7 8 9 //比较操作。若S\u0026gt;T，则返回值\u0026gt;0；若S=T， 则返回值=0；若S\u0026lt;T，则返回值≤0 int StrCompare(SString S, SString T) { for (int i=1; i\u0026lt;=S.length \u0026amp;\u0026amp; i\u0026lt;=T.length; i++){ if (S.ch[i]!=T.ch[i]) return S.ch[il-T.ch[il; } //扫描过的所有字符都相同，则长度长的串更大 return S. length-T. length; } Index（S,T）：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0。 1 2 3 4 5 6 7 8 9 10 int Index(SString S, SString T){ int i=1, n=StrLength(S), m=StrLength(T); SString sub； //用于暂存子串 while(i\u0026lt;=n-m+1){ Substring(sub, S, i,m)； if(StrCompare(sub,T)！=0) ++i； else return i; //返回子串在主串中的位置 } return 0; //S中不存在与T相等的子串 } 字符串\u0026mdash;-朴素模式匹配算法 字符串模式匹配：在主串中找到与模式串相同的子串，并返回其所在位置。\n两种方法：朴素模式匹配算法、KMP算法 朴素模式匹配算法 主串长度为n，模式串长度为 m 朴素模式匹配算法：将主串中所有长度为m的子串依次与模式串对比，直到找到一个完全匹配的子串，或所有的子串都不匹配为止。（最多对比 n-m+1个子串）\n若当前子串匹配失败，则主串指针i指向下一个子串的第一个位置，模式串指针j回到模式串的第一个位置。若j\u0026gt;T.length，则当前子串匹配成功，返回当前子串第一个字符的位置\u0026mdash;-i- T.length\nIndex(S,T):定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0。\n1 2 3 4 5 6 7 8 9 10 int Index(SString S, SString T){ int i=1, n=StrLength(S), m=StrLength(T); String sub;//用于暂存子串 while(i\u0026lt;=n-m+1){//最多对比 n-m+1个子串 SubString(sub,S,i,m);//取出从位置i开始，长度为m的子串 if(Strcompare(sub,T)!=0)//子串和模式串对比，若不匹配，则匹配下一个子串 else return i; //返回子串在主串中的位置 } return 0; //S中不存在与T相等的子串 } 接下来：不使用字符串的基本操作，直接通过数组下标实现朴素模式匹配算法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int Index(SString S,SString T){ int i=1,j=1; while(i\u0026lt;=S.length \u0026amp;\u0026amp; j\u0026lt;=T.length){ if(S.ch [i]==T.ch[j]){ ++1;++j;//继续比较后继字符 } else{ i=1-j+2; j=1;//指针后退重新开始匹配 } if(j\u0026gt;T.length) return i-T.length; else return 0; } 最坏的情况，每个子串都要对比 m 个字符，共n-m+1个子串，复杂度=O((n-m+1)m)=O(nm)\n字符串\u0026mdash;-KMP算法 KMP算法 由D.E.Knuth,J.H.Morris和V.R.Pratt提出，因此称为KMP算法\n不匹配的字符之前，一定是和模式串一致的 Eg：对于模式串 T= ‘abaabc\u0026rsquo; 当第6个元素匹配失败时，可令主串指针i不变，模式串指针j=3 当第5个元素匹配失败时，可令主串指针i不变，模式串指针j=2 当第4个元素匹配失败时，可令主串指针i不变，模式串指针j=2 当第3个元素匹配失败时，可令主串指针i不变，模式串指针j=1 当第2个元素匹配失败时，可令主串指针i不变，模式串指针j=1 当第1个元素匹配失败时，匹配下一个相邻子串，令j=0,i++，j++ next数组 next数组只和短短的模式串有关，和长长的主串无关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int Index_KMP(SString S,SString T,int nextl]){ int i=1, j=1; while (i\u0026lt;=S.length\u0026amp;\u0026amp;j\u0026lt;=T.length){ if (j==0||S.ch[i]==T.chljl){ ++i; ++j;//继续比较后继字符 } else j=next[j];//模式串向右移动 if(j\u0026gt;T. length) return i-T. length；//匹配成功 else return 0; } KMP算法\u0026mdash;-求next数组 next数组的作用：当模式串的第j个字符失配时，从模式串的第 nextljl 的继续往后匹配\n任何模式串都一样，第一个字符不匹配时，只能匹配下一个子串，因此，往后余生，next［1］都无脑写0 任何模式串都一样，第2个字符不匹配时，应尝试匹配模式串的第1个字符，因此，往后余生，next［2］都无脑写1 在不匹配的位置前边，划一根美丽的分界线，模式串一步一步往后退，直到分界线之前“能对上”，或模式串完全跨过分界线为止，此时j指向哪儿，next数组值就是多少 KMP算法\u0026mdash;-进一步优化 树和二叉树 树的定义与基本术语 树的基本概念 非空树的特性： 有且仅有一个根节点 没有后继的结点称为“叶子结点”（或终端结点） 有后继的结点称为“分支结点”（或非终端结点） 除了根节点外，任何一个结点都有且仅有一个前驱 每个结点可以有0个或多个后继。 除了根节点外，任何一个结点都有且仅有一个前驱 树是n(n\u0026gt;=0)个结点的有限集合，n=0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足： 1）有且仅有一个特定的称为根的结点。 2）当n\u0026gt;1时，其余结点可分为m(m\u0026gt;0)个互不相交的有限集合T1，T2\u0026hellip;\u0026hellip;Tm，其中每个集合本身又是一棵树，并且称为根结点的子树。 什么是两个结点之间的路径？\u0026mdash;只能从上往下 什么是路径长度？\u0026mdash;经过几条边 属性： 结点的层次(深度)\u0026mdash;-从上往下数 结点的高度\u0026mdash;-从下往上数 树的高度(深度)\u0026mdash;-总共多少层 结点的度\u0026mdash;-有几个孩子（分支） 树的度\u0026mdash;-各结点的度的最大值 有序树V.S无序树 有序树—-逻辑上看，树中结点的各子树从左至右是有次序的，不能互换 无序树—-逻辑上看，树中结点的各子树从左至右是无次序的，可以互换\n树V.S森林 森林。森林是m（m≥0）棵互不相交的树的集合\n树的常考性质 常见考点1：结点数=总度数+1 结点的度—一结点有几个孩子（分支）\n树的度——各结点的度的最大值 m叉树一一每个结点最多只能有m个孩子的树\n度为m的树 m叉树 任意结点的度≤m（最多m个孩子） 任意结点的度≤m（最多m个孩子） 至少有一个结点度=m（有m个孩子） 允许所有结点的度都＜ m 一定是非空树，至少有m+1个结点 可以是空树 常见考点2：度为m的树、m叉树的区别\n常见考点3：度为m的树第i层至多有mi-1个结点（i\u0026gt;=1） m叉树第i层至多有mi-1 个结点（1\u0026gt;=1）\n常见考点4：高度为h的m叉树至多有mh-1/m-1个结点。 等比数列求和公式：a+aq+aq2+\u0026hellip;\u0026hellip;+aqn-1=a(1-qn)/1-q\n常见考点5：高度为h的m叉树至少有h个结点。 高度为h、度为m的树至少有h+m-1个结点。\n常见考点6：具有n个结点的m又树的最小高度为 logm(n(m-1)+1)\n高度最小的情况——所有结点都有m个孩子\n二叉树的定义与基本定语 二叉树的基本概念 二叉树是n(n\u0026gt;=0)个结点的有限集合： ① 或者为空二叉树，即n=0。 ② 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。 特点：①每个结点至多只有两棵子树 ②左右子树不能颠倒（二叉树是有序树） *注意区别：度为2的有序树\n二叉树的五种状态\n1.空二叉树\n2.只有左子树\n3.只有右子树\n4.只有根结点\n5.左右子树都有\n几种特殊的二叉树 满二叉树。一棵高度h，且含有2-1个结点的二叉树\n特点： ①只有最后一层有叶子结点 ②不存在度为1的结点 ③按层序从1开始编号，结点i的左孩子2i，右孩子为2i+1；结点i的父节点为|/2」（如果有的话）\n完全二叉树。当且仅当其每个结点都与高度为h的满二叉树中编号为1～n的结点一一对应时，称为完全二叉树\n特点： ①只有最后两层可能有叶子结点 ②最多只有一个度为1的结点 ③按层序从1开始编号，结点i的左孩子2i，右孩子为2i+1；结点i的父节点为|/2」（如果有的话） ④i\u0026lt;=[n/2]为分支结点，i\u0026gt;[n/2]为叶子结点\n二叉排序树。一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树： 左子树上所有结点的关键字均小于根结点的关键字； 右子树上所有结点的关键字均大于根结点的关键字。 左子树和右子树又各是一棵二叉排序树。 \u0026mdash;-二叉排序树可用于元素的排序、搜索\n平衡二叉树。树上任一结点的左子树和右子树的深度之差不超过1。\n二叉树常考性质 二叉树常考性质 常见考点1：设非空二叉树中度为0、1和2的结点个数分别为n0、n1和n2，则n0=n2+1(叶子结点 比二分支结点多一个)\n证明：假设树中结点总数为n，则 (1)n = n0+ n1+ n2 (2)n = n1+ 2n2+1\u0026mdash;-树的结点数=总度数+1 (1)-(2):n0=n2+1\n常见考点2：二叉树第i层至多有2i-1 个结点（i≥1） m叉树第i层至多有mi-1 个结点（i≥1）\n常见考点3：高度为h的二叉树至多有 2h—1个结点（满二叉树） 高度为h的m叉树至多有mh-1/m-1个结点 等比数列求和公式：a+aq+aq2+\u0026hellip;\u0026hellip;+aqn-1=a(1-qn)/1-q\n完全二叉树常考性质 常见考点1：具有n个（n\u0026gt;0）结点的完全二叉树的高度h为 log2(n+1) 或log2n +1\nlog2(n+1)是怎么来的？\n高为h的满二叉树共有2h-1个结点，\n高h-1的满二叉树共有2h-1—1个结点，\n所以要想高度为h就必须满足：\n2h-1-1 \u0026lt;n≤2h-1 2h-1 \u0026lt; n+1≤2h h - 1 \u0026lt; log2(n+1) ≤ h h = log2(n+ 1)\nlog2n +1是怎么来的？\n高h-1的满二叉树共有2h-1—1个结点，\n所以高为h的二叉树则至少比他多一个结点，\n即至少为2h-1，\n至多为2h-1-1\n常见考点2：对于完全二叉树，可以由的结点数n推出度为0、1和2的结点个数为n0、n1和n2\n完全二叉树最多只有一个度1的结点，即n0=0或1 n0=n2+1 \u0026ndash;\u0026gt; n0+n2一定是奇数\n若完全二叉树有2k个(偶数)个结点，则必有n1=1，n0=k，n2=k-1 若完全二叉树有2k-1个(奇数)个结点，则必有n1=0, n0=k, n2 = k-1\n二叉树的存储结构 二叉树的顺序存储 代码定义 1 2 3 4 5 6 #define MaxSize 100 struct TreeNode { ftemTypeyalue; //结点中的数据元素 bool isEmpty;//结点是否为空 ｝； TreeNode t [MaxSizel; 定义一个长度为 MaxSize 的数组t，按照从上至下、从左至右的顺序依次存储完全二叉树中的各个结点\n注意：可以让第一个位置为空，保证数组下标和结点编号一致\n几个重要常考的基本操作：\ni 的左孩子——2i i 的右孩子——2i+1 i 的父节点——i/2 i 所在的层次——log2(n+1) 或 [log2n ]+1 若完全二叉树中共有n个结点，则（注意，只有完全二叉树才符合这个规则 ） 判断 i 是否有左孩子？——2i ≤ n？ 判断 i 是否有右孩子？——2i+1 ≤ n? 判断 i 是否是叶子/分支结点？ ——i\u0026gt;[n/2]？ 如果不是完全二叉树怎么办？\n二叉树的顺序存储中，一定要把二叉树的结点编号与完全二叉树对应起来\n结论：二叉树的顺序存储结构，只适合存储完全二叉树\n二叉树的链式存储 代码定义\n1 2 3 4 5 //二叉树的结点（链式存储） typedef struct BiTNode{ ElemType data: //数据域 struct BiNode *child, *rchild;//左、右孩子指针 }BiTNode *BiTree: 线索二叉树\n若有n个结点，则有2n个指针，除了跟结点，每一个结点上面一定会有一个指针指向他，共有n-1个，所以有n+1个空的指针域，可以利用这些空间构造线索二叉树\n二叉树的构建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct ElemType{ int value; }; typedef struct BiTNode{ ElemType data; struct BiNode *lchild,*rchild; }BiT Node,*BiTree; //定义一棵空树 BiTree root = NULL; //插入根节点 root = (BiTree)malloc(sizeof(BiTNode)); root-\u0026gt;data = {1}; root-\u0026gt;lchild = NULL; root-\u0026gt;rchild = NULL; //插入新结点 BiTNode *p = (BiTNode *) malloc(sizeof(BiTNode)); p-\u0026gt;data = {2}; p-\u0026gt;lchild = NULL; p-\u0026gt;rchild = NULL; root-\u0026gt;lchild=p;v//作为根节点的左孩子 三叉链表 可以增加一个父结点指针以方便找父结点 二叉树的先中后序遍历 先序遍历：根左右（NLR）\n代码实现\n先序遍历（PreOrder）的操作过程如下：\n若二叉树空，则什么也不做； 若二叉树非空： ①访问根结点； ②先序遍历左子树； ③先序遍历右子树。 1 2 3 4 5 6 7 void PreOrder(BiTree T){ if (T!=NULL){ visit(T); PreOrder (T-\u0026gt;lchild); PreOrder (T-\u0026gt;rchild); } } 中序遍历：左根右（LNR）\n代码实现\n中序遍历（InOrder）的操作过程如下：\n若二叉树为空，则什么也不做； 若二叉树非空： ①先序遍历左子树； ②访问根结点； ③先序遍历右子树。 1 2 3 4 5 6 7 void InOrder(BiTree T){ if (T!=NULL){ PreOrder (T-\u0026gt;lchild); visit(T); PreOrder (T-\u0026gt;rchild); } } 后序遍历：左右根（LRN）\n后序遍历（InOrder）的操作过程如下：\n若二叉树为空，则什么也不做； 若二叉树非空： ①先序遍历左子树； ⑨先序遍历右子树； ③访问根结点。 先序遍历 前缀表达式 中序遍历 中缀表达式（需要加界限符） 后序遍历 后缀表达式\n脑补空结点，从根节点出发，画一条路： 如果左边还有没走的路，优先往左边走走到路的尽头（空结点）就往回走 如果左边没路了，就往右边走 如果左、右都没路了，则往上面走，经过三次时访问该结点\n例：求树的深度\n1 2 3 4 5 6 7 8 9 10 11 int treeDepth(BiTree T){ if (T == NULL) { return 0; } else { int l = treeDepth(T-\u0026gt;child); int r = treeDepth(T-\u0026gt;rchild); //树的深度=Max（左子树深度，右子树深度）+1 return l\u0026gt;r ? l+1 : r+1； ｝ } 二叉树的层次遍历 算法思想： 1.初始化一个辅助队列 2.根结点入队 3.若队列非空，则队头结点出队，访问该结点：并将其左、右孩子插入队尾（如果有的话） 4.重复3直至队列为空 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //层序遍历 void LevelOrder(BiTree D){ LinkQueue Q; InitQueue (Q);//初始化辅助队列 BiTree p; EnQueue (Q,T);//将根结点入队 while(!IsEmpty(Q)){//队列不空则循环 DeQueue（Q,p）；//队头结点出队 visit(p);//访问出队结点 if(p-\u0026gt;|child!=NULL) EnQueue(Q,P-\u0026gt;lchild);//左孩子入队 if(p-\u0026gt;rchild!=NULL) EnQueue(Q, p-\u0026gt;rchild);//右孩子入队 } } 由遍历序列来构造二叉树 若只给出一棵二叉树的前/中/后/层序遍历序列中的一种，不能唯一确定一棵二叉树\n前序＋中序遍历序列 前序遍历：根结点、前序遍历左子树、前序遍历右子树 中序遍历：中序遍历左子树、根结点、中序遍历右子树\n后序＋中序遍历序列\n逻辑与前序+中序类似\n层序＋中序遍历序列 线索二叉树的概念 二叉树存在的一些问题\n不能从一个指定结点开始中序遍历 找到前驱和后继比较麻烦 思路： 从根节点出发，重新进行一次中序 遍历，指针q记录当前访问的结点，指针 pre 记录上一个被访问的结点 ①当q=p时，pre为p的前驱 ②当pre=p时，q为p的后继 引入线索二叉树\n因为n个结点的二叉树会存在n+1个空链域，所以可以利用这些空间存储二叉树的前驱和后继\n代码定义\n1 2 3 4 5 6 //线索二叉树结点 typedef struct ThreadNode{ ElemType data； struct ThreadNode *lchild,*rchild; int ltag, rtag;//左、右线索标志,tag==0表示指向的是孩子，tag==1表示指向的是线索 }ThreadNode, *ThreadTree; 二叉树的线索化 \u0026ldquo;土方法\u0026quot;找中序前驱\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void FindPre(BiTree T){ if(T!=NULL){ InOrder (T-\u0026gt;l child);//递归遍历左子树 visit (T);//访问根结点 InOrder (T-\u0026gt;rchild);//递归遍历右子树 } } void visit(BiTNode * q){ if (q==p)//当前访问结点刚好是结点人展 final = pre;//找到p的前驱 else pre = q;//pre指向当前访问的结点 } //辅助全局变量，用于查找结点p的前驱 BiTNode *p;//p指向目标结点 Biz[Node * pre=NULL;//指向当前访问结点的前驱 BiTNode * final=NULL;//用于记录最终结果 中序线索化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //线索二叉树结点 typedef struct ThreadNode{ ElemType data; struct ThreadNode *lchild,*rchild; int ltag,rtag;//左、右线索标志 }ThreadNode, *ThreadTree; //中序遍历二叉树，一边遍历一边线索化 void InThread(ThreadTree T){ if(T!=NULL){ InThread(T-\u0026gt;lchild)；//中序遍历左子树 visit(T);//访问根节点 InThread (T-\u0026gt;rchild);//中序遍历右子树 } } void visit(ThreadNode *q){ if(q-\u0026gt;lchild==NULL){//左子树为空，建立前驱线索 q-\u0026gt;lchild=pre; q-\u0026gt;ltag=1; } if(pre!=NULL\u0026amp;\u0026amp;pre-\u0026gt;rchild==NULL){ pre-\u0026gt;rchild=q； //建立前驱结点的后继线索 pre-\u0026gt;rtag=1; ｝ pre=q; ｝ //全局变量 pre，指向当前访问结点的前驱 ThreadNode *pre=NULL: 中序线索化（王道教材版）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //中序线索化 void InThread (ThreadTree p, ThreadTree \u0026amp;pre){ if(p!=NULL){ InThread (p-\u0026gt;lchild, pre);//递归，线索化左子树 if(p-\u0026gt;lchild==NULL){//左子树为空，建立前驱线索 p-\u0026gt;lchild=pre; p-\u0026gt;ltag=1; } if(pre!=NULL\u0026amp;\u0026amp;pre-\u0026gt;rchild==NULL){ pre-\u0026gt;rchild=p;//建立前驱结点的后继线索 pre-\u0026gt;rtag=1; } pre=p; InThread (p-\u0026gt;rchild, pre) ; }//if(p!=NULL) } //中序线索化二叉树T void CreateInThread(ThreadTree T){ ThreadTree pre=NULL; if(T!=NULL){ InThread(T,pre);//非空二叉树，线索化 pre-\u0026gt;rchild=NULL；//线索化二叉树 pre-\u0026gt;rtag=1;//处理遍历的最后一个结点 } } 思考：处理遍历的最后一个结点时，为什么没有判断 rchild 是否为NULL？ 答：中序遍历的最后一个结点右孩子指针必为空。\n先序线索化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 //全局变量 pre，指向当前访问结点的前驱 ThreadNode *pre=NULL; //先序线索化二叉树T void CreatePreThread (ThreadTree T){ pre=NULL;//pre初始为NULL if(T!=NULL){//非空二叉树才能线索化 PreThread (T) ;//先序线索化二叉树 if (pre-\u0026gt;rchild==NULL) pre-\u0026gt;rtag=1;//处理遍历的最后一个结点 } //先序遍历二叉树，一边遍历一边线索化 void PreThread(ThreadTree T){ if(T!=NULL){ visit(T);//先处理根节点 if(T-\u0026gt;Ltag==0)//lchild不是前驱线索 PreThread(T-\u0026gt;|child); PreThread(T-\u0026gt;rchild); } } void visit(ThreadNode *q){ if(q-\u0026gt;Lchild==NULL){//左子树为空，建立前驱线索 q-\u0026gt;Lchild=pre; q-\u0026gt;ltag=1; } if(pre!=NULL\u0026amp;\u0026amp;pre-\u0026gt;rchild==NULL){ pre-\u0026gt;rchild=q； //建立前驱结点的后继线索 pre-\u0026gt;rtag=1; } pre=q; } 后序线索化\n在线索二叉树中找前驱后继 中序线索二叉树找中序后继 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //找到以P为根的子树中，第一个被中序遍历的结点 ThreadNode *Firstnode (ThreadNode *p){ //循环找到最左下结点（不一定是叶结点） while(p-\u0026gt;Ltag==0) p=p-\u0026gt;lchild; return p; } //在中序线索二叉树中找到结点p的后继结点 ThreadNode *Nextnode(ThreadNode *p){ //右子树中最左下结点 if(p-\u0026gt;rtag==0) return Firstnode(p-\u0026gt;rchild); else return p-\u0026gt;rchild;//ctag==1直接返回后继线索 } //对中序线索二叉树进行中序遍历（利用线索实现的非递归算法） void Inorder(ThreadNode *T){ for(ThreadNode *p=Firstnode(T);p!=NULL;p=Nextnode(p)) visit (p); } 中序线索二叉树找中序前驱 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //找到以P为根的子树中，最后一个被中序遍历的结点 ThreadNode *Lastnode (ThreadNode *p){ //循环找到最右下结点（不一定是叶结点） while (p-\u0026gt;rtag==0) p=p-\u0026gt;rchild; return p; ｝ //在中序线索二叉树中找到结点p的前驱结点 ThreadNode *Prenode (ThreadNode *p){ //左子树中最右下结点 if(p-\u0026gt;ltag==0) return Lastnode(p-\u0026gt;lchild); else return p-\u0026gt;lchild; //ltag==1直接返回前驱线索 ｝ //对中序线索二叉树进行逆向中序遍历 void RevInorder(ThreadNode *T){ for (ThreadNode *p=Lastnode(T);p!=NULL; p=Prenode(p)) visit(p); } 树的存储结构 树的逻辑结构 树是n(n\u0026gt;=0)个结点的有限集合，n=0时，称空树，这是一种特殊情况。在任意一棵非空树中应满足： 1）有且仅有一个特定的称次根的结点。 2）当n\u0026gt;1时，其余结点可分为m（m\u0026gt;0）个互不相交的有限集合T1，T2…，Tm，其中每个集合本身又是一棵树，并且称为根结点的子树。 树是一种递归定义的数据结构 如何实现树的顺序存储 思路：用数组顺序存储各个结点。每个结点中保存数据元素、指向双亲结点（父节点）的“指针”\n树的存储1:双亲表示法\n1 2 3 4 5 6 7 8 9 #define MAX_TREE_SIZE 100//树中最多结点数 typedef struct{//树的结点定义 ElemType data;//数据元素 int parent;//双亲位置域 }PTNode: typedef struct{//树的类型定义 PTNode nodes[MAX_TREE_SIZE];//双亲表示 int n;//结点数 }PTree; 优点：找双亲（父节点）很方便 缺点：找孩子不方便，只能从头到尾遍历整个数组\n适用于“找父亲”多，“找孩子”少的应用场景。如：并查集\n树的存储2：孩子表示法\n孩子表示法：用数组顺序存储各个结点。每个结点中保存数据元素、孩子链表头指针\n1 2 3 4 5 6 7 8 9 10 11 12 struct CTNode{ int child; //孩子结点在数组中的位置、 struct CTNode *next;//下一个孩子 }; typedef struct{ ElemType data; struct CTNode *firstChild; //第一个孩子 }СТВох; typedef struct { СТBох nodes [MAX_TREE_SIZE]; int n,r;//结点数和根的位置 } CTree; 孩子表示法存储“森林”\n孩子表示法的优缺点\n优点：找孩子很方便 缺点：找双亲（父节点）不方便，只能遍历每个链表\n树的存储3：孩子兄弟表示法\n1 2 3 4 5 //树的存储：孩子兄弟表示法 typedef struct CSNode{ ElemType data; struct CSNode *firstchild,*nextsibling; }CSNode, *CSTree; 树的孩子兄弟表示法，与二叉树类似，采用二叉链表实现每个结点内保存数据元素和两个指针，但两个指针的含义与二叉树结点不同\n1 2 3 4 5 //二叉树的结点（链式存储） typedef struct BiTNode{ ElemType data; struct BiTNode *lchild,*rchild; }BiTNode, *BiTree; 当使用“孩子兄弟表示法”存储树或森林时，从存储视角来看形态上与二叉树类似，如下图：\n树、森林与二叉树的转换 树-\u0026gt;二叉树的转换 树-二叉树 转换技巧： ①先在二叉树中，画一个根节点。 ②按“树的层序”依次处理每个结点。\n处理一个结点的方法是：如果当前处理的结点在树中有孩子，就把所有孩子结点“用右指针串成糖葫芦”，并在二叉树中把第一个孩子挂在当前结点的左指针下方\n森林-\u0026gt;二叉树的转换 注意：森林中各棵树的根节点视为平级的兄弟关系\n森林-\u0026gt;二叉树转换技巧： ①先把所有树的根结点画出来，在二叉树中用右指针串成糖葫芦。 ②按“森林的层序”依次处理每个结点。 处理一个结点的方法是：如果当前处理的结点在树中有孩子，就把所有孩子结点“用右指针串成糖葫芦”，并在二叉树中把第一个孩子挂在当前结点的左指针下方\n二叉树-\u0026gt;树的转换 二叉树-\u0026gt;树的转换技巧： ①先画出树的根节点 ②从树的根节点开始，按“树的层序”恢复每个结点的孩子 如何恢复一个结点的孩子：在二叉树中，如果当前处理的结点有左孩子，就把左孩子和“一整串右指针糖葫芦”拆下来，按顺序挂在当前结点的下方\n二叉树-\u0026gt;森林的转换 二叉树-\u0026gt;森林的转换技巧： ①先把二叉树的根节点和“一整串右指针糖葫芦”拆下来，作多棵树的根节点 ②按“森林的层序”恢复每个结点的孩子 如何恢复一个结点的孩子：在二叉树中，如果当前处理的结点有左孩子，就把左孩子和“一整串右指针糖葫芦”拆下来，按顺序挂在当前结点的下方\n树、森林的遍历 树的先根遍历和后根遍历 （1）先根遍历。若树非空，先访问根结点，再依次对每棵子树进行先根遍历。（深度优先遍历）\n伪代码如下（具体代码实现需要根据具体树的存储结构编写）：\n1 2 3 4 5 6 7 8 //树的先根遍历 void PreOrder (TreeNode *R){ if(R!=NULL){ visit(R);//访问根节点 while(R还有下一个子树T) PreOrder(T);//先根遍历下一棵子树 } } （2）后根遍历。若树非空，先依次对每棵子树进行后根遍历，最后再访问根结点。（深度优先遍历）\n伪代码如下（具体代码实现需要根据具体树的存储结构编写）：\n1 2 3 4 5 6 7 8 //树的后根遍历 void PostOrder(TreeNode *R){ if(R!=NULL){ while(R还有下一个子树T) PostOrder(T);//后根遍历下一棵子树 visit(R);//访问根节点 } } 树的层次遍历 （3）层次遍历（用队列实现）（广度优先遍历） ①若树非空，则根节点入队 ②若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队 ③重复②直到队列为空\n森林的先序遍历、中序遍历 1） 先序遍历森林。 若森林非空，则按如下规则进行遍历： 访问森林中第一棵树的根结点。 先序遍历第一棵树中根结点的子树森林。 先序遍历除去第一棵树之后剩余的树构成的森林。\n（效果等于先序遍历每个树）\n2） 中序遍历森林。 若森林为非空，则按如下规则进行遍历： 中序遍历森林中第一棵树的根结点的子树森林。 访问第一棵树的根结点。 中序遍历除去第一棵树之后剩余的树构成的森林。\n哈夫曼树 带权路径长度 结点的权：有某种现实含义的数值（如：表示结点的重要性等） 结点的带权路径长度：从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积 树的带权路径长度：树中所有叶结点的带权路径长度之和（WPL, Weighted Path Length）\n哈夫曼树的定义 在含有n个带权叶结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称哈夫曼树，也称最优二叉树\n哈夫曼树的构造 给定n个权值分别为w1，w2…，wn的结点，构造哈夫曼树的算法描述如下： 1）将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。 2）构造一个新结点，从F中选取两棵根结点权值最小的树作新结点的左、右子树，并且将新结点的权值置左、右子树上根结点的权值之和。 3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中。 4）重复步骤2）和3），直至F中只剩下一棵树为止。\n最后： 1）每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大 2）哈夫曼树的结点总数为2n-1 3）哈夫曼树中不存在度1的结点。 4）哈夫曼树并不唯一，但WPL必然相同且为最优\n哈夫曼编码 Eg：\nA\u0026ndash;00\nB\u0026ndash;01\nC\u0026ndash;10\nD\u0026ndash;11\n假设，100题中有80题选C，10题选A，8题选B，2题选D,所有答案的二进制长度=80*2+10*2+8*2+2*2=200bit\n因为选C的概率大，所以我们可以把哈夫曼编码改良为：\nC\u0026ndash;0\nA\u0026ndash;10\nB-111\nD-110\n这是一种可变长度编码—一允许对不同字符用不等长的二进制位表示\n但是，如果改为：\nC\u0026ndash;0\nA\u0026ndash;1\nB\u0026ndash;111\nD\u0026ndash;110\n这样是不对的，因为会导致歧义，究其根本原因是字符A没有作为叶子结点\n固定长度编码一一每个字符用相等长度的二进制位表示\n可变长度编码—一允许对不同字符用不等长的二进制位表示\n若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码 有哈夫曼树得到哈夫曼编码——字符集中的每个字符作为一个叶子结点，各个字符出现的频度作为结点的权值，根据之前介绍的方法构造哈夫曼树\n图 图的基本概念 图的定义 图G（Graph）由顶点集V（Vertex）和边集E（Edge）组成，记为G=（V,E），其中V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系（边）集合。若V={v1，v2..， vn}，则用|V|表示图G中顶点的个数，也称图G的阶，E={u,v)| u∈V,v∈V}，用|E|表示图G中边的条数。 注意：线性表可以是空表，树可以是空树，但图不可以是空，即V一定是非空集\n无向图、有向图 若E是无向边（简称边）的有限集合时，则图G为无向图。边是顶点的无序对，记为（v,w）或（w, v），因为（v,w）=（w, v），其中v、w是顶点。可以说顶点w和顶点v互为邻接点。边（v,w）依附于顶点w和v，或者说边（v,w）和顶点 、w相关联。 若E是有向边（也称弧）的有限集合时，则图G为有向图。弧是顶点的有序对，记为\u0026lt;v，w\u0026gt;，其中v、w是顶点，v称为弧尾，w称为弧头，\u0026lt;v，w\u0026gt;称为从顶点到顶点w的弧，也称v邻接到w，或w邻接自v。\u0026lt;v,w\u0026gt;≠\u0026lt;w,v\u0026gt; 简单图、多重图 简单图——① 不存在重复边； ② 不存在顶点到自身的边 多重图——图G中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联，则G为多重图 顶点的度、入度、出度 对于无向图：顶点v的度是指依附于该顶点的边的条数，记为 TD(v)。 在具有n个顶点、e条边的无向图中，∑i=1nTD(vi)=2e 即无向图的全部顶点的度的和等于边数的2倍 对于有向图： 入度是以顶点v为终点的有向边的数目，记为ID(v)； 出度是以顶点v为起点的有向边的数目，记为OD(v)。 顶点v的度等于其入度和出度之和，即TD（v）=ID（V）+ OD（w）。 顶点-顶点的关系描述 路径一一顶点vp到顶点vq之间的一条路径是指顶点序列\u0026mdash;\u0026ndash;vp,vi1\u0026hellip;\u0026hellip;vim,vq 回路一一第一个顶点和最后一个顶点相同的路径称为回路或环 简单路径一一在路径序列中，顶点不重复出现的路径称为简单路径。 简单回路—-除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。 路径长度一一路径上边的数目 点到点的距离一一从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到v的距离。 若从u到v根本不存在路径，则记该距离为无穷（∞）。 无向图中，若从顶点v到顶点w有路径存在，则称v和w是连通的 有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的 连通图、强连通图 若图G中任意两个顶点都是连通的，则称图G 连通图，否则称为非连通图。\n常见考点： 对于n个顶点的无向图G， 若G是连通图，则最少有n-1条边 若G是非连通图，则最多可能有C-1条边\n","date":"2024-11-12T20:43:19+08:00","permalink":"http://localhost:1313/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E7%8E%8B%E9%81%93%E7%BD%91%E8%AF%BE/","title":"数据结构---王道网课"},{"content":"第1章 绪论 考纲内容 算法时间复杂度和空间复杂度的分析与计算 复习提示 本章内容是数据结构概述，并不在考研大纲中。读者可通过对本章的学习，初步了解数据结构的基本内容和基本方法。分析算法的时间复杂度和空间复杂度是本章重点，需要熟练掌握，算法设计题通常都会要求分析时间复杂度、空间复杂度，同时会出现考查时间复杂度的选择题。 ","date":"2024-11-12T20:43:19+08:00","permalink":"http://localhost:1313/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E7%8E%8B%E9%81%93%E4%B9%A6/","title":"数据结构--王道书"},{"content":"简单的HTML语法 1.简单的 HTML 页面架构 2. HTML 常见标签 2.1. meta 标签 \u0026lt;meta\u0026gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎 和更新频度的描述和关键词。\n设置网站关键字 \u0026lt;meta name=\u0026ldquo;keywords\u0026rdquo; content=\u0026ldquo;网络安全，WEB 渗透，数据安全，渗透测试， 安全培训\u0026rdquo; /\u0026gt;\n2.1.1\u0026lt;link\u0026gt;\u0026mdash;-标签定义文档与外部资源的关系。 \u0026lt;link\u0026gt; 标签用于在 HTML 文档中引入外部资源，通常用于链接样式表（CSS），设置网站图标，或者定义其他与文档相关的信息。它是一个自闭合标签。\n\u0026mdash;-基本语法\u0026mdash;- \u0026lt;link rel=\u0026ldquo;关系类型\u0026rdquo; href=\u0026ldquo;资源路径\u0026rdquo; 属性=\u0026ldquo;值\u0026rdquo;\u0026gt;\n\u0026mdash;-常见用法\u0026mdash;-\n引入外部样式表（CSS） 这是\u0026lt;link\u0026gt; 最常见的用途，用于将 CSS 文件引入 HTML 文档。\n\u0026lt;link rel=\u0026ldquo;stylesheet\u0026rdquo; href=\u0026ldquo;styles.css\u0026rdquo;\u0026gt;\n•\trel=\u0026quot;stylesheet\u0026quot;：指定链接的是一个样式表。 •\thref=\u0026quot;styles.css\u0026quot;：指定样式表的路径。 设置网站图标（Favicon） 通过 \u0026lt;link\u0026gt; 定义网站的图标。\n\u0026lt;link rel=\u0026ldquo;icon\u0026rdquo; href=\u0026ldquo;favicon.ico\u0026rdquo; type=\u0026ldquo;image/x-icon\u0026rdquo;\u0026gt;\n•\trel=\u0026quot;icon\u0026quot;：指定这是一个图标。 •\ttype=\u0026quot;image/x-icon\u0026quot;：图标的文件类型。 •\thref=\u0026quot;favicon.ico\u0026quot;：图标文件的路径。 定义预加载资源 可以通过 \u0026lt;link\u0026gt; 提前加载关键资源以提升页面性能。\n\u0026lt;link rel=\u0026ldquo;preload\u0026rdquo; href=\u0026ldquo;font.woff2\u0026rdquo; as=\u0026ldquo;font\u0026rdquo; type=\u0026ldquo;font/woff2\u0026rdquo; crossorigin=\u0026ldquo;anonymous\u0026rdquo;\u0026gt;\n•\trel=\u0026quot;preload\u0026quot;：提前加载资源。 •\tas=\u0026quot;font\u0026quot;：指定资源的类型。 •\tcrossorigin：如果资源需要跨域加载，需要添加此属性。 引入其他文档类型 例如，引入一个 RSS 订阅文件。\n\u0026lt;link rel=\u0026ldquo;alternate\u0026rdquo; type=\u0026ldquo;application/rss+xml\u0026rdquo; title=\u0026ldquo;RSS\u0026rdquo; href=\u0026ldquo;feed.xml\u0026rdquo;\u0026gt;\n引用网站的规范 URL 用于避免重复内容问题，定义此页面的标准 URL。\n\u0026lt;link rel=\u0026ldquo;canonical\u0026rdquo; href=\u0026ldquo;https://www.example.com/page\"\u003e\n放置位置\u0026mdash;-必须放在 \u0026lt;head\u0026gt; 标签内，通常作为元信息的一部分。\n6.示例代码\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026ldquo;en\u0026rdquo;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026ldquo;UTF-8\u0026rdquo;\u0026gt; \u0026lt;meta name=\u0026ldquo;viewport\u0026rdquo; content=\u0026ldquo;width=device-width, initial-scale=1.0\u0026rdquo;\u0026gt; \u0026lt;title\u0026gt;示例页面\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026ldquo;stylesheet\u0026rdquo; href=\u0026ldquo;styles.css\u0026rdquo;\u0026gt; \u0026lt;link rel=\u0026ldquo;icon\u0026rdquo; href=\u0026ldquo;favicon.ico\u0026rdquo;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;欢迎访问！\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;\n注意事项\n1.\t自闭合：\u0026lt;link\u0026gt; 是自闭合标签，不需要 \u0026lt;/link\u0026gt;。 2.\t文件路径：确保 href 路径正确，支持绝对路径和相对路径。 3.\t缓存问题：更新样式文件时，可在 href 中加版本号，如 styles.css?v=1.1。 2.1.2\u0026lt;script\u0026gt; 引入 js 文件 \u0026lt;script\u0026gt; 标签用于在 HTML 文档中嵌入或引用 JavaScript 脚本。它可以用来实现交互、操作 DOM、动态更新内容等功能。\n基本语法\n\u0026lt;script 属性=\u0026ldquo;值\u0026rdquo;\u0026gt;JavaScript代码\n用法\n引入外部 JavaScript 文件 通过 src 属性引用外部的 JavaScript 文件。\n•\tsrc：指定 JavaScript 文件的路径。 •\t文件路径可以是相对路径或绝对路径。 内联 JavaScript 直接在 异步加载脚本（async 属性） 当脚本不依赖于页面的其他内容，可以通过 async 属性异步加载，提高页面加载速度。\n•\t异步加载：脚本加载完成后立即执行，不等待其他内容加载完成。 延迟加载脚本（defer 属性） 使用 defer 属性，脚本会在 HTML 解析完成后执行（但在 DOMContentLoaded 事件之前）。\n•\t延迟加载：保证脚本的执行顺序与页面结构一致。 指定脚本类型（type 属性） 通常默认是 text/javascript，但可以用于其他脚本\n注释 :\u0026lt;!\u0026ndash;这是一段注释。注释不会在浏览器中显示。\u0026ndash;\u0026gt; \u0026lt;p\u0026gt;这是一段普通的段落。\u0026lt;/p\u0026gt; 2.2. 标题标签 由大到小 原代码： \u0026lt;h1\u0026gt;h1\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;h2\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;h3\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;h4\u0026lt;/h4\u0026gt; \u0026lt;h5\u0026gt;h5\u0026lt;/h5\u0026gt; \u0026lt;h6\u0026gt;h6\u0026lt;/h6\u0026gt; 实际效果： h1 h2 h3 h4 h5 h6 换行线标签 \u0026lt;br\u0026gt; 换行标签\u0026mdash;直接放在\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;之中即可，无需闭合为\u0026lt;br /\u0026gt; 2.3. 文本属性 \u0026lt;strong\u0026gt;加粗\u0026lt;/strong\u0026gt;\n\u0026lt;b\u0026gt;\u0026lt;/b\u0026gt;加粗\n\u0026lt;i\u0026gt;\u0026lt;/i\u0026gt;斜体\n\u0026lt;u\u0026gt;\u0026lt;/u\u0026gt;下划线\n\u0026lt;sup\u0026gt;\u0026lt;/sup\u0026gt;上标\n\u0026lt;sub\u0026gt;\u0026lt;/sub\u0026gt;下标\n\u0026lt;del\u0026gt;\u0026lt;/del\u0026gt; 删除线\n\u0026lt;font\u0026gt;\u0026lt;/font\u0026gt; 规定字体属性:size 字体的大小 color 字体颜色 face规定字体\nEg：\u0026lt;font size=\u0026ldquo;4\u0026rdquo; color=\u0026ldquo;blue\u0026rdquo; face=\u0026ldquo;Arial\u0026rdquo;\u0026gt;这是蓝色的 Arial 字体文字\u0026lt;/font\u0026gt;\n注：一般不建议使用\u0026lt;font\u0026gt;，可以直接使用现代化的CSS来控制文本样式\n代码样式原样输出\u0026lt;pre\u0026gt;\u0026lt;/pre\u0026gt;\n2.4. form 表单 **form表单: 规定当提交表单时向何处发送表单数据 **\nmethod 提交的方法有get、post规定在发送表单数据之前如何对其进行编码。\nenctype属性可能的值\n​ application/x-www-form-urlencoded\u0026mdash;\u0026mdash;\u0026mdash;-默认值 ​ multipart form-data\u0026mdash;\u0026mdash;\u0026mdash;-使用文件上传标签需要使用这个值！！！ ​ text/plain\u0026mdash;\u0026mdash;\u0026mdash;表单数据将以纯文本格式发送（不常用）\ninput 标签 name：同样是表示的该文本输入框名称。\nsize：输入框的长度大小。\nmaxlength：输入框中允许输入字符的最大数。\nvalue：输入框中的默认值\nreadonly：表示该框中只能显示，不能添加修改。\ninput 的类型\ntype=password 密码输入框 type=file文件上传 type=hidden隐藏域 button按钮 checkbox复选框 radio单选框 type=submit提交按钮 type=reset重置按钮\n2.5. a 标签、img 标签、table 标签 a 标签的作用 a 标签的作用就是用于控制界面与页面之间的跳转 默认就是 self\nself：用于在当前选项卡中跳转，也就是不新建页面跳转 _blank ：用于在新的选项卡中跳转，也就是新建页面跳转 Eg: \u0026lt;a href=\u0026ldquo;http://www.baidu.com\u0026rdquo; target=\u0026ldquo;self\u0026rdquo;\u0026gt;百度\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026ldquo;http://www.baidu.com\u0026rdquo; target=\u0026quot;_blank\u0026rdquo;\u0026gt;百度\u0026lt;/a\u0026gt; _blank 在新窗口中打开被链接文档。 _self 默认。在相同的框架中打开被链接文档。 _parent 在父框架集中打开被链接文档。 _top 在整个窗口中打开被链接文档。 2.6. 锚文本 1.基本语法\n\u0026lt;a href=\u0026quot;#2\u0026quot;\u0026gt;锚点\u0026lt;/a\u0026gt;\n(1) 跳转到外部网页\n(2) 跳转到页面的某个位置\na.设置目标锚点\n使用 id 为目标元素标记位置：\n\u0026lt;h2 id=\u0026ldquo;section1\u0026rdquo;\u0026gt;这是目标位置\u0026lt;/h2\u0026gt;\nb.创建锚文本链接\n\u0026lt;a href=\u0026quot;#section1\u0026quot;\u0026gt;跳转到目标位置\u0026lt;/a\u0026gt;\n点击后页面会滚动到 id=\u0026ldquo;section1\u0026rdquo; 的位置\n(3) 打开本地文件或资源\n\u0026lt;a href=\u0026ldquo;files/document.pdf\u0026rdquo;\u0026gt;下载 PDF 文档\u0026lt;/a\u0026gt;\n点击后会打开或下载 document.pdf 文件，前提是文件路径正确。\n(4)发送邮件\n使用 mailto: 协议打开用户默认的邮件客户端：\n\u0026lt;a href=\u0026ldquo;mailto:example@example.com\u0026rdquo;\u0026gt;发送邮件\u0026lt;/a\u0026gt;\n点击后会打开邮件客户端并准备发送邮件。\n(5)拨打电话\n使用 tel: 协议实现点击拨号功能（通常用于移动设备）：\n\u0026lt;a href=\u0026ldquo;tel:+1234567890\u0026rdquo;\u0026gt;拨打电话\u0026lt;/a\u0026gt;\n点击后会启动拨号应用。\n添加属性扩展功能 （1）在新窗口打开链接\n通过 target=\u0026quot;_blank\u0026quot; 属性设置链接在新窗口或新标签页中打开：\n\u0026lt;a href=\u0026ldquo;https://www.example.com\u0026rdquo; target=\u0026quot;_blank\u0026quot;\u0026gt;访问 Example 网站\u0026lt;/a\u0026gt;\n（2）添加提示信息\n使用 title 属性提供鼠标悬停时的提示：\n\u0026lt;a href=\u0026ldquo;https://www.example.com\u0026rdquo; title=\u0026ldquo;点击访问 Example 网站\u0026rdquo;\u0026gt;访问 Example 网站\u0026lt;/a\u0026gt;\n（3）设置链接样式\n结合 CSS，改变锚文本的外观：\n\u0026lt;a href=\u0026ldquo;https://www.example.com\u0026rdquo; style=\u0026ldquo;color: red; text-decoration: none;\u0026quot;\u0026gt;访问 Example 网站\u0026lt;/a\u0026gt;\n（4）下载文件\n通过 download 属性提示浏览器下载文件而不是直接打开：\n\u0026lt;a href=\u0026ldquo;files/document.pdf\u0026rdquo; download\u0026gt;下载 PDF 文档\u0026lt;/a\u0026gt;\n\u0026lt;a name=\u0026ldquo;2\u0026rdquo;\u0026gt;锚点\u0026lt;/a\u0026gt;\n2.7. img 标签 img 元素向网页中嵌入一幅图像。 \u0026lt;img src=\u0026rdquo;../../../../../../../i/eg_tulip.jpg\u0026quot; alt=\u0026ldquo;上海鲜花港 - 郁金香\u0026rdquo; /\u0026gt;\nsrc：图片的来源（路径）。 这是必需属性，指向图片的 URL 或文件路径。 alt：图片的替代文本。 如果图片无法加载或被禁用，替代文本会显示在页面上，且对搜索引擎和无障碍工具（如屏幕阅读器）非常重要。 width 规定图片的高度 height 规定图片的宽度 2.8. table 表格 基本结构 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;列1\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;列2\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;列3\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;数据1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;数据2\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;数据3\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;table\u0026gt;：定义表格的容器。 \u0026lt;tr\u0026gt;：定义表格中的一行（row） \u0026lt;th\u0026gt;：定义表头单元格（通常加粗显示）。 \u0026lt;td\u0026gt;：定义表格中的普通单元格。\n显示效果 列1 列2 列3 数据1 数据2 数据3 **表格的标题** \u0026lt;caption\u0026gt;我的标题\u0026lt;/caption\u0026gt;\n表格属性\n1.border：设置表格边框宽度。\n2.cellpadding：设置单元格内边距。\n3.cellspacing：设置单元格间距。\n4.width 和 height：设置表格宽高。\n5.align：设置表格对齐方式（不推荐，建议用 CSS）。\n表格样式\u0026mdash;推荐用CSS\n可以通过 CSS 自定义表格样式，例如\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;style\u0026gt; table { border-collapse: collapse; /* 合并边框 */ width: 100%; } th, td { border: 1px solid black; text-align: center; /* 居中对齐 */ padding: 10px; /* 内边距 */ } th { background-color: #f2f2f2; /* 设置表头背景色 */ } \u0026lt;/style\u0026gt; 合并单元格\n行合并：使用 rowspan 属性。\n示例代码 1 2 3 4 5 6 7 8 9 \u0026lt;table border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th rowspan=\u0026#34;2\u0026#34;\u0026gt;合并两行\u0026lt;/th\u0026gt; \u0026lt;td\u0026gt;数据1\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;数据2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 合并两行 数据1 数据2 列合并：使用 colspan 属性。\n示例代码\n1 2 3 4 5 6 7 8 9 \u0026lt;table border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th colspan=\u0026#34;2\u0026#34;\u0026gt;合并两列\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;数据1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;数据2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 合并两列 数据1 数据2 2.9 列表标签 HTML 提供两种主要的列表形式：无序列表和有序列表，以及一种常用的描述列表。\n1. 无序列表 \u0026lt;ul\u0026gt;\n定义：无序列表用\u0026lt;ul\u0026gt; 表示，列表项用 \u0026lt;li\u0026gt; 包裹。\n特点：项目符号默认是圆点（disc），可以自定义样式。\ndisc：默认圆点。\ncircle：空心圆。\nsquare：方块。\n基本语法\n1 2 3 4 5 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;项目 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;项目 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;项目 3\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 显示效果\n项目 1 项目 2 项目 3 2. 有序列表 \u0026lt;ol\u0026gt;\n定义：有序列表用 \u0026lt;ol\u0026gt; 表示，列表项用 \u0026lt;li\u0026gt; 包裹。\n特点：项目符号为数字或字母，按顺序排列。\n基本语法\n1 2 3 4 5 \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;项目 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;项目 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;项目 3\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 显示效果\n项目 1 项目 2 项目 3 自定义项目符号类型\n1：默认数字 (1, 2, 3…)。\nA：大写字母 (A, B, C…)。\na：小写字母 (a, b, c…)。\nI：大写罗马数字 (I, II, III…)。\ni：小写罗马数字 (i, ii, iii…)。\n样例\n1 2 3 4 5 6 7 8 \u0026lt;ol type=\u0026#34;A\u0026#34;\u0026gt; \u0026lt;li\u0026gt;大写字母\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;大写字母\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;ol type=\u0026#34;i\u0026#34;\u0026gt; \u0026lt;li\u0026gt;小写罗马数字\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;小写罗马数字\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 起始编号\n通过 start 属性设置起始编号：\n1 2 3 4 \u0026lt;ol start=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;li\u0026gt;从数字 5 开始\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;从数字 6 开始\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 3. 描述列表 \u0026lt;dl\u0026gt;\n定义：描述列表用\u0026lt;dl\u0026gt; 表示，包含描述项\u0026lt;dt\u0026gt; 和描述内容\u0026lt;dd\u0026gt;。\n用途：用于术语解释、属性说明等场景。\n基本语法\n1 2 3 4 5 6 \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;HTML\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;超文本标记语言\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;CSS\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;层叠样式表\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; 显示效果\nHTML 超文本标记语言 CSS 层叠样式表 4. 嵌套列表\n可以将列表嵌套在另一个列表中，支持任意深度。\n1 2 3 4 5 6 7 8 9 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;项目 1 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;子项目 1.1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;子项目 1.2\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;项目 2\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 显示效果\n项目 1 子项目 1.1 子项目 1.2 项目 2 5. CSS 样式定制列表\n5.1 自定义项目符号 可以通过 CSS 设置 list-style-type 或使用图片作为符号：\n1 2 3 \u0026lt;ul style=\u0026#34;list-style-image: url(\u0026#39;bullet.png\u0026#39;);\u0026#34;\u0026gt; \u0026lt;li\u0026gt;自定义符号\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 5.2 删除项目符号 设置 list-style: none; 可以移除符号：\n1 2 3 \u0026lt;ul style=\u0026#34;list-style: none;\u0026#34;\u0026gt; \u0026lt;li\u0026gt;无符号项目\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 5.3 设置列表间距 可以通过 margin 和 padding 调整：\n1 2 3 \u0026lt;ul style=\u0026#34;margin: 20px; padding: 10px;\u0026#34;\u0026gt; \u0026lt;li\u0026gt;调整间距\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 6. 特殊用法 6.1 自定义编号 通过 CSS 和伪元素创建完全自定义的编号样式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;普通样式\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;普通样式\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;style\u0026gt; ol { counter-reset: custom-counter; /* 初始化计数器 */ } ol \u0026gt; li { counter-increment: custom-counter; /* 递增计数器 */ } ol \u0026gt; li::before { content: \u0026#34;★ \u0026#34; counter(custom-counter) \u0026#34;. \u0026#34;; /* 自定义编号样式 */ color: red; } \u0026lt;/style\u0026gt; 2.10. 框架的使用 1. 基本结构\n使用 \u0026lt;frameset\u0026gt; 标签代替 \u0026lt;body\u0026gt;，通过 \u0026lt;frame\u0026gt; 标签定义每个框架的内容。\ncols 定义框架集中列的数目和尺寸 rows 定义框架集中行的数目和尺寸\n示例：两列布局\n1 2 3 4 \u0026lt;frameset cols=\u0026#34;50%,50%\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;left.html\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;right.html\u0026#34;\u0026gt; \u0026lt;/frameset\u0026gt; 说明：\n•\t\u0026lt;frameset\u0026gt;：定义框架的布局方式，取代 \u0026lt;body\u0026gt;。 •\tcols：定义列布局（水平分割），可用像素、百分比或 *。 •\trows：定义行布局（垂直分割），用法与 cols 类似。 •\t\u0026lt;frame\u0026gt;：定义每个框架加载的页面。 •\tsrc：指定每个框架加载的内容，可以是 HTML 文件或其他资源。\n2. 常见布局方式\n2.1 水平分割页面\n1 2 3 4 \u0026lt;frameset rows=\u0026#34;70%,30%\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;top.html\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;bottom.html\u0026#34;\u0026gt; \u0026lt;/frameset\u0026gt; 2.2 网格式布局\n1 2 3 4 5 6 7 \u0026lt;frameset rows=\u0026#34;50%,50%\u0026#34;\u0026gt; \u0026lt;frameset cols=\u0026#34;50%,50%\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;top-left.html\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;top-right.html\u0026#34;\u0026gt; \u0026lt;/frameset\u0026gt; \u0026lt;frame src=\u0026#34;bottom.html\u0026#34;\u0026gt; \u0026lt;/frameset\u0026gt; 3. 嵌套框架\n框架可以嵌套实现复杂布局。\n示例：上下左右分割页面\n1 2 3 4 5 6 7 \u0026lt;frameset rows=\u0026#34;80,*\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;header.html\u0026#34;\u0026gt; \u0026lt;frameset cols=\u0026#34;30%,70%\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;menu.html\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;content.html\u0026#34;\u0026gt; \u0026lt;/frameset\u0026gt; \u0026lt;/frameset\u0026gt; 4. 添加边框、滚动和标题\n框架可以通过属性设置样式：\nframeborder：设置边框（0 表示无边框）。\nscrolling：设置是否显示滚动条（yes、no、auto）。\nname：给框架命名，便于其他页面的链接跳转。\n示例\n1 2 3 4 \u0026lt;frameset cols=\u0026#34;70%,30%\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;content.html\u0026#34; name=\u0026#34;main\u0026#34; frameborder=\u0026#34;1\u0026#34; scrolling=\u0026#34;yes\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;menu.html\u0026#34; name=\u0026#34;menu\u0026#34; frameborder=\u0026#34;0\u0026#34; scrolling=\u0026#34;no\u0026#34;\u0026gt; \u0026lt;/frameset\u0026gt; 5. 框架中的链接跳转\n框架中的链接可以指定目标框架加载内容，通过 target 属性实现：\n示例：\n1 2 3 4 \u0026lt;frameset cols=\u0026#34;20%,80%\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;menu.html\u0026#34; name=\u0026#34;menu\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;content.html\u0026#34; name=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;/frameset\u0026gt; menu.html 中的链接：\n1 2 \u0026lt;a href=\u0026#34;page1.html\u0026#34; target=\u0026#34;main\u0026#34;\u0026gt;加载 Page 1\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;page2.html\u0026#34; target=\u0026#34;main\u0026#34;\u0026gt;加载 Page 2\u0026lt;/a\u0026gt; 6. 替代方案：使用现代技术\n由于框架的以下问题，HTML5 废弃了 \u0026lt;frameset\u0026gt; 和 \u0026lt;frame\u0026gt;：\n•\t不利于 SEO（搜索引擎无法有效索引）。 •\t用户体验差，不能轻松导航和书签管理。 •\t兼容性问题。 推荐使用现代技术：\n1.\tCSS Flexbox 和 Grid Layout：布局灵活且易于控制。 2.\t\u0026lt;iframe\u0026gt; 标签：加载独立页面到当前页面中。 示例：\u0026lt;iframe\u0026gt; 使用\n1 \u0026lt;iframe src=\u0026#34;page.html\u0026#34; width=\u0026#34;100%\u0026#34; height=\u0026#34;500px\u0026#34; frameborder=\u0026#34;0\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; ","date":"2024-11-12T20:43:19+08:00","permalink":"http://localhost:1313/p/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/","title":"网络安全"},{"content":"title=\u0026ldquo;Markdown语法\u0026rdquo;\n什么是MarkDown语法？ Markdown 致力于使阅读和创作文档变得容易。\nMarkdown是一种轻量级的标记语言，设计初衷是让人们可以使用简单的文本格式来书写和编辑文档，同时具有一定的格式化效果。通过使用Markdown语法，用户可以快速地将纯文本转换为格式化的文档，例如标题、列表、链接、图片等。Markdown语法简单直观，易于学习和使用，逐渐成为了各种平台上书写文档的常用格式，甚至还可以实现Markdown文档对PDF、Word等格式的快速转换。\nMarkdown的文件通常以.md或.markdown为扩展名\n我们可以创建一个TXT文本文档，然后将其后缀改为.md即可开始编辑此Markdown文档。\n基础语法讲解 段落和换行 Markdown文档与我们常见的Word文档或是TXT文档类似，只需要直接输入内容，就可以展示了：\n[][https://oss.itbaima.cn/internal/markdown/2024/04/01/HVqab9QUm4vw73P.png]\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/","title":""},{"content":"计算机发展历程 什么计算机系统 计算机系统=硬件+软件 硬件：计算机的实体，如主机、外设等 软件：由具有各类特殊作用的程序组成 计算机性能的好坏取决于“软”、“硬”件功能的总和 软件可以分为系统软件和应用软件 系统软件：用来管理整个计算机系统\u0026mdash;如操作系统、数据库管理系统（DBMS）、标准程序库、网络软件、语言处理程序、服务程序 应用软件：微信、哔哩哔哩等\u0026hellip; \u0026hellip; 硬件的发展 第一台计算机 台电子数字计算机：ENIAC(1946) 占地面积约170平方米 耗电量150千瓦 运算速度：5000次加法/秒 逻辑元件：电子管 四代计算机 发展阶段 时间 逻辑元件 速度(次/秒) 内存 外存 第一代 1946-1957 电子管 几千-几万 汞延迟线、磁鼓 穿孔卡片、纸带 第二代 1958-1964 晶体管 几万-几十万 磁芯存储器 磁带 第三代 1964-1971 中小规模集成 电路 几十万-几百万 半导体存储器 第四代 1972-现在 大规模、超大 规模集成电路 上千万-万亿 半导体存储器 磁盘、磁带、光盘、半导体存储器 各代计算机特点 第一代：电子管时代体积超大、耗电量超大 使用机器语言编程 逻辑元件：电子管 第二代：晶体管时代 体积、功耗降低 出现面向过程的程序设计语言：FORTRAN 有了操作系统雏形 逻辑元件：晶体管 第三代：中小规模集成电路时代 计算机主要用于科学计算等专业用途 高级语言迅速发展 开始有了分时操作系统 将元件集成在基片上 第四代：大规模、超大规模集成电路时代 开始出现“微处理器”、微型计算机个人计算机（PC）萌芽 操作系统：Windows、MacOS、Linux Eg：苹果A13制造工艺：7nm （每个元件宽度7nm） 拥有85亿个晶体管 微处理器的发展 微处理器的发展：微型计算机的发展以微处理器技术为标志 机器字长：计算机一次整数运算所能处理的二进制位数\n1947年，贝尔实验室，发明了“晶体管〞 1955年，肖克利在硅谷创建 肖克利实验室股份有限公司 1957年，八叛徒（traitorous eight）创立 仙童半导体公司 1959年，仙童半导体公司发明“集成电路“ 1968年，摩尔等人离开仙童，创立 Intel 1969年，仙童销售部负责人桑德斯离开仙童，创立 AMD 摩尔定律 摩尔定律揭示了信息技术进步的速度 集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，整体性能也将提升一倍 半导体存储器的发展 1970年，仙童公司生产出第一个较大容量的半导体存储器 半导体存储器单芯片容量：1KB、4KB、16KB、64KB、256KB、1MB、4MB、16MB、64MB、 256MB, 1GB\u0026hellip; 计算机硬件的基本组成 早期冯诺依曼机 “存储程序” “存储程序”的概念是指将指令以二进制代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。\n冯诺伊曼计算机的基本逻辑（注意流程图）\n输入设备：将信息转换成机器能识别的形式 存储器：存放数据和程序 运算器：算术运算逻辑运算 输出设备：将结果转换成人们熟悉的形式 控制器：指挥程序运行\n在计算机系统中，软件和硬件在逻辑上是等效的。 为什么说是等效的？：对于乘法运算，可以设计一个专门的硬件电路实现乘法运算也可以用软件的方式，执行多次加法运算来实现\n冯•诺依曼计算机的特点：\n计算机由五大部件组成 指令和数据以同等地位存于存储器，可按地址寻访（后文会有详细介绍） 指令和数据用二进制表示 指令由操作码（指明这条指令要干什么）和地址码（指明对哪一个内存单元进行操作）组成 存储程序 以运算器为中心（输入/输出设备与存储器之间的数据传送通过运算器完成） 现代计算机的结构 现代计算机：以存储器为中心 (输入设备直接放到存储器中) CPU=运算器+控制器 存储器=主存+辅存 (Eg:手机中的APP平常就存在辅存中，只有使用的时候才会调到主存) 主机=主存+CPU I/O设备=辅存+输入设备+输出设备 硬件=主机+I/O设备 Eg:像平常说的，手机内存8gb，指的就是主存储器是8gb ，机身存储128gb，就是指的辅存\n现代计算机简化图： 各个硬件的工作原理 主存储器的基本组成 主存储器=存储体+MAR+MDR Memory Address Register （存储地址寄存器） Memory Data Register （存储数据寄存器）\n寄存器：存放二进制数据\n存储单元：每个存储单元存放一串二进制代码 存储字（word）：存储单元中二进制代码的组合（一个字根据不同电脑的设置，大小是不一样的） 存储字长：存储单元中二进制代码的位数 存储元：即存储二进制的电子元件，每个存储元可存 1bit\nMAR位数反映存储单元的个数\n数据在存储体内按地址存储\nMDR位数=存储字长\n例： MAR=4位 总共有24个存储单元 MDR=16位 每个存储单元可存放16bit， 1个字(word) = 16bit 易混淆：1个字节（Byte）= 8bit 1B=1个字节，1b=1个bit\n运算器的基本组成 运算器：用于实现算术运算（如：加减乘除）、逻辑运算（如：与或非） ACC:累加器，用于存放操作数，或运算结果。 MQ:乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。 X:通用的操作数寄存器，用于存放操作数 ALU:算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算 加 减 乘 除 ACC 被加数、和 被减数、差 乘积高位 MQ 乘数、乘积低位 X 加数 减数 被乘数 ACC:Accumulator MQ:Multiple-Quotient Register ALU:Arithmetic and Logic Unit 控制器的基本组成 控制器由CU、IR和PC组成： CU：控制单元，分析指令，给出控制信号 IR：指令寄存器，存放当前执行的指令 PC：程序计数器，存放下一条指令地址，有自动加1功能 Control Unit Instruction Register Program Counter 完成一条指令：取指令-\u0026gt;分析指令-\u0026gt;执行指令 取指=PC+IR CU 执行 计算机的工作过程 PC 主存地址 指令 注释 0 操作码：000001 地址码：0000000101 取数a至ACC 1 操作码：000100 地址码：0000000110 乘得ab，存于ACC中 2 操作码：000011 地址码：0000000111 加c得ab+c，存于ACC中 3 操作码000010 地址码：0000001000 将ab+c.存于主存单元 4 操作码：000110 地址码：0000000000 停机 5 0000000000000010 原始数据a=2 6 0000000000000011 原始数据b=3 7 0000000000000001 原始数据c=1 8 0000000000000000 原始数据y=0 流程图 注：取指令（#1~#4） 分析指令（#5） 执行取数指令（#6~#9）\n初：（PC）=0，指向第一条指令的存储地址 #1: (PC)→MAR, 导致(MAR)=0 #3: M(MAR)→MDR, 导致(MDR)=000001 0000000101 #4: (MDR)→IR, 导致(|R)=000001 0000000101 #5:OP(IR)→CU，指令的操作码送到CU，CU分析后得知，这是“取数”指令 #6:Ad(IR)→MAR，指令的地址码送到MAR，导致（MAR）=5 #8: M(MAR)→MDR, 导致(MDR)=0000000000000010=2 #9: (MDR)→ACC, 导致(ACC)=0000000000000010=2\n取指令（#1~#4） 分析指令（#5） 执行乘法指令（#6~#11）\n上一条指令取指后PC自动+1，（PC）=1；执行后，（ACC）=2 #1: (PC)→MAR, 导致(MAR)=1 #3: M(MAR)→MDR, 导致(MDR)=000100 0000000110 #4: (MDR)→IR, 导致(IR)= 000100 0000000110 #5:OP（IR）\u0026gt;CU，指令的操作码送到CU，CU分析后得知，这是“乘法”指令 #6：Ad（IR）\u0026gt;MAR，指令的地址码送到MAR，导致（MAR）=6 #8: M(MAR)→MDR, 导致(MDR)=0000000000000011=3 #9：(MDR)→MQ，导致(MQ)=0000000000000011=3 #10：(ACC)X，导致(X)=2 #11：(MQ)*(X)→ACC，由ALU实现乘法运算，导致（ACC）=6，如果乘积太大，则需要MQ辅助存储\n取指令（#1~#4） 分析指令（#5） 执行加法指令（#6~#10）\n上一条指令取指后（PC）=2，执行后，（ACC）=6 #1：(PC)→MAR，导致（MAR）=2 #3: M(MAR)→MDR, 导致(MDR)= 000011 0000000111 #4：(MDR)→IR，导致(IR)= 000011 0000000111 #5:OP(IR)→CU，指令的操作码送到CU，CU分析后得知，这是“加法”指令 #6:Ad(IR)→MAR，指令的地址码送到MAR，导致（MAR）=7 #8: M(MAR) →MDR, 导致(MDR)=0000000000000001=1 #9: (MDR)→X, 导致(X)=0000000000000001=1 #10：（ACC）+（X） ACC，导致（ACC）=7，由ALU实现加法运算\n取指令（#1~#4） 分析指令（#5） 执行存数指令（#6~#9）\n上一条指令取指后（PC）=4 #1: (PC)→MAR, 导致(MAR)=3 #3: M(MAR)→MDR, 导致(MDR)=000110 00000 #4：(MDR)→IR，导致(IR)= 000110 0000000000 #5:OP(IR)→ CU，指令的操作码送到CU，CU分析后得知，这是“停机”指令 （利用中断机制通知操作系统终止该进程）\n注：现在的计算机通常把MAR、MDR也集成在CPU中\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/","title":"计算机组成原理"}]